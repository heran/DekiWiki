<?xml version="1.0"?>
<doc>
    <assembly>
        <name>mindtouch.dream</name>
    </assembly>
    <members>
        <member name="T:MindTouch.Data.DataColumnAttribute">
            <summary>
            Markup attribute for defining entity/database column mappings
            </summary>
        </member>
        <member name="F:MindTouch.Data.DataColumnAttribute.Name">
            <summary>
            Database column name for entity field.
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataColumnAttribute.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataColumnAttribute.#ctor(System.String)">
            <summary>
            Createa a new instance.
            </summary>
            <param name="name">Initial field name value.</param>
        </member>
        <member name="T:MindTouch.Data.DataUpgradeAttribute">
            <summary>
            This attribute is used to mark the class that is responsible to update the database
            </summary>
        </member>
        <member name="T:MindTouch.Data.EffectiveVersionAttribute">
            <summary>
            This attribute is used to mark methods that update the database to a specific version
            </summary>
        </member>
        <member name="T:MindTouch.Data.ADataUpdater">
            <summary>
            Provides an interface for updating Data in Dream Applications
            </summary>
        </member>
        <member name="M:MindTouch.Data.IDataUpdater.GetMethods">
            <summary>
             Get a list of methods that will be run
            </summary>
            <returns>
             List of method names
            </returns>
        </member>
        <member name="M:MindTouch.Data.IDataUpdater.TestConnection">
            <summary>
            Tests the connection with the Data Store 
            that is to be updated. Throws an Exception 
            if an error occurs.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Data.IDataUpdater.LoadMethods(System.Reflection.Assembly)">
            <summary>
            Loads the Methods to run into a list 
            </summary>
            <param name="updateAssembly">Assembly object to perform reflection on</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Data.IDataUpdater.LoadMethodsAndExecute(System.Reflection.Assembly)">
            <summary>
            Loads the Methods to run into a list amd executes them
            </summary>
            <param name="updateAssembly">Assembly object to perform reflection on</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Data.IDataUpdater.Execute">
            <summary>
            Execute the methods in the assembly
            </summary>
        </member>
        <member name="M:MindTouch.Data.IDataUpdater.ExecuteMethod(System.String)">
            <summary>
            Execute the method with the given name
            <param name="name">Name of the method to execute. Case Sensitive.</param>
            </summary>
        </member>
        <member name="P:MindTouch.Data.IDataUpdater.EffectiveVersion">
            <summary>
             Get or set the effective version
            </summary>
            <returns> The string representation of the effective version</returns>
        </member>
        <member name="M:MindTouch.Data.ADataUpdater.GetMethods">
            <summary>
             Get a list of methods that will be run
            </summary>
            <returns>
             List of method names
            </returns>
        </member>
        <member name="M:MindTouch.Data.ADataUpdater.TestConnection">
            <summary>
            Tests the connection with the Data Store 
            that is to be updated. Throws an Exception 
            if an error occurs.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Data.ADataUpdater.LoadMethods(System.Reflection.Assembly)">
            <summary>
            Loads the Methods to run into a list 
            </summary>
            <param name="updateAssembly">Assembly object to perform reflection on</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Data.ADataUpdater.LoadMethodsAndExecute(System.Reflection.Assembly)">
            <summary>
            Loads the Methods to run into a list amd executes them
            </summary>
            <param name="updateAssembly">Assembly object to perform reflection on</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Data.ADataUpdater.Execute">
            <summary>
            Execute the methods in the assembly
            </summary>
        </member>
        <member name="M:MindTouch.Data.ADataUpdater.ExecuteMethod(System.String)">
            <summary>
            Execute the method with the given name
            <param name="name">Name of the method to execute. Case Sensitive.</param>
            </summary>
        </member>
        <member name="M:MindTouch.Data.ADataUpdater.CreateActivatorInstance(System.Type)">
            <summary>
            Create instance of class defined by the provided Type
            <param name="dataUpgradeType">"The Type instance to activate"</param>
            </summary>
        </member>
        <member name="P:MindTouch.Data.ADataUpdater.EffectiveVersion">
            <summary>
             Get or set the effective version
            </summary>
            <returns> The string representation of the effective version</returns>
        </member>
        <member name="T:MindTouch.Dream.AutoFacEx">
            <summary>
            Extension methods for defining Autofac registration scope
            </summary>
        </member>
        <member name="M:MindTouch.Dream.AutoFacEx.InScope(Autofac.Registrars.IConcreteRegistrar,MindTouch.Dream.DreamContainerScope)">
            <summary>
            Set the registered item's container resolution scope.
            </summary>
            <param name="registrar">Registrar instance.</param>
            <param name="scope">Container Resolution scope.</param>
            <returns>The modified registrar instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.AutoFacEx.HostScoped(Autofac.Registrars.IConcreteRegistrar)">
            <summary>
            Set the registered item's contrainer resolution scope to <see cref="F:MindTouch.Dream.DreamContainerScope.Host"/>
            </summary>
            <param name="registrar">Registrar instance.</param>
            <returns>The modified registrar instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.AutoFacEx.ServiceScoped(Autofac.Registrars.IConcreteRegistrar)">
            <summary>
            Set the registered item's contrainer resolution scope to <see cref="F:MindTouch.Dream.DreamContainerScope.Service"/>
            </summary>
            <param name="registrar">Registrar instance.</param>
            <returns>The modified registrar instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.AutoFacEx.RequestScoped(Autofac.Registrars.IConcreteRegistrar)">
            <summary>
            Set the registered item's contrainer resolution scope to <see cref="F:MindTouch.Dream.DreamContainerScope.Request"/>
            </summary>
            <param name="registrar">Registrar instance.</param>
            <returns>The modified registrar instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.AutoFacEx.InScope(Autofac.Registrars.IReflectiveRegistrar,MindTouch.Dream.DreamContainerScope)">
            <summary>
            Set the registered item's container resolution scope.
            </summary>
            <param name="registrar">Registrar instance.</param>
            <param name="scope">Container Resolution scope.</param>
            <returns>The modified registrar instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.AutoFacEx.HostScoped(Autofac.Registrars.IReflectiveRegistrar)">
            <summary>
            Set the registered item's contrainer resolution scope to <see cref="F:MindTouch.Dream.DreamContainerScope.Host"/>
            </summary>
            <param name="registrar">Registrar instance.</param>
            <returns>The modified registrar instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.AutoFacEx.ServiceScoped(Autofac.Registrars.IReflectiveRegistrar)">
            <summary>
            Set the registered item's contrainer resolution scope to <see cref="F:MindTouch.Dream.DreamContainerScope.Service"/>
            </summary>
            <param name="registrar">Registrar instance.</param>
            <returns>The modified registrar instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.AutoFacEx.RequestScoped(Autofac.Registrars.IReflectiveRegistrar)">
            <summary>
            Set the registered item's contrainer resolution scope to <see cref="F:MindTouch.Dream.DreamContainerScope.Request"/>
            </summary>
            <param name="registrar">Registrar instance.</param>
            <returns>The modified registrar instance.</returns>
        </member>
        <member name="T:MindTouch.Dream.DreamContainerScope">
            <summary>
            Singleton ownership scope of items resolved from a container. 
            </summary>
            <remarks>
            Dream uses a nested hierarchy of one host container, per service containers and per request (per service) containers.
            The singleton ownership and lifespan of an instance resolved at from any container will goverened by its scope,
            rather than the container. The only exception are <see cref="F:MindTouch.Dream.DreamContainerScope.Factory"/> scoped instances which are created new on each resolution,
            while their lifespan is governed by the container they were resolved from.
            </remarks>
        </member>
        <member name="F:MindTouch.Dream.DreamContainerScope.Host">
            <summary>
            Singleton belonging to the host container.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContainerScope.Service">
            <summary>
            Singleton belonging to the current service's container.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContainerScope.Request">
            <summary>
            Singleton belonging to the current request's container.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContainerScope.Factory">
            <summary>
            Per call instance.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamFeatureStage">
            <summary>
            Provides a single stage in a <see cref="T:MindTouch.Dream.DreamFeature"/> processing chain.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeatureStage.Name">
            <summary>
            Stage name.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeatureStage.Access">
            <summary>
            Stage access level.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamFeatureStage.#ctor(System.String,MindTouch.Tasking.CoroutineHandler{MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage}},MindTouch.Dream.DreamAccess)">
            <summary>
            Creates a new stage instance.
            </summary>
            <param name="name">Stage name.</param>
            <param name="handler">Stage handler.</param>
            <param name="access">Stage access level.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamFeatureStage.#ctor(MindTouch.Dream.IDreamService,System.Reflection.MethodInfo,MindTouch.Dream.DreamAccess)">
            <summary>
            Creates a new stage instance.
            </summary>
            <param name="service">Service instance to which the stage belongs to.</param>
            <param name="method">Method definintion for stage handler.</param>
            <param name="access">Stage access level.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamFeatureStage.Invoke(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the stage method.
            </summary>
            <param name="context"><see cref="T:MindTouch.Dream.DreamContext"/> for invocation.</param>
            <param name="request"><see cref="T:MindTouch.Dream.DreamMessage"/> for invocation.</param>
            <param name="response"><see cref="T:MindTouch.Tasking.Result`1"/> for invocations.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamServiceConfigurationBuilder">
            <summary>
            Concrete implementation of <see cref="T:MindTouch.Dream.IDreamServiceConfigurationBuilder"/>.
            </summary>
            <remarks>
             Cannot be used by itself since only configuration invocation happens via callback providing the instance.
            </remarks>
        </member>
        <member name="T:MindTouch.Dream.IDreamServiceConfigurationBuilder">
            <summary>
            Fluent interface for confirguring a <see cref="T:MindTouch.Dream.IDreamService"/> registration.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.IDreamServiceConfigurationBuilder.AtPath(System.String)">
            <summary>
            The path at which the service is to be instantiated.
            </summary>
            <param name="path">Full path to service.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.IDreamServiceConfigurationBuilder.WithConfig(MindTouch.Xml.XDoc)">
            <summary>
            Full configuration for service.
            </summary>
            <remarks>Values can be overwritten by keys set via <see cref="M:MindTouch.Dream.IDreamServiceConfigurationBuilder.With(System.String,System.String)"/>.</remarks>
            <param name="config">Service configuration document.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.IDreamServiceConfigurationBuilder.With(System.String,System.String)">
            <summary>
            Add a configuration key/value pair.
            </summary>
            <param name="key">Key to add.</param>
            <param name="value">Value to add.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.IDreamServiceConfigurationBuilder.With(System.String,MindTouch.Xml.XDoc)">
            <summary>
            Add a configuration key/value pair.
            </summary>
            <param name="key">Key to add.</param>
            <param name="childDoc">Child document value to add.</param>
            <returns>This instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.IDreamServiceConfigurationBuilder.SkipIfExists">
            <summary>
            Skip configuring this service if one already exists at its path.
            </summary>
            <returns>This instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceConfigurationBuilder.#ctor(System.Type)">
            <summary>
            Create a new configuration for a given type.
            </summary>
            <param name="type"><see cref="T:MindTouch.Dream.IDreamService"/> instance to configure.</param>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceConfigurationBuilder.ServiceType">
            <summary>
            Type of the <see cref="T:MindTouch.Dream.IDreamService"/> configured by this instance.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceConfigurationBuilder.Path">
            <summary>
            Server path the service is to be located at.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceConfigurationBuilder.SkipServiceIfExists">
            <summary>
            True if service configuration is to be skipped if one already exists at the specified <see cref="P:MindTouch.Dream.DreamServiceConfigurationBuilder.Path"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceConfigurationBuilder.ServiceConfig">
            <summary>
            Retrieve the service configuration document.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamServiceRegistrationBuilder">
            <summary>
            Fluent configuration helper for creating creating a Dream service startup script
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceRegistrationBuilder.RegisterService``1">
            <summary>
            Register a service using default conventions.
            </summary>
            <remarks>
            Default convention means no config values and path is either Foo for FooService or type name if not postfixed with Service.
            </remarks>
            <typeparam name="T"><see cref="T:MindTouch.Dream.IDreamService"/> to register.</typeparam>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceRegistrationBuilder.RegisterService``1(System.Action{MindTouch.Dream.IDreamServiceConfigurationBuilder})">
            <summary>
            Register a service with callback for configuration.
            </summary>
            <typeparam name="T"><see cref="T:MindTouch.Dream.IDreamService"/> to register.</typeparam>
            <param name="configurationCallback">Callback for modifying the created <see cref="T:MindTouch.Dream.IDreamServiceConfigurationBuilder"/> instance.</param>
            <returns>
            True if service was configured (only possible to be false if <see cref="M:MindTouch.Dream.IDreamServiceConfigurationBuilder.SkipIfExists"/> was
            specified and a service already exists at the configured path.
            </returns>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceRegistrationBuilder.RegisterService(System.Type,System.Action{MindTouch.Dream.IDreamServiceConfigurationBuilder})">
            <summary>
            Register a service with callback for configuration.
            </summary>
            <param name="serviceType">Type of <see cref="T:MindTouch.Dream.IDreamService"/> to register.</param>
            <param name="configurationCallback">Callback for modifying the created <see cref="T:MindTouch.Dream.IDreamServiceConfigurationBuilder"/> instance.</param>
            <returns>
            True if service was configured (only possible to be false if <see cref="M:MindTouch.Dream.IDreamServiceConfigurationBuilder.SkipIfExists"/> was
            specified and a service already exists at the configured path.
            </returns>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceRegistrationBuilder.Build">
            <summary>
            Build a service configuration script for posting against host/services from the presently configured services.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceRegistrationBuilder.ScanAssemblyForServices(System.Reflection.Assembly)">
            <summary>
            Scan the provided assembly for all <see cref="T:MindTouch.Dream.IDreamService"/> that live in a namespace ending with .Services and configure them
            by convention.
            </summary>
            <param name="assembly">Assembly to scan.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceRegistrationBuilder.ScanAssemblyForServices(System.Reflection.Assembly,System.Func{System.Type,System.Boolean})">
            <summary>
            Scan the provided assembly for <see cref="T:MindTouch.Dream.IDreamService"/> that live in a namespace ending with .Services and configure them
            by convention.
            </summary>
            <param name="assembly">Assembly to scan.</param>
            <param name="filter">Filter expression to exclude services.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceRegistrationBuilder.ScanAssemblyForServices(System.Reflection.Assembly,System.Func{System.Type,System.Boolean},System.Action{System.Type,MindTouch.Dream.IDreamServiceConfigurationBuilder})">
            <summary>
            Scan the provided assembly for <see cref="T:MindTouch.Dream.IDreamService"/> that live in a namespace ending with .Services and configure them.
            </summary>
            <param name="assembly">Assembly to scan.</param>
            <param name="filter">Filter expression to exclude services.</param>
            <param name="configurationCallback">Configuration callback expression to be called for each <see cref="T:System.Type"/> to be configured.</param>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueue">
            <summary>
            Dispatch Queue used by <see cref="T:MindTouch.Dream.Services.PubSub.Dispatcher"/> for events with applicable subscription.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueue.Enqueue(MindTouch.Dream.Services.PubSub.DispatchItem)">
            <summary>
            Enqueue a new item to dispatch.
            </summary>
            <param name="item"></param>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueue.FailureWindow">
            <summary>
            Duration of the current chain of failures, <see cref="F:System.TimeSpan.Zero"/> if no failures are currently occuring.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository">
            <summary>
            Repository for dispatch queues by subscription.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository.GetUninitializedSets">
            <summary>
            Retrieve all sets that the repository has loaded from its optional storage. This will only return data before <see cref="M:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository.InitializeRepository(System.Func{MindTouch.Dream.Services.PubSub.DispatchItem,MindTouch.Tasking.Result{System.Boolean}})"/> is called, after which the sets will be initialized with queues.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository.InitializeRepository(System.Func{MindTouch.Dream.Services.PubSub.DispatchItem,MindTouch.Tasking.Result{System.Boolean}})">
            <summary>
            Attach the dequeue handler to use for constructing dispatch queues. Calling this will also initalize queues for all sets found in <see cref="M:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository.GetUninitializedSets"/>.
            </summary>
            <param name="dequeueHandler">Callback for items to be dispatched.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository.RegisterOrUpdate(MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet)">
            <summary>
            Register or update an existing set and its queue.
            </summary>
            <param name="set">The set to register.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository.Delete(MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet)">
            <summary>
            Delete a set and its queue. Has no effect if the set isn't registered.
            </summary>
            <param name="set">The set to be deleted.</param>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository.Item(MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet)">
            <summary>
            Retrieve the queue for a subscription.
            </summary>
            <param name="set"><see cref="T:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet"/> identifying the dispatch queue.</param>
            <returns>Returns the dispatch queue or null, if there is no queue for that set.</returns>
        </member>
        <member name="T:MindTouch.IO.IQueueItemSerializer`1">
            <summary>
            Defines a serializer that can convert a type to and from a Stream.
            </summary>
            <remarks>
            Exists primarily for use with <see cref="T:MindTouch.Collections.TransactionalQueue`1"/>
            </remarks>
            <typeparam name="T">Any type</typeparam>
        </member>
        <member name="M:MindTouch.IO.IQueueItemSerializer`1.ToStream(`0)">
            <summary>
            Convert type T to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            It is assumed that the returned stream is read from beginning to end and contains only the binary data for the serialized item.
            </remarks>
            <param name="item">An instance of type T</param>
            <returns>A <see cref="T:System.IO.Stream"/> containing the binary formatted type T</returns>
        </member>
        <member name="M:MindTouch.IO.IQueueItemSerializer`1.FromStream(System.IO.Stream)">
            <summary>
            Create an instance of type T from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            It is assumed that the provided stream is read from beginning to end and contains only the binary data for the item to be deserialized.
            </remarks>
            <param name="stream">A <see cref="T:System.IO.Stream"/> contained the binary formatted type T</param>
            <returns>A new instance of type T</returns>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.DispatchItem">
            <summary>
            Serializable container for an <see cref="T:MindTouch.Dream.Services.PubSub.DispatcherEvent"/> for a specific <see cref="T:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet"/> identified by its location.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatchItem.Uri">
            <summary>
            Uri the event will be dispatched to.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatchItem.Event">
            <summary>
            Event to dispatch.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatchItem.Location">
            <summary>
            Location string identifying the <see cref="T:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet"/> the event is being dispatched for.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatchItem.#ctor(MindTouch.Dream.XUri,MindTouch.Dream.Services.PubSub.DispatcherEvent,System.String)">
            <summary>
            Create a new dispatch item
            </summary>
            <param name="uri">Uri the event will be dispatched to.</param>
            <param name="event">Event to dispatch.</param>
            <param name="location">Location string identifying the <see cref="T:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet"/> the event is being dispatched for.</param>
        </member>
        <member name="T:MindTouch.Extensions.ReflectionEx">
            <summary>
            Provides extension methods relating to <see cref="T:System.Reflection.MethodInfo"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Extensions.ReflectionEx.InvokeWithRethrow(System.Reflection.MethodInfo,System.Object,System.Object[])">
            <summary>
            Invokes the method or constructor represented by the current instance, using the specified parameters.  Automatically rethrows the inner exception of a <see cref="T:System.Reflection.TargetInvocationException"/>.
            </summary>
            <param name="method">Method or constructor to invoke.</param>
            <param name="subject">The object on which to invoke the method or constructor. If a method is static, this argument is ignored. If the a constructor is static, this argument must be null.</param>
            <param name="arguments">An argument list for the invoked method or constructor.</param>
            <returns>Returns the value returned by the invoked method or constructor.</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToInt(System.UInt32)">
            <summary>
            Safely convert an unsigned integer to an int. If the unsigned integer is greater than int.MaxValue, int.MaxValue is returned.
            </summary>
            <param name="value">Unsigned integer</param>
            <returns>Integer</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToInt(System.Int64)">
            <summary>
            Safely convert an long integer to an int. If the long integer is greater than int.MaxValue, int.MaxValue is returned.
            </summary>
            <param name="value">long integer</param>
            <returns>Integer</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToInt(System.UInt64)">
            <summary>
            Safely convert an unsigned long integer to an int. If the unsigned long integer is greater than int.MaxValue, int.MaxValue is returned.
            </summary>
            <param name="value">Unsigned integer</param>
            <returns>Integer</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToUInt(System.UInt64)">
            <summary>
            Safely convert an unsigned long integer to an unsigned integer. If the unsigned long integer is greater than uint.MaxValue, uint.MaxValue is returned.
            </summary>
            <param name="value">Unsigned long integer</param>
            <returns>Unsigned Integer</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToLong(System.UInt64)">
            <summary>
            Safely convert an unsigned long integer to an int. If the unsigned integer is greater than long.MaxValue, long.MaxValue is returned.
            </summary>
            <param name="value">Unsigned long integer</param>
            <returns>Long Integer</returns>
        </member>
        <member name="M:MindTouch.Numeric.SafeAdd(System.Int32,System.Int32)">
            <summary>
            Safely add two integers, remaining bounded by int.MinValue and int.MaxValue.
            </summary>
            <param name="a">left hand side of addition</param>
            <param name="b">right hand side of addtion</param>
            <returns>Signed integer</returns>
        </member>
        <member name="M:MindTouch.Numeric.SafeAdd(System.UInt32,System.UInt32)">
            <summary>
            Safely add two unsigned integers, remaining bounded by uint.MinValue and uint.MaxValue.
            </summary>
            <param name="a">left hand side of addition</param>
            <param name="b">right hand side of addtion</param>
            <returns>Unsigned integer</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToCommaDelimitedString(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Convert a sequence of numbers into a commma separated string
            </summary>
            <param name="ids">Sequence of numbers</param>
            <returns>Comma separated string</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToCommaDelimitedString(System.Collections.Generic.IEnumerable{System.UInt32})">
            <summary>
            Convert a sequence of numbers into a commma separated string
            </summary>
            <param name="ids">Sequence of numbers</param>
            <returns>Comma separated string</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToCommaDelimitedString(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Convert a sequence of numbers into a commma separated string
            </summary>
            <param name="ids">Sequence of numbers</param>
            <returns>Comma separated string</returns>
        </member>
        <member name="M:MindTouch.Numeric.ToCommaDelimitedString(System.Collections.Generic.IEnumerable{System.UInt64})">
            <summary>
            Convert a sequence of numbers into a commma separated string
            </summary>
            <param name="ids">Sequence of numbers</param>
            <returns>Comma separated string</returns>
        </member>
        <member name="M:MindTouch.Numeric.CommaDelimitedToUInt(System.String)">
            <summary>
            Convert a comma-separated string of numbers into a sequence of numbers.
            </summary>
            <param name="commaDelimited">comma delimited string</param>
            <returns>Sequence of numbers or an empty sequence, if the string was empty</returns>
        </member>
        <member name="M:MindTouch.Numeric.CommaDelimitedToInt(System.String)">
            <summary>
            Convert a comma-separated string of numbers into a sequence of numbers.
            </summary>
            <param name="commaDelimited">comma delimited string</param>
            <returns>Sequence of numbers or an empty sequence, if the string was empty</returns>
        </member>
        <member name="M:MindTouch.Numeric.CommaDelimitedToULong(System.String)">
            <summary>
            Convert a comma-separated string of numbers into a sequence of numbers.
            </summary>
            <param name="commaDelimited">comma delimited string</param>
            <returns>Sequence of numbers or an empty sequence, if the string was empty</returns>
        </member>
        <member name="M:MindTouch.Numeric.CommaDelimitedToLong(System.String)">
            <summary>
            Convert a comma-separated string of numbers into a sequence of numbers.
            </summary>
            <param name="commaDelimited">comma delimited string</param>
            <returns>Sequence of numbers or an empty sequence, if the string was empty</returns>
        </member>
        <member name="T:System.GitBranchAttribute">
            <summary>
            Assembly attribute used by MindTouch build system to track revision control branch name with the Assembly.
            </summary>
        </member>
        <member name="M:System.GitBranchAttribute.#ctor(System.String)">
            <summary>
            Default constructor used by Attribute syntax.
            </summary>
            <param name="branch">Subversion branch name for Assembly.</param>
        </member>
        <member name="P:System.GitBranchAttribute.Branch">
            <summary>
            Accessor for branch name attached via attribute.
            </summary>
        </member>
        <member name="T:System.GitRevisionAttribute">
            <summary>
            Assembly attribute used by MindTouch build system to track subversion revision number with the Assembly.
            </summary>
        </member>
        <member name="M:System.GitRevisionAttribute.#ctor(System.String)">
            <summary>
            Default constructor used by Attribute syntax.
            </summary>
            <param name="revision">Subversion revision number for the Assembly.</param>
        </member>
        <member name="P:System.GitRevisionAttribute.Revision">
            <summary>
            Accessor for revsion number attached via attribute.
            </summary>
        </member>
        <member name="T:System.GitUriAttribute">
            <summary>
            Assembly attribute used by MindTouch build system to track revision control uri name with the Assembly.
            </summary>
        </member>
        <member name="M:System.GitUriAttribute.#ctor(System.String)">
            <summary>
            Default constructor used by Attribute syntax.
            </summary>
            <param name="uri">Revision control uri name for Assembly.</param>
        </member>
        <member name="P:System.GitUriAttribute.Uri">
            <summary>
            Accessor for Revision Control Uri attached via attribute.
            </summary>
        </member>
        <member name="T:System.ShouldNeverHappenException">
            <summary>
            Provides a common exception for situations that should never occur.
            </summary>
        </member>
        <member name="M:System.ShouldNeverHappenException.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:System.ShouldNeverHappenException.#ctor(System.String)">
            <summary>
            Create a new instance with a custom message.
            </summary>
            <param name="message">Custom message to include in exception.</param>
        </member>
        <member name="T:MindTouch.IO.BinaryFormatterSerializer">
            <summary>
            Provides an implementation of <see cref="T:MindTouch.IO.ISerializer"/> capable of serialzing any type marked with the <see cref="T:System.SerializableAttribute"/>
            attribute.
            </summary>
        </member>
        <member name="T:MindTouch.IO.ISerializer">
            <summary>
            Provides a stream based contract for serializing types to binary and back.
            </summary>
            <remarks>
            This contract assumes that implementations will only read from and write to the stream and not try to alter it otherwise.
            </remarks>
        </member>
        <member name="M:MindTouch.IO.ISerializer.Deserialize``1(System.IO.Stream)">
            <summary>
            Return an instance of the specified type by reading from the <see cref="T:System.IO.Stream"/> at its current position.
            </summary>
            <remarks>
            The serializer must be smart enough to know when it has reached the end of the type's byte sequence, rather than reading
            until the end of stream.
            </remarks>
            <typeparam name="T">Type of the instance to deserialize.</typeparam>
            <param name="stream">Source stream.</param>
            <returns>Deserialized instance.</returns>
        </member>
        <member name="M:MindTouch.IO.ISerializer.Serialize``1(System.IO.Stream,``0)">
            <summary>
            Write the provided instance at the current position in the stream.
            </summary>
            <typeparam name="T">Type of the instance to serialize.</typeparam>
            <param name="stream">Destination stream.</param>
            <param name="data">Instance to be serialized.</param>
        </member>
        <member name="T:MindTouch.Cache.IKeyValueCache">
            <summary>
            Public contract for key/value cache's to be offered by Dream.
            </summary>
            <remarks>
            <p>It should be excepted that any value stored in the <see cref="T:MindTouch.Cache.IKeyValueCache"/> may be discarded at any time. A Time-to-live
            does not provide any guarantee that the value will remain in the cache that long, it merely means that after that time the value
            will not be returned by the cache.</p>
            <p>
            All values stored in the cache are stored as binary copies, not as references. The cache will never hold on to a reference. This does
            mean that all values need to be serializable by the cache. It is is assumed that cache's are constructed via an implementation of 
            <see cref="T:MindTouch.Cache.IKeyValueCacheFactory"/>, which provides a mechanism for registering <see cref="T:MindTouch.IO.ISerializer"/> instances for this purpose.
            </p>
            </remarks>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCache.Delete(System.String)">
            <summary>
            Delete a value from the cache.
            </summary>
            <param name="key">Key to identify the value by.</param>
            <returns><see langword="True"/> if the value was deleted.</returns>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCache.TryGet``1(System.String,``0@)">
            <summary>
            Try to retrieve a value from the cache.
            </summary>
            <typeparam name="T">Type the value to be returned.</typeparam>
            <param name="key">Key to identify the value by.</param>
            <param name="value">Output slot for value, if it was retrieved. Must be deserializable by the cache.</param>
            <returns><see langword="True"/> if the value was returned.</returns>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCache.Set``1(System.String,``0,System.TimeSpan)">
            <summary>
            Add a value to the cache.
            </summary>
            <remarks>
            The time-to-live only guarantees that the value will no longer be retrievable after the specified time. It doesn not mean that the
            value is guaranteed to be in the cache for the specified time. A ttl of <see cref="F:System.TimeSpan.MinValue"/> leaves disposal of
            the value up to the cache implementation.
            </remarks>
            <typeparam name="T">Type the value to be stored.</typeparam>
            <param name="key">Key to identify the value by.</param>
            <param name="value">Value to be stored. Must be serializable by the cache.</param>
            <param name="ttl">Maximum time-to-live for the value in the cache. A ttl of <see cref="F:System.TimeSpan.MinValue"/> leaves disposal of
            the value up to the cache implementation.</param>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCache.Clear">
            <summary>
            Clear the cache. 
            </summary>
            <remarks>Not guaranteed to be atomic.</remarks>
        </member>
        <member name="T:MindTouch.Cache.IKeyValueCacheFactory">
            <summary>
            Common contract for <see cref="T:MindTouch.Cache.IKeyValueCache"/> factories. Meant to unify creation of cache instances and serializer registration.
            </summary>
            <remarks>
            See <see cref="T:MindTouch.Cache.KeyValueCacheFactory"/> as a common base for building a factory, although it can also be used for construction of
            <see cref="T:MindTouch.Cache.IKeyValueCache"/> implementation without subtyping it.
            </remarks>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCacheFactory.SetSerializer``1(MindTouch.IO.ISerializer)">
            <summary>
            Register a serializer for a specific type.
            </summary>
            <typeparam name="T">Type the serializer is responsible for.</typeparam>
            <param name="serializer">A serializer instance.</param>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCacheFactory.SetSerializer(MindTouch.IO.ISerializer,System.Type)">
            <summary>
            Register a serializer for a specific type.
            </summary>
            <param name="serializer">A serializer instance.</param>
            <param name="type">Type the serializer is responsible for.</param>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCacheFactory.RemoveSerializer``1">
            <summary>
            Remove a serializer for a specific type.
            </summary>
            <typeparam name="T">Type the serializer is responsible for.</typeparam>
            <returns><see langword="True"/> if a serializer for the specified type was registered.</returns>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCacheFactory.RemoveSerializer(System.Type)">
            <summary>
            Remove a serializer for a specific type.
            </summary>
            <param name="type">Type the serializer is responsible for.</param>
            <returns><see langword="True"/> if a serializer for the specified type was registered.</returns>
        </member>
        <member name="M:MindTouch.Cache.IKeyValueCacheFactory.Create">
            <summary>
            Create a new <see cref="T:MindTouch.Cache.IKeyValueCache"/> instance.
            </summary>
            <remarks>
            The cache is assumed to be provided all registered serializers and their type mappings. It is also assumed that serializers
            added to the factory after the instance is created are not visible to the instance.
            </remarks>
            <returns>A new cache instance.</returns>
        </member>
        <member name="P:MindTouch.Cache.IKeyValueCacheFactory.Serializers">
            <summary>
            All serializers registered with this factory.
            </summary>
        </member>
        <member name="P:MindTouch.Cache.IKeyValueCacheFactory.DefaultSerializer">
            <summary>
            Default serializer to fire for all types lacking an explicit serializer.
            </summary>
        </member>
        <member name="T:MindTouch.Cache.InMemoryKeyValueCacheFactory">
            <summary>
            Provides a factory for the <see cref="T:MindTouch.Cache.InMemoryKeyValueCache"/> implementation of <see cref="T:MindTouch.Cache.IKeyValueCache"/>.
            </summary>
        </member>
        <member name="T:MindTouch.Cache.KeyValueCacheFactory">
            <summary>
            Provides a common <see cref="T:MindTouch.Cache.IKeyValueCacheFactory"/> that can be used for subclassing or directly by instantiating it with an
            appropriate instance creation function.
            </summary>
            <remarks>
            <see cref="T:MindTouch.Cache.IKeyValueCache"/> are created via a creation function that is provided the factory's <see cref="T:MindTouch.Tasking.TaskTimerFactory"/> and
            an <see cref="T:MindTouch.IO.ISerializer"/> instance that encapsulates all registered serializer via the <see cref="T:MindTouch.IO.SerializerProxy"/> aggregator,
            allowing the <see cref="T:MindTouch.Cache.IKeyValueCache"/> implementation to function against a single serializer without having to determine the right
            serializer for a given type.
            </remarks>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheFactory.#ctor(MindTouch.Tasking.TaskTimerFactory,System.Func{MindTouch.IO.ISerializer,MindTouch.Tasking.TaskTimerFactory,MindTouch.Cache.IKeyValueCache})">
            <summary>
            Create a new factory instance.
            </summary>
            <param name="timer">The timer factory to be provided to cache instances.</param>
            <param name="factoryMethod">A function for creating a new cache instance from an <see cref="T:MindTouch.IO.ISerializer"/> instance and timer factory.</param>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheFactory.SetSerializer``1(MindTouch.IO.ISerializer)">
            <summary>
            Register a serializer for a specific type.
            </summary>
            <typeparam name="T">Type the serializer is responsible for.</typeparam>
            <param name="serializer">A serializer instance.</param>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheFactory.SetSerializer(MindTouch.IO.ISerializer,System.Type)">
            <summary>
            Register a serializer for a specific type.
            </summary>
            <param name="serializer">A serializer instance.</param>
            <param name="type">Type the serializer is responsible for.</param>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheFactory.RemoveSerializer``1">
            <summary>
            Remove a serializer for a specific type.
            </summary>
            <typeparam name="T">Type the serializer is responsible for.</typeparam>
            <returns><see langword="True"/> if a serializer for the specified type was registered.</returns>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheFactory.RemoveSerializer(System.Type)">
            <summary>
            Remove a serializer for a specific type.
            </summary>
            <param name="type">Type the serializer is responsible for.</param>
            <returns><see langword="True"/> if a serializer for the specified type was registered.</returns>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheFactory.Create">
            <summary>
            Create a new <see cref="T:MindTouch.Cache.IKeyValueCache"/> instance.
            </summary>
            <returns>A new cache instance.</returns>
        </member>
        <member name="P:MindTouch.Cache.KeyValueCacheFactory.Serializers">
            <summary>
            All serializers registered with this factory.
            </summary>
        </member>
        <member name="P:MindTouch.Cache.KeyValueCacheFactory.DefaultSerializer">
            <summary>
            Default serializer to fire for all types lacking an explicit serializer.
            </summary>
            <remarks>
            At creation time, this is set to an instance of <see cref="T:MindTouch.IO.BinaryFormatterSerializer"/>, providing the ability to
            serialize any <see cref="T:System.SerializableAttribute"/> marked instances.
            </remarks>
        </member>
        <member name="F:MindTouch.Cache.InMemoryKeyValueCacheFactory.DEFAULT_MAX_SIZE">
            <summary>
            Default maximum memory size (in bytes) for the cache: 10MB.
            </summary>
        </member>
        <member name="M:MindTouch.Cache.InMemoryKeyValueCacheFactory.#ctor(MindTouch.Tasking.TaskTimerFactory)">
            <summary>
            Create a new factory instance.
            </summary>
            <param name="timer">Timer factory to provide to the cache instance.</param>
        </member>
        <member name="M:MindTouch.Cache.InMemoryKeyValueCacheFactory.#ctor(System.Int32,MindTouch.Tasking.TaskTimerFactory)">
            <summary>
            Create a new factory instance.
            </summary>
            <param name="maxSize">Maximum number of bytes of memory the cache should use for stored items</param>
            <param name="timer">Timer factory to provide to the cache instance.</param>
        </member>
        <member name="T:MindTouch.Cache.InMemoryKeyValueCache">
            <summary>
            Main-memory implementation of <see cref="T:MindTouch.Cache.IKeyValueCache"/>.
            </summary>
            <remarks>
            Even though the values cached remain in process, they are stored as serialized data not as references. Instances can be created via
            <see cref="M:MindTouch.Cache.KeyValueCacheFactory.Create"/>.
            </remarks>
        </member>
        <member name="M:MindTouch.Cache.InMemoryKeyValueCache.Flush">
            <summary>
            Manually force excess memory collection
            </summary>
        </member>
        <member name="M:MindTouch.Cache.InMemoryKeyValueCache.Delete(System.String)">
            <summary>
            Delete a value from the cache.
            </summary>
            <param name="key">Key to identify the value by.</param>
            <returns><see langword="True"/> if the value was deleted.</returns>
        </member>
        <member name="M:MindTouch.Cache.InMemoryKeyValueCache.TryGet``1(System.String,``0@)">
            <summary>
            Try to retrieve a value from the cache.
            </summary>
            <typeparam name="T">Type the value to be returned.</typeparam>
            <param name="key">Key to identify the value by.</param>
            <param name="value">Output slot for value, if it was retrieved. Must be deserializable by the cache.</param>
            <returns><see langword="True"/> if the value was returned.</returns>
        </member>
        <member name="M:MindTouch.Cache.InMemoryKeyValueCache.Set``1(System.String,``0,System.TimeSpan)">
            <summary>
            Add a value to the cache.
            </summary>
            <typeparam name="T">Type the value to be stored.</typeparam>
            <param name="key">Key to identify the value by.</param>
            <param name="value">Value to be stored. Must be serializable by the cache.</param>
            <param name="ttl">Maximum time for the value to live in the cache.</param>
        </member>
        <member name="M:MindTouch.Cache.InMemoryKeyValueCache.Clear">
            <summary>
            Clear the entire cache immediately.
            </summary>
        </member>
        <member name="M:MindTouch.Cache.InMemoryKeyValueCache.Dispose">
            <summary>
            Dispose all values currently in the cache.
            </summary>
        </member>
        <member name="P:MindTouch.Cache.InMemoryKeyValueCache.MemoryCapacity">
            <summary>
            Maximum number of bytes used for cache values
            </summary>
        </member>
        <member name="P:MindTouch.Cache.InMemoryKeyValueCache.MemorySize">
            <summary>
            Number of bytes currently used by cache values
            </summary>
        </member>
        <member name="T:MindTouch.Cache.KeyValueCacheEx">
            <summary>
            Provides extension methods to attach additional getters and setter to any implemenation of <see cref="T:MindTouch.Cache.IKeyValueCache"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheEx.Get``1(MindTouch.Cache.IKeyValueCache,System.String)">
            <summary>
            Retrieve a value from the cache.
            </summary>
            <typeparam name="T">Type the value to be returned.</typeparam>
            <param name="cache">The cache instance to operate on.</param>
            <param name="key">Key to identify the value by.</param>
            <returns>The cached value or <see langword="null"/> if the value is not in cache.</returns>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheEx.Get``1(MindTouch.Cache.IKeyValueCache,System.String,``0)">
            <summary>
            Retrieve a value from the cache.
            </summary>
            <typeparam name="T">Type the value to be returned.</typeparam>
            <param name="cache">The cache instance to operate on.</param>
            <param name="key">Key to identify the value by.</param>
            <param name="def"></param>
            <returns>The cached value or the method's default value if the value is not in cache.</returns>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheEx.Set``1(MindTouch.Cache.IKeyValueCache,System.String,``0)">
            <summary>
            Store a value in the cache.
            </summary>
            <remarks>
            This method will set the value and leave expiration up to the cache implementation.
            </remarks>
            <typeparam name="T">Type the value to be stored.</typeparam>
            <param name="cache">The cache instance to operate on.</param>
            <param name="key">Key to identify the value by.</param>
            <param name="val">Value to be stored.</param>
        </member>
        <member name="M:MindTouch.Cache.KeyValueCacheEx.Set``1(MindTouch.Cache.IKeyValueCache,System.String,``0,System.DateTime)">
            <summary>
            Store a value in the cache.
            </summary>
            <typeparam name="T">Type the value to be stored.</typeparam>
            <param name="cache">The cache instance to operate on.</param>
            <param name="key">Key to identify the value by.</param>
            <param name="val">Value to be stored.</param>
            <param name="expires">Absolute time at which the value should no longer be accessible from the cache.</param>
        </member>
        <member name="T:MindTouch.IO.SerializerProxy">
            <summary>
            Provides an aggregator of serializer instances and type mappings to allow a collection of separate <see cref="T:MindTouch.IO.ISerializer"/>
            instances to function as a single serializer.
            </summary>
        </member>
        <member name="M:MindTouch.IO.SerializerProxy.#ctor(MindTouch.IO.ISerializer,System.Collections.Generic.Dictionary{System.Type,MindTouch.IO.ISerializer})">
            <summary>
            Create a new proxy serializer.
            </summary>
            <param name="defaultSerializer">Serializer to use for all types without an explicit type mapping.</param>
            <param name="serializers">Map of types and responsible serializers.</param>
        </member>
        <member name="T:MindTouch.Collections.QueueClosedException">
            <summary>
            Exception thrown by <see cref="M:MindTouch.Collections.BlockingQueue`1.Enqueue(`0)"/> and <see cref="M:MindTouch.Collections.BlockingQueue`1.Dequeue"/> when the underlying queue has already been closed.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.QueueClosedException.#ctor">
            <summary>
            Create a new exception instance.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.IBlockingQueue`1">
            <summary>
            Provides a thread-safe queue that blocks on queue and dequeue operations under lock contention or when no items are available.
            </summary>
            <typeparam name="T">Type of the data items in the queue</typeparam>
        </member>
        <member name="M:MindTouch.Collections.IBlockingQueue`1.TryDequeue(System.TimeSpan,`0@)">
            <summary>
            Attempt to dequeue an item from the queue.
            </summary>
            <remarks>Dequeue timeout can occur either because a lock could not be acquired or because no item was available.</remarks>
            <param name="timeout">Time to wait for an item to become available.</param>
            <param name="item">The location for a dequeue item.</param>
            <returns><see langword="True"/> if an item was dequeued, <see langword="False"/> if the operation timed out instead.</returns>
        </member>
        <member name="M:MindTouch.Collections.IBlockingQueue`1.Dequeue">
            <summary>
            Blocking dequeue operation. Will not return until an item is available.
            </summary>
            <returns>A data item.</returns>
            <exception cref="T:MindTouch.Collections.QueueClosedException">Thrown when the queue is closed and has no more items.</exception>
        </member>
        <member name="M:MindTouch.Collections.IBlockingQueue`1.Enqueue(`0)">
            <summary>
            Enqueue a new item into the queue.
            </summary>
            <param name="data">A data item.</param>
            <exception cref="T:MindTouch.Collections.QueueClosedException">Thrown when the queue is closed and does not accept new items.</exception>
        </member>
        <member name="M:MindTouch.Collections.IBlockingQueue`1.Close">
            <summary>
            Close the queue and stop it from accepting more items.
            </summary>
            <remarks>Pending items can still be dequeued.</remarks>
        </member>
        <member name="P:MindTouch.Collections.IBlockingQueue`1.IsClosed">
            <summary>
            <see langword="True"/> when the queue has been closed and can no longer accept new items, <see langword="False"/> otherwise.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.IBlockingQueue`1.Count">
            <summary>
            Total number of items currently in the queue.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.BlockingQueue`1">
            <summary>
            Provides a thread-safe queue that blocks on queue and dequeue operations under lock contention or when no items are available.
            </summary>
            <typeparam name="T">Type of the data items in the queue</typeparam>
        </member>
        <member name="M:MindTouch.Collections.BlockingQueue`1.Dequeue">
            <summary>
            Blocking dequeue operation. Will not return until an item is available.
            </summary>
            <returns>A data item.</returns>
            <exception cref="T:MindTouch.Collections.QueueClosedException">Thrown when the queue is closed and has no more items.</exception>
        </member>
        <member name="M:MindTouch.Collections.BlockingQueue`1.TryDequeue(System.TimeSpan,`0@)">
            <summary>
            Attempt to dequeue an item from the queue.
            </summary>
            <remarks>Dequeue timeout can occur either because a lock could not be acquired or because no item was available.</remarks>
            <param name="timeout">Time to wait for an item to become available.</param>
            <param name="item">The location for a dequeue item.</param>
            <returns><see langword="True"/> if an item was dequeued, <see langword="False"/> if the operation timed out instead.</returns>
        </member>
        <member name="M:MindTouch.Collections.BlockingQueue`1.Enqueue(`0)">
            <summary>
            Enqueue a new item into the queue.
            </summary>
            <param name="data">A data item.</param>
            <exception cref="T:MindTouch.Collections.QueueClosedException">Thrown when the queue is closed and does not accept new items.</exception>
        </member>
        <member name="M:MindTouch.Collections.BlockingQueue`1.Close">
            <summary>
            Close the queue and stop it from accepting more items.
            </summary>
            <remarks>Pending items can still be dequeued.</remarks>
        </member>
        <member name="P:MindTouch.Collections.BlockingQueue`1.IsClosed">
            <summary>
            <see langword="True"/> when the queue has been closed and can no longer accept new items, <see langword="False"/> otherwise.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.BlockingQueue`1.Count">
            <summary>
            Total number of items currently in the queue.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.ChunkedArray`1">
            <summary>
            Create an array with chunked internal storage to avoid large object allocations.
            </summary>
            <typeparam name="T">Type of data to store in array.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.ChunkedArray`1.#ctor(System.Int32)">
            <summary>
            Create a new instance.
            </summary>
            <param name="length">Length of the array.</param>
        </member>
        <member name="P:MindTouch.Collections.ChunkedArray`1.Length">
            <summary>
            Length of the array.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ChunkedArray`1.ChunkCount">
            <summary>
            Number of chunks used by the array.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ChunkedArray`1.Item(System.Int32)">
            <summary>
            Accessor for item in array.
            </summary>
            <param name="index">0 based index into array.</param>
            <returns>Value of item at index.</returns>
        </member>
        <member name="T:MindTouch.Collections.ExpiringDictionary`2">
            <summary>
            Represents a dictionary of key/value pairs with an expiration time.
            </summary>
            <remarks>
            Values inserted into this this set will expire after some set time (which may be updated and reset), automatically removing the value
            from the set and firing a notification event <see cref="E:MindTouch.Collections.ExpiringDictionary`2.EntryExpired"/>. The dictionary may optionally be configured to extend a pair's
            expiration on access, including accessing the entry via the instances iterator.
            </remarks>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue">The type of elements in the list.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.#ctor(MindTouch.Tasking.TaskTimerFactory)">
            <summary>
            Create a new hashset
            </summary>
            <param name="taskTimerFactory">The timer factory to create the set's timer from</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.#ctor(MindTouch.Tasking.TaskTimerFactory,System.Boolean)">
            <summary>
            Create a new hashset
            </summary>
            <param name="taskTimerFactory">The timer factory to create the set's timer from</param>
            <param name="autoRefresh"><see langword="True"/> if accessing an entry should extend the expiration time by the time-to-live</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.Clear">
            <summary>
            Clear the entire set immediately
            </summary>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.Update(`0,`1)">
            <summary>
            Update the value of an entry.
            </summary>
            <param name="key">The identifying key.</param>
            <param name="value">The keyed value.</param>
            <returns><see langword="True"/> if an entry existed for the given key.</returns>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.Set(`0,`1,System.TimeSpan)">
            <summary>
            Add or update a key/value pair.
            </summary>
            <param name="key">The identifying key.</param>
            <param name="value">The keyed value.</param>
            <param name="ttl">The time-to-live from right now</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.TrySet(`0,`1,System.TimeSpan,`1@)">
            <summary>
            Add or update a key/value pair.
            </summary>
            <param name="key">The identifying key.</param>
            <param name="value">The keyed value.</param>
            <param name="ttl">The time-to-live from right now</param>
            <param name="oldValue">Previous value stored at the key location</param>
            <returns><see langword="True"/> if an entry existed for the given key.</returns>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.Set(`0,`1,System.DateTime)">
            <summary>
            Add or update a key/value pair.
            </summary>
            <param name="key">The identifying key.</param>
            <param name="value">The keyed value.</param>
            <param name="when">The absolute expiration time of the pair.</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.TrySet(`0,`1,System.DateTime,`1@)">
            <summary>
            Add or update a key/value pair.
            </summary>
            <param name="key">The identifying key.</param>
            <param name="value">The keyed value.</param>
            <param name="oldValue">Previous value stored at the key location</param>
            <param name="when">The absolute expiration time of the pair.</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.SetExpiration(`0,System.TimeSpan)">
            <summary>
            Set the expiration for a key/value pair.
            </summary>
            <param name="key">The identifying key.</param>
            <param name="ttl">Time-to-live for the entry.</param>
            <returns><see langword="True"/> if an entry existed for the given key.</returns>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.SetExpiration(`0,System.DateTime)">
            <summary>
            Set the expiration for a key/value pair.
            </summary>
            <param name="key">The identifying key.</param>
            <param name="when">The absolute expiration time of the pair.</param>
            <returns><see langword="True"/> if an entry existed for the given key.</returns>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.Delete(`0)">
            <summary>
            Remove a value from the set.
            </summary>
            <param name="key">The identifying key.</param>
            <returns><see langword="True"/> if an entry existed for the given key.</returns>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.TryDelete(`0,`1@)">
            <summary>
            Try to delete a key and receive back its old value on success.
            </summary>
            <param name="key">The key to delete.</param>
            <param name="value">Output slot of the original value on successful deletion.</param>
            <returns><see langword="True"/> if an entry existed for the given key.</returns>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.RefreshExpiration(`0)">
            <summary>
            Extend an entry's expiration by its time-to-live.
            </summary>
            <param name="key">The identifying key.</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringDictionary`2.Dispose">
            <summary>
            Dispose the set, releasing all entries.
            </summary>
        </member>
        <member name="E:MindTouch.Collections.ExpiringDictionary`2.EntryExpired">
            <summary>
            Fired for every entry that expires.
            </summary>
        </member>
        <member name="E:MindTouch.Collections.ExpiringDictionary`2.CollectionChanged">
            <summary>
            Fired any time a value is added, removed or experiation is changed.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ExpiringDictionary`2.Item(`0)">
            <summary>
            Get the <see cref="T:MindTouch.Collections.ExpiringDictionary`2.Entry"/> meta-data container for the given value.
            </summary>
            <remarks>
            This access will refresh the entry's expiration, if the set was created with the 'autoRefresh' flag.
            </remarks>
            <param name="key">The identifying key.</param>
            <returns>Meta-data for specified value. Returns <see langword="null"/> if the value is not stored in the set.</returns>
        </member>
        <member name="T:MindTouch.Collections.ExpiringDictionary`2.Entry">
            <summary>
            A wrapper class containing meta data about values stored in the <see cref="T:MindTouch.Collections.ExpiringDictionary`2"/>.
            </summary>
            <remarks>
            The meta-data is created on demand, i.e. it will not reflect changes in <see cref="F:MindTouch.Collections.ExpiringDictionary`2.Entry.When"/> or <see cref="F:MindTouch.Collections.ExpiringDictionary`2.Entry.TTL"/> that happen
            after it is retrieved from the set.
            </remarks>
        </member>
        <member name="F:MindTouch.Collections.ExpiringDictionary`2.Entry.When">
            <summary>
            The absolute time at which the entry will expire.
            </summary>
        </member>
        <member name="F:MindTouch.Collections.ExpiringDictionary`2.Entry.TTL">
            <summary>
            The time-to-live of the entry at insertion time.
            </summary>
        </member>
        <member name="F:MindTouch.Collections.ExpiringDictionary`2.Entry.Key">
            <summary>
            The key stored in the dictionary.
            </summary>
        </member>
        <member name="F:MindTouch.Collections.ExpiringDictionary`2.Entry.Value">
            <summary>
            The value stored in the dictionary.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.ExpirationArgs`2">
            <summary>
            Event argument for <see cref="E:MindTouch.Collections.ExpiringDictionary`2.EntryExpired"/> event.
            </summary>
            <typeparam name="TKey">Type of the key stored in the <see cref="T:MindTouch.Collections.ExpiringDictionary`2"/> that fired the event.</typeparam>
            <typeparam name="TValue">Type of the value stored in the <see cref="T:MindTouch.Collections.ExpiringDictionary`2"/> that fired the event.</typeparam>
        </member>
        <member name="F:MindTouch.Collections.ExpirationArgs`2.Entry">
            <summary>
            Entry that expired.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.ExpiringHashSet`1">
            <summary>
            Represents a set of values with an expiration time.
            </summary>
            <remarks>
            Values inserted into this this set will expire after some set time (which may be updated and reset), automatically removing the value
            from the set and firing a notification event <see cref="E:MindTouch.Collections.ExpiringHashSet`1.EntryExpired"/>. The set may optionally be configured to extend a value's
            expiration on access, including accessing the entry via the instances iterator.
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.#ctor(MindTouch.Tasking.TaskTimerFactory)">
            <summary>
            Create a new hashset
            </summary>
            <param name="taskTimerFactory">The timer factory to create the set's timer from</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.#ctor(MindTouch.Tasking.TaskTimerFactory,System.Boolean)">
            <summary>
            Create a new hashset
            </summary>
            <param name="taskTimerFactory">The timer factory to create the set's timer from</param>
            <param name="autoRefresh"><see langword="True"/> if accessing an entry should extend the expiration time by the time-to-live</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.SetExpiration(`0,System.TimeSpan)">
            <summary>
            Add or update the expiration for an item
            </summary>
            <param name="value">The value in the set</param>
            <param name="ttl">The time-to-live from right now</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.SetExpiration(`0,System.DateTime)">
            <summary>
            Add or update the expiration for an item
            </summary>
            <param name="value">The value in the set</param>
            <param name="when">The absolute expiration time of the item</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.SetExpiration(`0,System.DateTime,System.TimeSpan)">
            <summary>
            Add or update the expiration for an item
            </summary>
            <remarks>
            Thie overload takes both the when and ttl. The <paramref name="when"/> is authoritative for expiration,
            but <paramref name="ttl"/> is used for <see cref="M:MindTouch.Collections.ExpiringHashSet`1.RefreshExpiration(`0)"/>
            </remarks>
            <param name="value"></param>
            <param name="when"></param>
            <param name="ttl"></param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.RemoveExpiration(`0)">
            <summary>
            Obsolete: The method <see cref="M:MindTouch.Collections.ExpiringHashSet`1.RemoveExpiration(`0)"/> has been deprecated. Use <see cref="M:MindTouch.Collections.ExpiringHashSet`1.Delete(`0)"/> instead.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.Delete(`0)">
            <summary>
            Remove a value from the set.
            </summary>
            <param name="value">Value to remove</param>
            <returns><see langword="True"/> if an entry existed for the given key.</returns>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.RefreshExpiration(`0)">
            <summary>
            Extend an entry's expiration by its time-to-live.
            </summary>
            <param name="value">The value in the set</param>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.Clear">
            <summary>
            Clear the entire set immediately
            </summary>
        </member>
        <member name="M:MindTouch.Collections.ExpiringHashSet`1.Dispose">
            <summary>
            Dispose the set, releasing all entries.
            </summary>
        </member>
        <member name="E:MindTouch.Collections.ExpiringHashSet`1.EntryExpired">
            <summary>
            Fired for every entry that expires.
            </summary>
        </member>
        <member name="E:MindTouch.Collections.ExpiringHashSet`1.CollectionChanged">
            <summary>
            Fired any time a value is added, removed or experiation is changed.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ExpiringHashSet`1.Item(`0)">
            <summary>
            Get the <see cref="T:MindTouch.Collections.ExpiringHashSet`1.Entry"/> meta-data container for the given value.
            </summary>
            <remarks>
            This access will refresh the entry's expiration, if the set was created with the 'autoRefresh' flag.
            </remarks>
            <param name="value">Set value.</param>
            <returns>Meta-data for specified value. Returns <see langword="null"/> if the value is not stored in the set.</returns>
        </member>
        <member name="T:MindTouch.Collections.ExpiringHashSet`1.Entry">
            <summary>
            A wrapper class containing meta data about values stored in the <see cref="T:MindTouch.Collections.ExpiringHashSet`1"/>.
            </summary>
            <remarks>
            The meta-data is created on demand, i.e. it will not reflect changes in <see cref="F:MindTouch.Collections.ExpiringHashSet`1.Entry.When"/> or <see cref="F:MindTouch.Collections.ExpiringHashSet`1.Entry.TTL"/> that happen
            after it is retrieved from the set.
            </remarks>
        </member>
        <member name="F:MindTouch.Collections.ExpiringHashSet`1.Entry.When">
            <summary>
            The absolute time at which the entry will expire
            </summary>
        </member>
        <member name="F:MindTouch.Collections.ExpiringHashSet`1.Entry.TTL">
            <summary>
            The time-to-live of the entry at insertion time
            </summary>
        </member>
        <member name="F:MindTouch.Collections.ExpiringHashSet`1.Entry.Value">
            <summary>
            The value stored in the set
            </summary>
        </member>
        <member name="T:MindTouch.Collections.ExpirationEventArgs`1">
            <summary>
            Event argument for <see cref="E:MindTouch.Collections.ExpiringHashSet`1.EntryExpired"/> event.
            </summary>
            <typeparam name="T">Type of the value stored in the <see cref="T:MindTouch.Collections.ExpiringHashSet`1"/> that fired the event.</typeparam>
        </member>
        <member name="F:MindTouch.Collections.ExpirationEventArgs`1.Entry">
            <summary>
            Entry that expired.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.ITransactionalQueue`1">
            <summary>
            A specialized queue that uses a two-phase dequeue to retrieve items
            </summary>
            <remarks>
            Items dequeued are invisible to other users of the queue, but are not permanently removed until the dequeue is either committed,
            or rolled back, the latter action making the item availabe for dequeuing again
            </remarks>
            <seealso cref="T:MindTouch.Collections.TransactionalQueue`1"/>
            <typeparam name="T">Type of entries in the queue</typeparam>
        </member>
        <member name="M:MindTouch.Collections.ITransactionalQueue`1.Clear">
            <summary>
            Clear out the queue and drop all items.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.ITransactionalQueue`1.Enqueue(`0)">
            <summary>
            Put an item into the queue
            </summary>
            <param name="item">An instance of type T</param>
        </member>
        <member name="M:MindTouch.Collections.ITransactionalQueue`1.Dequeue">
            <summary>
            Get the next available item from the queue. Must call <see cref="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)"/> to fully take possession or the item. Uses <see cref="P:MindTouch.Collections.ITransactionalQueue`1.DefaultCommitTimeout"/>.
            </summary>
            <remarks>
            Phase 1 of the two-phase dequeue. <see cref="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)"/> within <see cref="P:MindTouch.Collections.ITransactionalQueue`1.DefaultCommitTimeout"/> completes the dequeue, while waiting for the timeout to
            expire or calling <see cref="M:MindTouch.Collections.ITransactionalQueue`1.RollbackDequeue(System.Int64)"/> aborts the dequeue.
            </remarks>
            <returns>
            An instance of <see cref="T:MindTouch.Collections.ITransactionalQueueEntry`1"/> wrapping the dequeued value and item id for use 
            with <see cref="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)"/> or <see cref="M:MindTouch.Collections.ITransactionalQueue`1.RollbackDequeue(System.Int64)"/>. <see langword="null"/> if the queue is empty.
            </returns>
        </member>
        <member name="M:MindTouch.Collections.ITransactionalQueue`1.Dequeue(System.TimeSpan)">
            <summary>
            Get the next available item from the queue. Must call <see cref="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)"/> to fully take possession or the item.
            </summary>
            <remarks>
            Phase 1 of the two-phase dequeue. <see cref="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)"/> within <b>commitTimeout</b> completes the dequeue, while waiting for the timeout to
            expire or calling <see cref="M:MindTouch.Collections.ITransactionalQueue`1.RollbackDequeue(System.Int64)"/> aborts the dequeue.
            </remarks>
            <param name="commitTimeout">Time before an uncommitted dequeue is considered abandoned and automatically rolled back</param>
            <returns>
            An instance of <see cref="T:MindTouch.Collections.ITransactionalQueueEntry`1"/> wrapping the dequeued value and item id for use 
            with <see cref="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)"/> or <see cref="M:MindTouch.Collections.ITransactionalQueue`1.RollbackDequeue(System.Int64)"/>. <see langword="null"/> if the queue is empty.
            </returns>
        </member>
        <member name="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)">
            <summary>
            Completes the two-phase <see cref="M:MindTouch.Collections.ITransactionalQueue`1.Dequeue"/>.
            </summary>
            <param name="id"><see cref="P:MindTouch.Collections.ITransactionalQueueEntry`1.Id"/> identifier of the dequeued item</param>
            <returns><see langword="true"/> if the commit succeeded, <see langword="false"/> if the item was already dequeued or has been rolled back</returns>
        </member>
        <member name="M:MindTouch.Collections.ITransactionalQueue`1.RollbackDequeue(System.Int64)">
            <summary>
            Undo <see cref="M:MindTouch.Collections.ITransactionalQueue`1.Dequeue"/> and return item back to the queue.
            </summary>
            <param name="id"><see cref="P:MindTouch.Collections.ITransactionalQueueEntry`1.Id"/> identifier of the dequeued item</param>
        </member>
        <member name="P:MindTouch.Collections.ITransactionalQueue`1.DefaultCommitTimeout">
            <summary>
            The default timeout used for a dequeued item before the item is considered abandoned and automatically rolled back
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ITransactionalQueue`1.Count">
            <summary>
            The current count of items available for <see cref="M:MindTouch.Collections.ITransactionalQueue`1.Dequeue"/>
            </summary>
            <remarks>
            Count only reflects items available for dequeue, not items pending commit or rollback
            </remarks>
        </member>
        <member name="T:MindTouch.Collections.ITransactionalQueueEntry`1">
            <summary>
            A entry returned from <see cref="M:MindTouch.Collections.ITransactionalQueue`1.Dequeue"/> containing both the dequeued value and an entry Id to be
            used with <see cref="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)"/> or <see cref="M:MindTouch.Collections.ITransactionalQueue`1.RollbackDequeue(System.Int64)"/>.
            </summary>
            <typeparam name="T">Type of entries in the originating <see cref="T:MindTouch.Collections.ITransactionalQueue`1"/></typeparam>
        </member>
        <member name="P:MindTouch.Collections.ITransactionalQueueEntry`1.Value">
            <summary>
            The dequeued value
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ITransactionalQueueEntry`1.Id">
            <summary>
            The entry Id for use with <see cref="M:MindTouch.Collections.ITransactionalQueue`1.CommitDequeue(System.Int64)"/> or <see cref="M:MindTouch.Collections.ITransactionalQueue`1.RollbackDequeue(System.Int64)"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ITransactionalQueueEntry`1.Expiration">
            <summary>
            The time at which this entry will be considered abandoned and automatically rolled back.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.Dispatcher">
            <summary>
            Default implementation of <see cref="T:MindTouch.Dream.Services.PubSub.IPubSubDispatcher"/> with extension points for sub-classing.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.IPubSubDispatcher">
            <summary>
            Contract for implementing an event dispatcher for the pub sub service.
            </summary>
            <remarks>
            The default implementation is <see cref="T:MindTouch.Dream.Services.PubSub.Dispatcher"/>.
            </remarks>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatcher.GetAllSubscriptionSets">
            <summary>
            Retrieve all uncombined subscription sets.
            </summary>
            <returns>Enumerable of <see cref="T:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet"/>.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatcher.RegisterSet(System.String,MindTouch.Xml.XDoc,System.String)">
            <summary>
            Register a subscription set
            </summary>
            <param name="location"></param>
            <param name="setDoc">Xml formatted subscription set.</param>
            <param name="accessKey"></param>
            <returns>Tuple of subscription set and <see langword="True"/> if the set was newly created, or <see langword="False"/> if the set existed (does not update the set).</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatcher.Dispatch(MindTouch.Dream.Services.PubSub.DispatcherEvent)">
            <summary>
            Dispatch an event against the registered subscriptions.
            </summary>
            <param name="ev">Dispatch event instance.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatcher.ReplaceSet(System.String,MindTouch.Xml.XDoc,System.String)">
            <summary>
            Replace an existing set.
            </summary>
            <param name="location">Set resource location uri postfix.</param>
            <param name="setDoc">New set document.</param>
            <param name="accessKey">Updates set access key, if provided.</param>
            <returns>Updated set.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.IPubSubDispatcher.RemoveSet(System.String)">
            <summary>
            Remove a set.
            </summary>
            <param name="location">Set resource location uri postfix.</param>
            <returns><see langword="True"/> if a set existed at the provided location.</returns>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.IPubSubDispatcher.CombinedSet">
            <summary>
            The combined set of pub sub subscriptions.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.IPubSubDispatcher.Item(System.String)">
            <summary>
            Retrieve a subscription set by location key.
            </summary>
            <param name="location">Location postfix of subscription set resource uri on the pub sub service.</param>
            <returns></returns>
        </member>
        <member name="E:MindTouch.Dream.Services.PubSub.IPubSubDispatcher.CombinedSetUpdated">
            <summary>
            Event fired anytime the combined subscription set has changed.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.Dispatcher._cookieJar">
            <summary>
            Cookie Jar provide by the hosting pub sub service
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.Dispatcher._subscriptionsByRecipient">
            <summary>
            Collection of dispatch destinations by recipients.
            </summary>
            <remarks>
            Should not be modified by subclass.
            </remarks>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.Dispatcher._channelMap">
            <summary>
            Uri lookup table for subscriptions by channel uri.
            </summary>
            <remarks>
            Should not be modified by subclass. When <see cref="F:MindTouch.Dream.Services.PubSub.Dispatcher._channelMap"/> or <see cref="F:MindTouch.Dream.Services.PubSub.Dispatcher._resourceMap"/> is accessed a lock should always be
            taken on <see cref="F:MindTouch.Dream.Services.PubSub.Dispatcher._channelMap"/>.
            </remarks>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.Dispatcher._resourceMap">
            <summary>
            Uri lookup table for subscriptions by resource uri.
            </summary>
            <remarks>
            Should not be modified by subclass. When <see cref="F:MindTouch.Dream.Services.PubSub.Dispatcher._channelMap"/> or <see cref="F:MindTouch.Dream.Services.PubSub.Dispatcher._resourceMap"/> is accessed a lock should always be
            taken on <see cref="F:MindTouch.Dream.Services.PubSub.Dispatcher._channelMap"/>.
            </remarks>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.#ctor(MindTouch.Dream.Services.PubSub.DispatcherConfig,MindTouch.Dream.Services.PubSub.IPubSubDispatchQueueRepository)">
            <summary>
            Create a new dispatcher.
            </summary>
            <param name="config">Configuration instance injected from pub sub service.</param>
            <param name="queueRepository">Factory for dispatch queues used by persisted (i.e. expiring) subscriptions</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.GetAllSubscriptionSets">
            <summary>
            Retrieve all uncombined subscription sets.
            </summary>
            <returns>Enumerable of <see cref="T:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet"/>.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.RegisterSet(System.String,MindTouch.Xml.XDoc,System.String)">
            <summary>
            Register a subscription set
            </summary>
            <param name="location">location id.</param>
            <param name="setDoc">Xml formatted subscription set.</param>
            <param name="accessKey">secret key for accessing the set.</param>
            <returns>Tuple of subscription set and <see langword="True"/> if the set was newly created, or <see langword="False"/> if the set existed (does not update the set).</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.Dispatch(MindTouch.Dream.Services.PubSub.DispatcherEvent)">
            <summary>
            Dispatch an event against the registered subscriptions.
            </summary>
            <param name="ev">Dispatch event instance.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.GetListenersByChannelResourceMatch(MindTouch.Dream.Services.PubSub.DispatcherEvent,MindTouch.Tasking.Result{System.Collections.Generic.Dictionary{MindTouch.Dream.XUri,System.Collections.Generic.List{MindTouch.Dream.Services.PubSub.PubSubSubscription}}})">
            <summary>
            Override hook for modifying the selection of event listeners based on channel and resource matches.
            </summary>
            <param name="ev">Event to be dispatched.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.GetListenersForRecipients(MindTouch.Dream.Services.PubSub.DispatcherEvent,MindTouch.Tasking.Result{System.Collections.Generic.Dictionary{MindTouch.Dream.XUri,System.Collections.Generic.List{MindTouch.Dream.Services.PubSub.PubSubSubscription}}})">
            <summary>
            Override hook for modifying the selection of event listeners based on recipients subscribed to the event.
            </summary>
            <param name="ev">Event to be dispatched.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.FilterRecipients(MindTouch.Dream.Services.PubSub.DispatcherEvent,MindTouch.Dream.Services.PubSub.PubSubSubscription,MindTouch.Tasking.Result{MindTouch.Dream.Services.PubSub.DispatcherEvent})">
            <summary>
            Override hook for filtering recipients for an event.
            </summary>
            <param name="ev">Event to be dispatched.</param>
            <param name="subscription">Matching subscription.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.ReplaceSet(System.String,MindTouch.Xml.XDoc,System.String)">
            <summary>
            Replace an existing set.
            </summary>
            <param name="location">Set resource location uri postfix.</param>
            <param name="setDoc">New set document.</param>
            <param name="accessKey"></param>
            <returns>Updated set.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.RemoveSet(System.String)">
            <summary>
            Remove a set.
            </summary>
            <param name="location">Set resource location uri postfix.</param>
            <returns><see langword="True"/> if a set existed at the provided location.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.Dispatcher.CalculateCombinedSubscriptions">
            <summary>
            Override hook for modifying/augmenting the calculation of the combined subscription set.
            </summary>
            <returns>Returns all subscription sets used to calculate the new combined set.</returns>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.Dispatcher.CombinedSet">
            <summary>
            The combined set of pub sub subscriptions.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.Dispatcher.Item(System.String)">
            <summary>
            Retrieve a subscription set by location key.
            </summary>
            <param name="location">Location postfix of subscription set resource uri on the pub sub service.</param>
            <returns></returns>
        </member>
        <member name="E:MindTouch.Dream.Services.PubSub.Dispatcher.CombinedSetUpdated">
            <summary>
            Event fired anytime the combined subscription set has changed.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.DispatcherConfig">
            <summary>
            Configuration class that may be injected into <see cref="T:MindTouch.Dream.Services.PubSub.IPubSubDispatcher"/> instances if a matching constructor is found.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherConfig.ServiceUri">
            <summary>
            Uri of the hosting service.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherConfig.ServiceAccessCookie">
            <summary>
            Accesss cookie of the hosting service.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherConfig.ServiceCookies">
            <summary>
            Cookies the service has provided by other services.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherConfig.ServiceConfig">
            <summary>
            Service configuration.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.DispatcherEvent">
            <summary>
            Event processed and sent by the <see cref="T:MindTouch.Dream.Services.PubSub.IPubSubDispatcher"/>.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherEvent.Id">
            <summary>
            Event Id.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherEvent.Channel">
            <summary>
            Event Channel.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherEvent.Resource">
            <summary>
            Optional Event Resource.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherEvent.Origins">
            <summary>
            List of origins of the event.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherEvent.Recipients">
            <summary>
            List of recipients of the event derived from matched subscriptions.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherEvent.Via">
            <summary>
            List of Pub Sub services this event has passed through.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.#ctor(MindTouch.Dream.DreamMessage)">
            <summary>
            Create a new event from a dream message.
            </summary>
            <param name="message">Message to parse.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.#ctor(MindTouch.Xml.XDoc,MindTouch.Dream.XUri,MindTouch.Dream.XUri,MindTouch.Dream.XUri[])">
            <summary>
            Create a new event from an Xml payload
            </summary>
            <param name="data">Event payload.</param>
            <param name="channel">Event channel.</param>
            <param name="resource">Event resource.</param>
            <param name="origins"> Event origins.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.#ctor(MindTouch.Dream.DreamMessage,MindTouch.Dream.XUri,MindTouch.Dream.XUri,MindTouch.Dream.XUri[])">
            <summary>
            Create a new event from a message body payload.
            </summary>
            <remarks>
            This constructor assumes that the message provided was newly created for the event and belongs to the event.
            </remarks>
            <param name="message">Event payload.</param>
            <param name="channel">Event channel.</param>
            <param name="resource">Event resource.</param>
            <param name="origins"> Event origins.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.GetEventEnvelope">
            <summary>
            Generate the message Xml envelope.
            </summary>
            <returns>Xml envelope instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.HasVisited(MindTouch.Dream.XUri)">
            <summary>
            Determine whether an event has visited a specific uri on its transit.
            </summary>
            <param name="via">Uri to check</param>
            <returns><see langword="True"/> if the Uri was part of the message's transit path.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.AsDocument">
            <summary>
            Get the message payload as a document.
            </summary>
            <returns>Xml document.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.AsMessage">
            <summary>
            Create a new <see cref="T:MindTouch.Dream.DreamMessage"/> instance containing payload and envelope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.WithVia(MindTouch.Dream.XUri)">
            <summary>
            Add a uri to the message's transit path.
            </summary>
            <param name="via"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherEvent.WithRecipient(System.Boolean,MindTouch.Dream.Services.PubSub.DispatcherRecipient[])">
            <summary>
            Add recipients to the message.
            </summary>
            <param name="replace">If <see langword="True"/>, the provide list replaces any existing recipients.</param>
            <param name="recipients">Zero or more recipients.</param>
            <returns>New event instance.</returns>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.DispatcherEvent.HasDocument">
            <summary>
            Does the message have a document payload?
            </summary>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.DispatcherRecipient">
            <summary>
            A <see cref="T:MindTouch.Dream.Services.PubSub.DispatcherEvent"/> recipient.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherRecipient.Uri">
            <summary>
            Canonical uri describing the recipient.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.DispatcherRecipient.Doc">
            <summary>
            Meta data about the recipient.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherRecipient.#ctor(MindTouch.Xml.XDoc)">
            <summary>
            Create a recipient from a recipient document.
            </summary>
            <param name="recipientDoc">Recipient Xml document.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherRecipient.#ctor(MindTouch.Dream.XUri)">
            <summary>
            Create a recipient, given its canonical uri.
            </summary>
            <param name="uri">Recipient uri.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherRecipient.GetHashCode">
            <summary>
            Override of default implementation for comparison purposes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherRecipient.Equals(System.Object)">
            <summary>
            Override of default implementation for comparison purposes.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherRecipient.ToString">
            <summary>
            Override of default implementation for display purposes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.DispatcherRecipient.AsDocument">
            <summary>
            Convert instance to Xml document representation.
            </summary>
            <returns>New Recipient document.</returns>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.PubSubSubscription">
            <summary>
            Provides an object model for a pub sub subscription.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.PubSubSubscription.MergeForChannelAndResource(MindTouch.Dream.XUri,MindTouch.Dream.XUri,MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet,MindTouch.Web.DreamCookie,MindTouch.Dream.Services.PubSub.PubSubSubscription,MindTouch.Dream.Services.PubSub.PubSubSubscription)">
            <summary>
            Merge two subscriptions on matchine channel and resource.
            </summary>
            <param name="channel">Common channel.</param>
            <param name="resource">Common resource.</param>
            <param name="owner">Common owner.</param>
            <param name="cookie">Subscription set cookie.</param>
            <param name="first">First subscription to merge.</param>
            <param name="second">Second subscription to merge.</param>
            <returns></returns>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscription.Id">
            <summary>
            Subscription Id.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscription.Channels">
            <summary>
            Subscription channels.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscription.Resources">
            <summary>
            Subscription resources.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscription.Destination">
            <summary>
            Subscription dispatch destination.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscription.Recipients">
            <summary>
            Subscription recipients.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscription.Owner">
            <summary>
            Subscription owner.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscription.Cookie">
            <summary>
            Dispatch access cookie.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.PubSubSubscription.#ctor(MindTouch.Xml.XDoc,MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet)">
            <summary>
            Create a subscription from a subscription document.
            </summary>
            <param name="sub">Subscription document.</param>
            <param name="owner">Owning set.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.PubSubSubscription.AsDocument">
            <summary>
            Create a subscription document.
            </summary>
            <returns>Subscription Xml document.</returns>
        </member>
        <member name="T:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet">
            <summary>
            Provides a <see cref="T:MindTouch.Dream.Services.PubSub.PubSubSubscription"/> collection.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.Owner">
            <summary>
            Set owner uri.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.Location">
            <summary>
            Pub sub service resource location uri postfix.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.Subscriptions">
            <summary>
            Subscriptions in set.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.MaxFailures">
            <summary>
            Maximum allowed dispatch failures before the set is dropped. Only used if <see cref="P:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.UsesFailureDuration"/> is false.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.AccessKey">
            <summary>
            Access key for reading/modifying the set on the pub sub service.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.Version">
            <summary>
            Set version serial.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.MaxFailureDuration">
            <summary>
            Maximum time period repeated failures are accepted before the set is dropped. Only used if <see cref="P:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.UsesFailureDuration"/> is true.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.#ctor(MindTouch.Dream.XUri,System.Int64,MindTouch.Web.DreamCookie,MindTouch.Dream.Services.PubSub.PubSubSubscription[])">
            <summary>
            Create a new subscription set.
            </summary>
            <param name="owner">Owner uri.</param>
            <param name="version">Version serial number.</param>
            <param name="cookie">Pub sub location access cookie.</param>
            <param name="childSubscriptions">Subscriptions.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.#ctor(MindTouch.Xml.XDoc,System.String,System.String)">
            <summary>
            Create a new subscription set from a subscription set document.
            </summary>
            <param name="setDoc">Set Xml document.</param>
            <param name="location">location id.</param>
            <param name="accessKey">secret key for accessing the set.</param>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.AsDocument">
            <summary>
            Create a new subscription set document.
            </summary>
            <returns>Set Xml document.</returns>
        </member>
        <member name="M:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.Derive(MindTouch.Xml.XDoc,System.String)">
            <summary>
            Derive a new set using a newer subscription set document.
            </summary>
            <param name="doc"></param>
            <param name="accessKey">Optional new access key</param>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.Cookies">
            <summary>
            Dispatch cookies.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.UsesFailureDuration">
            <summary>
            True if this set upes <see cref="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.MaxFailureDuration"/> instead of <see cref="F:MindTouch.Dream.Services.PubSub.PubSubSubscriptionSet.MaxFailures"/> to determine whether the set has exceeded
            its failure threshold and should be dropped.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.XDocAutofacContainerConfigurator">
            <summary>
            Autofac <see cref="T:Autofac.Builder.Module"/> implemenation for Dream specific configuration xml.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.XDocAutofacContainerConfigurator.#ctor(MindTouch.Xml.XDoc,MindTouch.Dream.DreamContainerScope)">
            <summary>
            Create a new XDoc configurator.
            </summary>
            <param name="config">Configuration fragment.</param>
            <param name="defaultScope">Default registration scope.</param>
        </member>
        <member name="M:MindTouch.Dream.XDocAutofacContainerConfigurator.Load(Autofac.Builder.ContainerBuilder)">
            <summary>
            Load the configuration into a builder
            </summary>
            <param name="builder">Container builder to public.</param>
        </member>
        <member name="T:MindTouch.Collections.LockFreeItemConsumerQueue`1">
            <summary>
            Provides an implementation of <see cref="T:MindTouch.Collections.IThreadsafeQueue`1"/> that does not incur locking overhead to provide thread-safe access to its members.
            </summary>
            <typeparam name="T">Type of item the queue can contain.</typeparam>
        </member>
        <member name="T:MindTouch.Collections.IThreadsafeQueue`1">
            <summary>
            Provides a thread-safe queue.
            </summary>
            <typeparam name="T">Type of item in the queue.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.IThreadsafeQueue`1.TryEnqueue(`0)">
            <summary>
            Try to add an item to the queue.
            </summary>
            <param name="item">Item to add to queue.</param>
            <returns><see langword="True"/> if the enqueue succeeded.</returns>
        </member>
        <member name="M:MindTouch.Collections.IThreadsafeQueue`1.TryDequeue(`0@)">
            <summary>
            Try to get an item from the queue.
            </summary>
            <param name="item">Storage location for the item to be removed.</param>
            <returns><see langword="True"/> if the dequeue succeeded.</returns>
        </member>
        <member name="P:MindTouch.Collections.IThreadsafeQueue`1.IsEmpty">
            <summary>
            <see langword="True"/> if the queue is empty.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.IThreadsafeQueue`1.Count">
            <summary>
            Total number of items in queue.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.LockFreeItemConsumerQueue`1.#ctor">
            <summary>
            Create a new instance of the queue.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.LockFreeItemConsumerQueue`1.TryEnqueue(`0)">
            <summary>
            Try to add an item to the queue.
            </summary>
            <param name="item">Item to add to queue.</param>
            <returns>Always returns <see langword="True"/>.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeItemConsumerQueue`1.TryDequeue(`0@)">
            <summary>
            Try to get an item from the queue.
            </summary>
            <param name="item">Storage location for the item to be removed.</param>
            <returns><see langword="True"/> if the dequeue succeeded.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeItemConsumerQueue`1.TryEnqueue(System.Action{`0})">
            <summary>
            Try to add a consumer to the queue.
            </summary>
            <param name="callback">Consumer to add to queue.</param>
            <returns>Always returns <see langword="True"/>.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeItemConsumerQueue`1.TryDequeue(System.Action{`0}@)">
            <summary>
            Try to get a consumer from the queue.
            </summary>
            <param name="callback">Storage location for the consumer to be removed.</param>
            <returns><see langword="True"/> if the dequeue succeeded.</returns>
        </member>
        <member name="P:MindTouch.Collections.LockFreeItemConsumerQueue`1.ItemIsEmpty">
            <summary>
            <see langword="True"/> if there are items in the queue.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.LockFreeItemConsumerQueue`1.ItemCount">
            <summary>
            Total number of items in the queue.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.LockFreeItemConsumerQueue`1.ConsumerIsEmpty">
            <summary>
            <see langword="True"/> if there are consumers in the queue.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.LockFreeItemConsumerQueue`1.ConsumerCount">
            <summary>
            Total number of consumers in the queue.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.ProcessingQueue`1">
            <summary>
            Provides a mechanism for dispatching work items against an <see cref="T:MindTouch.Threading.IDispatchQueue"/>.
            </summary>
            <typeparam name="T">Type of work item that can be dispatched.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.#ctor(System.Action{`0,System.Action},System.Int32,MindTouch.Threading.IDispatchQueue)">
            <summary>
            Create an instance of the work queue.
            </summary>
            <param name="handler">Dispatch action for work item Type and with completion callback.</param>
            <param name="maxParallelism">Maximum number of items being dispatch simultaneously against the dispatch queue.</param>
            <param name="dispatchQueue">Dispatch queue for work items.</param>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.#ctor(System.Action{`0,System.Action},MindTouch.Threading.IDispatchQueue)">
            <summary>
            Create an instance of the work queue.
            </summary>
            <param name="handler">Dispatch action for work item Type and with completion callback.</param>
            <param name="dispatchQueue">Dispatch queue for work items.</param>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.#ctor(System.Action{`0,System.Action},System.Int32)">
            <summary>
            Create an instance of the work queue.
            </summary>
            <param name="handler">Dispatch action for work item Type and with completion callback.</param>
            <param name="maxParallelism">Maximum number of items being dispatch simultaneously against the dispatch queue.</param>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.#ctor(System.Action{`0,System.Action})">
            <summary>
            Create an instance of the work queue.
            </summary>
            <param name="handler">Dispatch action for work item Type and with completion callback.</param>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.#ctor(System.Action{`0},System.Int32,MindTouch.Threading.IDispatchQueue)">
            <summary>
            Create an instance of the work queue.
            </summary>
            <param name="handler">Dispatch action for work item Type.</param>
            <param name="maxParallelism">Maximum number of items being dispatch simultaneously against the dispatch queue.</param>
            <param name="dispatchQueue">Dispatch queue for work items.</param>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.#ctor(System.Action{`0},MindTouch.Threading.IDispatchQueue)">
            <summary>
            Create an instance of the work queue.
            </summary>
            <param name="handler">Dispatch action for work item Type.</param>
            <param name="dispatchQueue">Dispatch queue for work items.</param>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.#ctor(System.Action{`0},System.Int32)">
            <summary>
            Create an instance of the work queue.
            </summary>
            <param name="handler">Dispatch action for work item Type and with completion callback.</param>
            <param name="maxParallelism">Maximum number of items being dispatch simultaneously against the dispatch queue.</param>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.#ctor(System.Action{`0})">
            <summary>
            Create an instance of the work queue.
            </summary>
            <param name="handler">Dispatch action for work item Type and with completion callback.</param>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.TryEnqueue(`0)">
            <summary>
            Try to queue a work item for dispatch.
            </summary>
            <param name="item">Item to add to queue.</param>
            <returns><see langword="True"/> if the enqueue succeeded.</returns>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.TryDequeue(`0@)">
            <summary>
            This method is not supported and throws <see cref="T:System.NotSupportedException"/>.
            </summary>
            <param name="item"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="M:MindTouch.Collections.ProcessingQueue`1.Dispose">
            <summary>
            Release the resources reserved by the work queue from the global thread pool.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ProcessingQueue`1.IsEmpty">
            <summary>
            <see langword="True"/> if the queue is empty.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.ProcessingQueue`1.Count">
            <summary>
            Total number of items in queue.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.XUriEx">
            <summary>
            Provides Dream specific extension methods for <see cref="T:MindTouch.Dream.XUri"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.XUriEx.GetParam``1(MindTouch.Dream.XUri,System.String,``0)">
            <summary>
            Get a typed parameter from the Uri.
            </summary>
            <typeparam name="T">Type of the parameter.</typeparam>
            <param name="uri">Input Uri.</param>
            <param name="key">Parameter key.</param>
            <param name="def">Default value to return in case parameter does not exist.</param>
            <returns>Parameter value or default.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriEx.GetParam``1(MindTouch.Dream.XUri,System.String,System.Int32,``0)">
            <summary>
            Get a typed parameter from the Uri.
            </summary>
            <typeparam name="T">Type of the parameter.</typeparam>
            <param name="uri">Input Uri.</param>
            <param name="key">Parameter key.</param>
            <param name="index">Parameter index.</param>
            <param name="def">Default value to return in case parameter does not exist.</param>
            <returns>Parameter value or default.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriEx.AsPublicUri(MindTouch.Dream.XUri)">
            <summary>
            Translate Uri to request context sensitive public uri.
            </summary>
            <param name="uri">Input uri.</param>
            <returns>Translated Uri or original instance, should translation not be possible.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriEx.AsLocalUri(MindTouch.Dream.XUri)">
            <summary>
            Translate Uri to request context sensitive local uri.
            </summary>
            <param name="uri">Input uri.</param>
            <returns>Translated Uri or original instance, should translation not be possible.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriEx.AsServerUri(MindTouch.Dream.XUri)">
            <summary>
            Translate Uri to request context sensitive server relateive uri.
            </summary>
            <param name="uri">Input uri.</param>
            <returns>Translated Uri or original instance, should translation not be possible.</returns>
        </member>
        <member name="T:MindTouch.Collections.IThreadsafeCollection`1">
            <summary>
            Provides a base set of requirements for a collection of values that allows thread safe addition and removal of items.
            </summary>
            <typeparam name="T">Type of item in the collection.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.IThreadsafeCollection`1.TryAdd(`0)">
            <summary>
            Try to add a new item to the collection.
            </summary>
            <param name="item">Item to add.</param>
            <returns><see langword="True"/> if the add succeeded.</returns>
        </member>
        <member name="M:MindTouch.Collections.IThreadsafeCollection`1.TryRemove(`0@)">
            <summary>
            Try to remove and retrieve an item from the collection.
            </summary>
            <param name="item">Storage location for retrieved item.</param>
            <returns><see langword="True"/> if the remove succeeded</returns>
        </member>
        <member name="P:MindTouch.Collections.IThreadsafeCollection`1.IsEmpty">
            <summary>
            <see langword="True"/> if there are items in the collection.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.IThreadsafePriorityQueue`1">
            <summary>
            Provides a thread-safe queue with priority ordering for enqueued items.
            </summary>
            <typeparam name="T">Type of item in the queue.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.IThreadsafePriorityQueue`1.TryEnqueue(System.Int32,`0)">
            <summary>
            Try to add an item to the queue.
            </summary>
            <param name="priority">Priority of the added item.</param>
            <param name="item">Item to add to queue.</param>
            <returns><see langword="True"/> if the enqueue succeeded.</returns>
        </member>
        <member name="M:MindTouch.Collections.IThreadsafePriorityQueue`1.TryDequeue(System.Int32@,`0@)">
            <summary>
            Try to get an item from the queue.
            </summary>
            <param name="priority">Storage location for priority of the removed item.</param>
            <param name="item">Storage location for the item to be removed.</param>
            <returns><see langword="True"/> if the dequeue succeeded.</returns>
        </member>
        <member name="P:MindTouch.Collections.IThreadsafePriorityQueue`1.IsEmpty">
            <summary>
            <see langword="True"/> if the queue is empty.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.IThreadsafePriorityQueue`1.Count">
            <summary>
            Total number of items in queue.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.IThreadsafePriorityQueue`1.MaxPriority">
            <summary>
            Maximum allowed priority for an enqueued item.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.IThreadsafeStack`1">
            <summary>
            Provides a thread-safe stack.
            </summary>
            <typeparam name="T">Type of item in the stack.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.IThreadsafeStack`1.TryPush(`0)">
            <summary>
            Try to push a new item on top of the stack.
            </summary>
            <param name="item">Item to add.</param>
            <returns><see langword="True"/> if the push succeeded.</returns>
        </member>
        <member name="M:MindTouch.Collections.IThreadsafeStack`1.TryPop(`0@)">
            <summary>
            Try to pop an item from the top of the stack
            </summary>
            <param name="item">Storage location for the item to be removed.</param>
            <returns><see langword="True"/> if the pop succeeded.</returns>
        </member>
        <member name="P:MindTouch.Collections.IThreadsafeStack`1.IsEmpty">
            <summary>
            <see langword="True"/> if the stack is empty.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.IThreadsafeStack`1.Count">
            <summary>
            Total number of items on stack.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.LockFreeXmlNameTable">
            <summary>
            Provides an implementation of <see cref="T:System.Xml.XmlNameTable"/> that does not incur lock contention for access to its members.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.#ctor(System.Int32)">
            <summary>
            Create a new instance.
            </summary>
            <param name="capacity">Number of hash buckets to use for the name table.</param>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.Get(System.Char[],System.Int32,System.Int32)">
            <summary>
            Get a string instance that matches a character sequence, if it exists.
            </summary>
            <param name="chars">Source character array.</param>
            <param name="offset">Offset in chars.</param>
            <param name="length">Length of sub-array from chars.</param>
            <returns>String instance for character sequence or null, if character sequence was not found.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.Get(System.String)">
            <summary>
            Get a string instance from the table for the provided token, if it exists
            </summary>
            <param name="token">Token to look up or store in the name table</param>
            <returns>String instance for token or null, if the token was not found.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.Add(System.Char[],System.Int32,System.Int32)">
            <summary>
            Add character sequence to nametable and get the string instance it represents.
            </summary>
            <remarks>
            If the sequence already exists, the existing string instance is returned.
            </remarks>
            <param name="chars">Source character array.</param>
            <param name="offset">Offset in chars.</param>
            <param name="length">Length of sub-array from chars.</param>
            <returns>String instance for character sequence.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.Add(System.String)">
            <summary>
            Add a token to the name table and get the common string instance it represents.
            </summary>
            <remarks>
            If the token already exists in the name table, the existing instance is returned.
            </remarks>
            <param name="token">The token to add.</param>
            <returns>String instance for the token.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.GetStats(System.Int32@,System.Int32@,System.Int64@,System.Int32[]@,System.Double@)">
            <summary>
            Get statistics for the name table.
            </summary>
            <param name="capacity">Number of buckets used by the name table.</param>
            <param name="entries">Number of entries stored in the name table.</param>
            <param name="bytes">Number of bytes used by the name table storage.</param>
            <param name="distribution">Distribution of hash keys in buckets.</param>
            <param name="expectedComparisonsPerLookup">Expected number of comparisons to retrieve a value.</param>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.GetEntries">
            <summary>
            Get all string instances stored in the name table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeXmlNameTable.GetIndex(System.Int32)">
            <summary>
            Get a string instance for a spcific hash code.
            </summary>
            <param name="hashcode"></param>
            <returns></returns>
        </member>
        <member name="T:MindTouch.Collections.LockFreePriorityQueue`1">
            <summary>
            Provides an implementation of <see cref="T:MindTouch.Collections.IThreadsafePriorityQueue`1"/> that does not incur locking overhead to provide thread-safe access to its members.
            </summary>
            <typeparam name="T">Type of item the queue can contain.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.LockFreePriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Create a new instance of the queue.
            </summary>
            <param name="maxPriority">Maximum priority for <see cref="M:MindTouch.Collections.LockFreePriorityQueue`1.TryEnqueue(System.Int32,`0)"/>.</param>
        </member>
        <member name="M:MindTouch.Collections.LockFreePriorityQueue`1.TryEnqueue(System.Int32,`0)">
            <summary>
            Try to add an item to the queue.
            </summary>
            <param name="priority">Priority of the added item.</param>
            <param name="item">Item to add to queue.</param>
            <returns>Always returns <see langword="True"/>.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreePriorityQueue`1.TryDequeue(System.Int32@,`0@)">
            <summary>
            Try to get an item from the queue.
            </summary>
            <param name="priority">Storage location for priority of the removed item.</param>
            <param name="item">Storage location for the item to be removed.</param>
            <returns><see langword="True"/> if the dequeue succeeded.</returns>
        </member>
        <member name="P:MindTouch.Collections.LockFreePriorityQueue`1.IsEmpty">
            <summary>
            <see langword="True"/> if the queue is empty.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.LockFreePriorityQueue`1.Count">
            <summary>
            Total number of items in queue.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.LockFreePriorityQueue`1.MaxPriority">
            <summary>
            Maximum allowed priority for an enqueued item.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.LockFreeQueue`1">
            <summary>
            Provides an implementation of <see cref="T:MindTouch.Collections.IThreadsafeQueue`1"/> that does not incur locking overhead to provide thread-safe access to its members.
            </summary>
            <typeparam name="T">Type of item the queue can contain.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.LockFreeQueue`1.#ctor">
            <summary>
            Create a new instance of the queue.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.LockFreeQueue`1.TryEnqueue(`0)">
            <summary>
            Try to add an item to the queue.
            </summary>
            <param name="item">Item to add to queue.</param>
            <returns><see langword="True"/> if the enqueue succeeded.</returns>
            <returns>Always returns <see langword="True"/>.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeQueue`1.TryDequeue(`0@)">
            <summary>
            Try to get an item from the queue.
            </summary>
            <param name="item">Storage location for the item to be removed.</param>
            <returns><see langword="True"/> if the dequeue succeeded.</returns>
        </member>
        <member name="P:MindTouch.Collections.LockFreeQueue`1.IsEmpty">
            <summary>
            <see langword="True"/> if the queue is empty.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.LockFreeQueue`1.Count">
            <summary>
            Total number of items in queue.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.LockFreeStack`1">
            <summary>
            Provides and implementation of <see cref="T:MindTouch.Collections.IThreadsafeStack`1"/> that does not incur locking overhead to provide thread-safe access to its members.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MindTouch.Collections.LockFreeStack`1.TryPush(`0)">
            <summary>
            Try to push a new item on top of the stack.
            </summary>
            <param name="item">Item to add.</param>
            <returns><see langword="True"/> if the push succeeded.</returns>
        </member>
        <member name="M:MindTouch.Collections.LockFreeStack`1.TryPop(`0@)">
            <summary>
            Try to pop an item from the top of the stack
            </summary>
            <param name="item">Storage location for the item to be removed.</param>
            <returns><see langword="True"/> if the pop succeeded.</returns>
        </member>
        <member name="P:MindTouch.Collections.LockFreeStack`1.IsEmpty">
            <summary>
            <see langword="True"/> if the stack is empty.
            </summary>
        </member>
        <member name="P:MindTouch.Collections.LockFreeStack`1.Count">
            <summary>
            Total number of items on stack.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.WorkStealingDeque`1">
            <summary>
            Provides a queue that allows items to pushed and popped by a single thread while 
            other threads may attempt steal from it.  The implementation is based on the work done by 
            Danny Hendler, Yossi Lev, Mark Moir, and Nir Shavit: "A dynamic-sized nonblocking work stealing deque", 
            Distributed Computing, Volume 18, Issue 3 (February 2006), pp189-207, ISSN:0178-2770 
            </summary>
            <typeparam name="T">Collection item type.</typeparam>
        </member>
        <member name="M:MindTouch.Collections.WorkStealingDeque`1.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.WorkStealingDeque`1.#ctor(System.Int32)">
            <summary>
            Create a new instance.
            </summary>
            <param name="capacity">Maximum number of items in the queue.</param>
        </member>
        <member name="M:MindTouch.Collections.WorkStealingDeque`1.Push(`0)">
            <summary>
            Push an item onto the tail of the queue.
            </summary>
            <remarks>
            NOTE: Push() and TryPop() <strong>MUST</strong> be called from the same thread.
            </remarks>
            <param name="data">Item to push onto the tail of the queue.</param>
        </member>
        <member name="M:MindTouch.Collections.WorkStealingDeque`1.TryPop(`0@)">
            <summary>
            Pop an item from the tail of the queue.
            </summary>
            <remarks>
            NOTE: Push() and TryPop() <strong>MUST</strong> be called from the same thread.
            </remarks>
            <param name="item">Tail item of the queue when operation is successful.</param>
            <returns><see langword="True"/> if operation was successful.</returns>
        </member>
        <member name="M:MindTouch.Collections.WorkStealingDeque`1.TrySteal(`0@)">
            <summary>
            Pop an item from the head of the queue.
            </summary>
            <remarks>
            NOTE: TrySteal() can be invoked from any thread.
            </remarks>
            <param name="item">Head item of the queue when operation is successful.</param>
            <returns><see langword="True"/> if operation was successful.</returns>
        </member>
        <member name="P:MindTouch.Collections.WorkStealingDeque`1.Count">
            <summary>
            Total number of items in queue.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.TransactionalQueue`1">
            <summary>
            A specialized queue that uses a two-phase dequeue to retrieve items
            </summary>
            <remarks>
            Items dequeued are invisible to other users of the queue, but are not permanently removed until the dequeue is either committed,
            or rolled back, the latter action making the item availabe for dequeuing again
            </remarks>
            <typeparam name="T">Type of entries in the queue</typeparam>
        </member>
        <member name="M:MindTouch.Collections.TransactionalQueue`1.#ctor(MindTouch.IO.IQueueStream,MindTouch.IO.IQueueItemSerializer{`0})">
            <summary>
            Create a new Queue given an <see cref="T:MindTouch.IO.IQueueStream"/> storage provider and an <see cref="T:MindTouch.IO.IQueueItemSerializer`1"/> serializer for type T.
            </summary>
            <remarks>
            This class assumes ownership of the provided <see cref="T:MindTouch.IO.IQueueStream"/> resource and will dispose it upon instance disposal
            </remarks>
            <param name="stream">An implementation of <see cref="T:MindTouch.IO.IQueueStream"/> <seealso cref="T:MindTouch.IO.SingleFileQueueStream"/><seealso cref="T:MindTouch.IO.MultiFileQueueStream"/></param>
            <param name="serializer">A serializer implementation of <see cref="T:MindTouch.IO.IQueueItemSerializer`1"/> for type T</param>
        </member>
        <member name="M:MindTouch.Collections.TransactionalQueue`1.Clear">
            <summary>
            Clear out the queue and drop all items, including pending commits.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.TransactionalQueue`1.Enqueue(`0)">
            <summary>
            Put an item into the queue
            </summary>
            <param name="item">An instance of type T</param>
        </member>
        <member name="M:MindTouch.Collections.TransactionalQueue`1.Dequeue">
            <summary>
            Get the next available item from the queue. Must call <see cref="M:MindTouch.Collections.TransactionalQueue`1.CommitDequeue(System.Int64)"/> to fully take possession or the item. Uses <see cref="P:MindTouch.Collections.TransactionalQueue`1.DefaultCommitTimeout"/>.
            </summary>
            <remarks>
            Phase 1 of the two-phase dequeue. <see cref="M:MindTouch.Collections.TransactionalQueue`1.CommitDequeue(System.Int64)"/> within <see cref="P:MindTouch.Collections.TransactionalQueue`1.DefaultCommitTimeout"/> completes the dequeue, while waiting for the timeout to
            expire or calling <see cref="M:MindTouch.Collections.TransactionalQueue`1.RollbackDequeue(System.Int64)"/> aborts the dequeue.
            </remarks>
            <returns>
            An instance of <see cref="T:MindTouch.Collections.ITransactionalQueueEntry`1"/> wrapping the dequeued value and item id for use 
            with <see cref="M:MindTouch.Collections.TransactionalQueue`1.CommitDequeue(System.Int64)"/> or <see cref="M:MindTouch.Collections.TransactionalQueue`1.RollbackDequeue(System.Int64)"/>. <see langword="null"/> if the queue is empty.
            </returns>
        </member>
        <member name="M:MindTouch.Collections.TransactionalQueue`1.Dequeue(System.TimeSpan)">
            <summary>
            Get the next available item from the queue. Must call <see cref="M:MindTouch.Collections.TransactionalQueue`1.CommitDequeue(System.Int64)"/> to fully take possession or the item.
            </summary>
            <remarks>
            Phase 1 of the two-phase dequeue. <see cref="M:MindTouch.Collections.TransactionalQueue`1.CommitDequeue(System.Int64)"/> within <b>commitTimeout</b> completes the dequeue, while waiting for the timeout to
            expire or calling <see cref="M:MindTouch.Collections.TransactionalQueue`1.RollbackDequeue(System.Int64)"/> aborts the dequeue.
            </remarks>
            <param name="commitTimeout">Time before an uncommitted dequeue is considered abandoned and automatically rolled back</param>
            <returns>
            An instance of <see cref="T:MindTouch.Collections.ITransactionalQueueEntry`1"/> wrapping the dequeued value and item id for use 
            with <see cref="M:MindTouch.Collections.TransactionalQueue`1.CommitDequeue(System.Int64)"/> or <see cref="M:MindTouch.Collections.TransactionalQueue`1.RollbackDequeue(System.Int64)"/>. <see langword="null"/> if the queue is empty.
            </returns>
        </member>
        <member name="M:MindTouch.Collections.TransactionalQueue`1.CommitDequeue(System.Int64)">
            <summary>
            Completes the two-phase <see cref="M:MindTouch.Collections.TransactionalQueue`1.Dequeue"/>.
            </summary>
            <param name="id"><see cref="P:MindTouch.Collections.ITransactionalQueueEntry`1.Id"/> identifier of the dequeued item</param>
            <returns><see langword="true"/> if the commit succeeded, <see langword="false"/> if the item was already dequeued or has been rolled back</returns>
        </member>
        <member name="M:MindTouch.Collections.TransactionalQueue`1.RollbackDequeue(System.Int64)">
            <summary>
            Undo <see cref="M:MindTouch.Collections.TransactionalQueue`1.Dequeue"/> and return item back to the queue.
            </summary>
            <param name="id"><see cref="P:MindTouch.Collections.ITransactionalQueueEntry`1.Id"/> identifier of the dequeued item</param>
        </member>
        <member name="M:MindTouch.Collections.TransactionalQueue`1.Dispose">
            <summary>
            Clean up the resources used by the Queue per the <see cref="T:System.IDisposable"/> pattern
            </summary>
        </member>
        <member name="P:MindTouch.Collections.TransactionalQueue`1.DefaultCommitTimeout">
            <summary>
            The default timeout used for a dequeued item before the item is considered abandoned and automatically rolled back
            </summary>
        </member>
        <member name="P:MindTouch.Collections.TransactionalQueue`1.Count">
            <summary>
            The current count of items available for <see cref="M:MindTouch.Collections.TransactionalQueue`1.Dequeue"/>
            </summary>
            <remarks>
            Count only reflects items available for dequeue, not items pending commit or rollback
            </remarks>
        </member>
        <member name="T:System.Collections.Generic.PriorityQueueComparer`1">
            <summary>
            Delegate used by <see cref="T:System.Collections.Generic.PriorityQueue`1"/> to determine priority order of items.
            </summary>
            <typeparam name="T">Type of item in queue.</typeparam>
            <param name="first">First item.</param>
            <param name="second">Second item.</param>
            <returns>Negative if the second item should come before the first, otherwise the order remains the same.</returns>
        </member>
        <member name="T:System.Collections.Generic.PriorityQueue`1">
            <summary>
            Provides a queue that determines the dequeue order of items by priority.
            </summary>
            <typeparam name="T">Type of item in the queue.</typeparam>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`1._list">
            <summary>
            Internal storage of queue items.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.PriorityQueue`1._comparer">
            <summary>
            Comparison delegate for doing queue priority ordering.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.#ctor(System.Collections.Generic.PriorityQueueComparer{`0})">
            <summary>
            Create a new queue instance.
            </summary>
            <param name="comparer">Comparison delegate for ordering queue items by priority.</param>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.PriorityQueueComparer{`0})">
            <summary>
            Create a new queue instance.
            </summary>
            <param name="capacity">Initial capacity of queue.</param>
            <param name="comparer">Comparison delegate for ordering queue items by priority.</param>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Enqueue(`0)">
            <summary>
            Add an item to queue.
            </summary>
            <param name="item">Item to add.</param>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Dequeue">
            <summary>
            Get the next item from the queue.
            </summary>
            <returns>The next item from the queue.</returns>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Peek">
            <summary>
            Get the next item in the queue without removing it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Remove(`0)">
            <summary>
            Remove an item from the queue.
            </summary>
            <param name="item">The item to remove from the queue.</param>
            <returns><see langword="True"/> if the remove succeeded.</returns>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Clear">
            <summary>
            Clear all items from the queue.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.SwitchElements(System.Int32,System.Int32)">
            <summary>
            Switch the position of two index positions in the queue.
            </summary>
            <param name="i">First index to switch into second.</param>
            <param name="j">Second index to switch into first.</param>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.RebalanceBinaryArrayStartingAt(System.Int32)">
            <summary>
            Rebalance the queue starting at a specific index into <see cref="F:System.Collections.Generic.PriorityQueue`1._list"/>.
            </summary>
            <param name="i"></param>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`1.Count">
            <summary>
            Number of items in the queue.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`1.IsEmpty">
            <summary>
            <see langword="True"/> if there are no items in the queue.
            </summary>
        </member>
        <member name="T:MindTouch.Collections.SingleLinkNode`1">
            <summary>
            Provides a node container class for data in a singly linked list
            </summary>
            <typeparam name="T">Type of data contained by the node.</typeparam>
        </member>
        <member name="F:MindTouch.Collections.SingleLinkNode`1.Next">
            <summary>
            Pointer to the next node in list.
            </summary>
        </member>
        <member name="F:MindTouch.Collections.SingleLinkNode`1.Item">
            <summary>
            The data contained by the node.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.SingleLinkNode`1.#ctor">
            <summary>
            Create a new node instance.
            </summary>
        </member>
        <member name="M:MindTouch.Collections.SingleLinkNode`1.#ctor(`0)">
            <summary>
            Create a new node instance.
            </summary>
            <param name="item">Initial data value.</param>
        </member>
        <member name="T:MindTouch.IO.XDocQueueItemSerializer">
            <summary>
            <see cref="T:MindTouch.Xml.XDoc"/> to and from <see cref="T:System.IO.Stream"/> serializer
            </summary>
            <remarks>
            Exists primarily for use with <see cref="T:MindTouch.Collections.TransactionalQueue`1"/>
            </remarks>
        </member>
        <member name="M:MindTouch.IO.XDocQueueItemSerializer.ToStream(MindTouch.Xml.XDoc)">
            <summary>
            Serialize an <see cref="T:MindTouch.Xml.XDoc"/> to a <see cref="T:System.IO.Stream"/>
            </summary> 
            <param name="doc">An <see cref="T:MindTouch.Xml.XDoc"/> document</param>
            <returns>A <see cref="T:System.IO.Stream"/></returns>
        </member>
        <member name="M:MindTouch.IO.XDocQueueItemSerializer.FromStream(System.IO.Stream)">
            <summary>
            Create an instance of <see cref="T:MindTouch.Xml.XDoc"/> from a binary <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/></param>
            <returns>An <see cref="T:MindTouch.Xml.XDoc"/> document</returns>
        </member>
        <member name="T:MindTouch.Data.IDataCatalog">
            <summary>
            Provides a database catalog abstraction.
            </summary>
        </member>
        <member name="M:MindTouch.Data.IDataCatalog.NewQuery(System.String)">
            <summary>
            Create a new query command.
            </summary>
            <param name="query">SQL query string.</param>
            <returns>Query instance.</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCatalog.NewReadOnlyQuery(System.String)">
            <summary>
            Create new a read-only query command.
            </summary>
            <param name="query">SQL query string.</param>
            <returns>Query instance.</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCatalog.NewQuery(System.String,System.Boolean)">
            <summary>
            Create a new query command.
            </summary>
            <param name="query">SQL query string.</param>
            <param name="readonly"><see langword="True"/> if the query is read-only.</param>
            <returns>New Query instance.</returns>
        </member>
        <member name="T:MindTouch.Data.DataCatalog">
            <summary>
            Provides a database catalog abstraction.
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.#ctor(MindTouch.Data.DataFactory,System.String)">
            <summary>
            Create a new instance.
            </summary>
            <param name="factory">Factory to use for command construction and query execution.</param>
            <param name="connectionString">Database connection string.</param>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.#ctor(MindTouch.Data.DataFactory,MindTouch.Xml.XDoc)">
            <summary>
            This constructor is deprecated, please use use the constructor requiring a connectionString instead
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.NewQuery(System.String)">
            <summary>
            Create a new query command.
            </summary>
            <param name="query">SQL query string.</param>
            <returns>Query instance.</returns>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.NewReadOnlyQuery(System.String)">
            <summary>
            Create new a read-only query command.
            </summary>
            <param name="query">SQL query string.</param>
            <returns>Query instance.</returns>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.NewQuery(System.String,System.Boolean)">
            <summary>
            Create a new query command.
            </summary>
            <param name="query">SQL query string.</param>
            <param name="readonly"><see langword="True"/> if the query is read-only.</param>
            <returns>New Query instance.</returns>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.NewProcedure(System.String)">
            <summary>
            Create a new stored procedure command.
            </summary>
            <param name="name">Name of the stored procedure.</param>
            <returns>Stored procedure command.</returns>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.NewReadOnlyProcedure(System.String)">
            <summary>
            Create a new read-only stored procedure command.
            </summary>
            <param name="name">Name of the stored procedure.</param>
            <returns>Stored procedure command.</returns>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.NewProcedure(System.String,System.Boolean)">
            <summary>
            Create a new stored procedure command.
            </summary>
            <param name="name">Name of the stored procedure.</param>
            <param name="readonly"><see langword="True"/> if the query is read-only.</param>
            <returns>Stored procedure command.</returns>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.TestConnection">
            <summary>
            Test the database connection.
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataCatalog.TestConnection(System.Boolean)">
            <summary>
            Test the read-only database connection.
            </summary>
            <param name="readonly"></param>
        </member>
        <member name="P:MindTouch.Data.DataCatalog.ConnectionString">
            <summary>
            This property bypasses the safety measures provided by MindTouch.Data objects.  Please avoid using it if possible.
            </summary>
        </member>
        <member name="E:MindTouch.Data.DataCatalog.OnQueryFinished">
            <summary>
            Notification of execution completion of an <see cref="T:MindTouch.Data.DataCommand"/> created by this instance.
            </summary>
        </member>
        <member name="T:MindTouch.Data.DataCommand">
            <summary>
            Provides a a database query/stored procedure command builder.
            </summary>
        </member>
        <member name="T:MindTouch.Data.IDataCommand">
            <summary>
            Provides a a database query/stored procedure command builder.
            </summary>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.With(System.String,System.Object)">
            <summary>
            Adds an input parameter to the command.
            </summary>
            <param name="key">Name of the parameter</param>
            <param name="value">Value of the parameter</param>
            <returns>Returns this command</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.WithInOut(System.String,System.Object)">
            <summary>
            Adds an input-output parameter to the command.
            </summary>
            <param name="key">Name of the parameter</param>
            <param name="value">Value of the parameter</param>
            <returns>Returns this command</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.WithOutput(System.String)">
            <summary>
            Adds an output parameter to the command.
            </summary>
            <param name="key">Name of the parameter</param>
            <returns>Returns this command</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.WithReturn(System.String)">
            <summary>
            Adds an return parameter to the command.
            </summary>
            <param name="key">Name of the parameter</param>
            <returns>Returns this command</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.At``1(System.String)">
            <summary>
            Retrieve an output/return value from the finished command.
            </summary>
            <typeparam name="T">Returned value type</typeparam>
            <param name="key">Name of returned parameter (provided previously using 'WithOutput()' or 'WithInOut()' or 'WithReturn()'</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.At``1(System.String,``0)">
            <summary>
            Retrieve an output/return value from the finished command.
            </summary>
            <typeparam name="T">Returned value type</typeparam>
            <param name="key">Name of returned parameter (provided previously using 'WithOutput()' or 'WithInOut()' or 'WithReturn()'</param>
            <param name="def">Value to return if returned value is null or DbNull</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.Execute">
            <summary>
            Execute command.
            </summary>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.Execute(System.Action{System.Data.IDataReader})">
            <summary>
            Execute command and call handler with an open IDataReader on the result set.  
            IDataReader and connection will be automatically closed upon completion of the handler.
            </summary>
            <param name="handler">Handler to invoke</param>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.Read">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Read value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsBool">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsByte">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsShort">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsUShort">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsInt">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsLong">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsUInt">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsULong">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsDateTime">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsXDoc(System.String,System.String)">
            <summary>
            Execute command and read result into an XDoc.
            </summary>
            <param name="table">Name of the root element</param>
            <param name="row">Name of the element created for each row</param>
            <returns>Read DataSet object</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsObject``1">
            <summary>
            Execute command and convert the first row into an object.
            </summary>
            <typeparam name="T">Object type to create</typeparam>
            <returns>Created object</returns>
        </member>
        <member name="M:MindTouch.Data.IDataCommand.ReadAsObjects``1">
            <summary>
            Execute command and convert all rows into a list of objects.
            </summary>
            <typeparam name="T">Object type to create</typeparam>
            <returns>List of created objects</returns>
        </member>
        <member name="P:MindTouch.Data.IDataCommand.IsStoredProcedure">
            <summary>
            <see langword="True"/> if this command is a stored procedure.
            </summary>
        </member>
        <member name="P:MindTouch.Data.IDataCommand.ExecutionTime">
            <summary>
            Execution time of the last query 
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataCommand.MakeSqlSafe(System.String)">
            <summary>
            Ensure that string is safe for use in SQL statements.
            </summary>
            <param name="text">String to escape</param>
            <returns>Escaped string</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.With(System.String,System.Object)">
            <summary>
            Adds an input parameter to the command.
            </summary>
            <param name="key">Name of the parameter</param>
            <param name="value">Value of the parameter</param>
            <returns>Returns this command</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.WithInOut(System.String,System.Object)">
            <summary>
            Adds an input-output parameter to the command.
            </summary>
            <param name="key">Name of the parameter</param>
            <param name="value">Value of the parameter</param>
            <returns>Returns this command</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.WithOutput(System.String)">
            <summary>
            Adds an output parameter to the command.
            </summary>
            <param name="key">Name of the parameter</param>
            <returns>Returns this command</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.WithReturn(System.String)">
            <summary>
            Adds an return parameter to the command.
            </summary>
            <param name="key">Name of the parameter</param>
            <returns>Returns this command</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.At``1(System.String)">
            <summary>
            Retrieve an output/return value from the finished command.
            </summary>
            <typeparam name="T">Returned value type</typeparam>
            <param name="key">Name of returned parameter (provided previously using 'WithOutput()' or 'WithInOut()' or 'WithReturn()'</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.At``1(System.String,``0)">
            <summary>
            Retrieve an output/return value from the finished command.
            </summary>
            <typeparam name="T">Returned value type</typeparam>
            <param name="key">Name of returned parameter (provided previously using 'WithOutput()' or 'WithInOut()' or 'WithReturn()'</param>
            <param name="def">Value to return if returned value is null or DbNull</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.Execute">
            <summary>
            Execute command.
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataCommand.Execute(System.Action{System.Data.IDataReader})">
            <summary>
            Execute command and call handler with an open IDataReader on the result set.  
            IDataReader and connection will be automatically closed upon completion of the handler.
            </summary>
            <param name="handler">Handler to invoke</param>
        </member>
        <member name="M:MindTouch.Data.DataCommand.Read">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Read value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsBool">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsByte">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsShort">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsUShort">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsInt">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsLong">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsUInt">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsULong">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsDateTime">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAs``1">
            <summary>
            Execute command and return value from the first column in the first row.
            </summary>
            <typeparam name="T">Returned value type</typeparam>
            <returns>Converted value</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsDataSet">
            <summary>
            Execute command and read result into a DataSet.
            </summary>
            <returns>Read DataSet object</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsXDoc(System.String,System.String)">
            <summary>
            Execute command and read result into an XDoc.
            </summary>
            <param name="table">Name of the root element</param>
            <param name="row">Name of the element created for each row</param>
            <returns>Read DataSet object</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsObject``1">
            <summary>
            Execute command and convert the first row into an object.
            </summary>
            <typeparam name="T">Object type to create</typeparam>
            <returns>Created object</returns>
        </member>
        <member name="M:MindTouch.Data.DataCommand.ReadAsObjects``1">
            <summary>
            Execute command and convert all rows into a list of objects.
            </summary>
            <typeparam name="T">Object type to create</typeparam>
            <returns>List of created objects</returns>
        </member>
        <member name="P:MindTouch.Data.DataCommand.IsStoredProcedure">
            <summary>
            <see langword="True"/> if this command is a stored procedure.
            </summary>
        </member>
        <member name="P:MindTouch.Data.DataCommand.ExecutionTime">
            <summary>
            Execution time of the last query 
            </summary>
        </member>
        <member name="T:MindTouch.Data.DataFactory">
            <summary>
            Provides a factory of ADO.NET objects for use by <see cref="T:MindTouch.Data.DataCatalog"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataFactory.#ctor(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This constructor is obsolete. Use a constructor using or creating a <see cref="T:System.Data.Common.DbProviderFactory"/> instead (including constructor that takes assemblyName and parameterChar).
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataFactory.#ctor(System.String,System.String,System.String)">
            <summary>
            This constructor is obsolete. Use a constructor using or creating a <see cref="T:System.Data.Common.DbProviderFactory"/> instead (including constructor that takes assemblyName and parameterChar).
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataFactory.#ctor(System.Type,System.Type,System.Type,System.Type,System.String)">
            <summary>
            This constructor is obsolete. Use a constructor using or creating a <see cref="T:System.Data.Common.DbProviderFactory"/> instead (including constructor that takes assemblyName and parameterChar).
            </summary>
        </member>
        <member name="M:MindTouch.Data.DataFactory.#ctor(System.String,System.String)">
            <summary>
            Create a new instance by dynamically loading a <see cref="T:System.Data.Common.DbProviderFactory"/>.
            </summary>
            <param name="assemblyName">Name of the assembly containing a <see cref="T:System.Data.Common.DbProviderFactory"/>.</param>
            <param name="parameterChar">Query parameter prefix character.</param>
        </member>
        <member name="M:MindTouch.Data.DataFactory.#ctor(System.Data.Common.DbProviderFactory,System.String)">
            <summary>
            Create a new instance based on an existing <see cref="T:System.Data.Common.DbProviderFactory"/>.
            </summary>
            <param name="factory">Provider factory instance.</param>
            <param name="parameterChar">Query parameter prefix character.</param>
        </member>
        <member name="T:MindTouch.Data.IDocStore">
            <summary>
            Provides access to a persistently stored collection of documents.
            </summary>
        </member>
        <member name="M:MindTouch.Data.IDocStore.Put(MindTouch.Xml.XDoc,System.Boolean)">
            <summary>
            Store a document in the collection.
            </summary>
            <param name="doc">Document to store.</param>
            <param name="force"><see langword="True"/> if the write should proceed even if optimistic locking meta-data indicates the document is older than the document already stored.</param>
            <returns><see langword="True"/> if the action completed successfully.</returns>
        </member>
        <member name="M:MindTouch.Data.IDocStore.Delete(System.String)">
            <summary>
            Delete a document from the collection.
            </summary>
            <param name="docId">Unique identifier of the document.</param>
            <returns><see langword="True"/> if the there was a document to be deleted.</returns>
        </member>
        <member name="M:MindTouch.Data.IDocStore.Get(System.String)">
            <summary>
            Retrieve a document by its unique identifier.
            </summary>
            <param name="docId">Unique identifier of the document.</param>
            <returns>Document instance.</returns>
        </member>
        <member name="M:MindTouch.Data.IDocStore.Get(System.Int32,System.Int32)">
            <summary>
            Get a subset of documents from the collection, ordered by insertion order.
            </summary>
            <param name="offset">Offset into collection.</param>
            <param name="limit">Maximum number of documents to retrieve.</param>
            <returns>Enumerable of matching documents.</returns>
        </member>
        <member name="M:MindTouch.Data.IDocStore.Get(System.String,System.String)">
            <summary>
            Query the collection based on an indexed key in the document.
            </summary>
            <param name="keyName">Name of the index key.</param>
            <param name="keyValue">Value of the key.</param>
            <returns>Enumerable of matching documents.</returns>
        </member>
        <member name="M:MindTouch.Data.IDocStore.Get(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Query the collection based on an indexed key in the document.
            </summary>
            <param name="keyName">Name of the index key.</param>
            <param name="keyValue">Value of the key.</param>
            <param name="offset">Offset into collection.</param>
            <param name="limit">Maximum number of documents to retrieve.</param>
            <returns>Enumerable of matching documents.</returns>
        </member>
        <member name="P:MindTouch.Data.IDocStore.AsQueryable">
            <summary>
            Provides queryable access to the document storage.
            </summary>
        </member>
        <member name="T:MindTouch.Data.MysqlDocStore">
            <summary>
            Provides and implementation of <see cref="T:MindTouch.Data.IDocStore"/> using Mysql as its persistence engine.
            </summary>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStore.#ctor(MindTouch.Data.IDataCatalog,MindTouch.Data.IMysqlDocStoreIndexer)">
            <summary>
            Create a new storage instance.
            </summary>
            <param name="catalog">DataCatalog to use for collection storage.</param>
            <param name="indexer">Indexing service.</param>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStore.Put(MindTouch.Xml.XDoc,System.Boolean)">
            <summary>
            Store a document in the collection.
            </summary>
            <param name="doc">Document to store.</param>
            <param name="force"><see langword="True"/> if the write should proceed even if optimistic locking meta-data indicates the document is older than the document already stored.</param>
            <returns><see langword="True"/> if the action completed successfully.</returns>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStore.Delete(System.String)">
            <summary>
            Delete a document from the collection.
            </summary>
            <param name="docId">Unique identifier of the document.</param>
            <returns><see langword="True"/> if the there was a document to be deleted.</returns>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStore.Get(System.String)">
            <summary>
            Retrieve a document by its unique identifier.
            </summary>
            <param name="docId">Unique identifier of the document.</param>
            <returns>Document instance.</returns>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStore.Get(System.Int32,System.Int32)">
            <summary>
            Get a subset of documents from the collection, ordered by insertion order.
            </summary>
            <param name="offset">Offset into collection.</param>
            <param name="limit">Maximum number of documents to retrieve.</param>
            <returns>Enumerable of matching documents.</returns>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStore.Get(System.String,System.String)">
            <summary>
            Query the collection based on an indexed key in the document.
            </summary>
            <param name="keyName">Name of the index key.</param>
            <param name="keyValue">Value of the key.</param>
            <returns>Enumerable of matching documents.</returns>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStore.Get(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Query the collection based on an indexed key in the document.
            </summary>
            <param name="keyName">Name of the index key.</param>
            <param name="keyValue">Value of the key.</param>
            <param name="offset">Offset into collection.</param>
            <param name="limit">Maximum number of documents to retrieve.</param>
            <returns>Enumerable of matching documents.</returns>
        </member>
        <member name="P:MindTouch.Data.MysqlDocStore.AsQueryable">
            <summary>
            Provides queryable access to the document storage.
            </summary>
        </member>
        <member name="T:MindTouch.Data.IndexInfo">
            <summary>
            Index information entity.
            </summary>
        </member>
        <member name="F:MindTouch.Data.IndexInfo.Name">
            <summary>
            Index name.
            </summary>
        </member>
        <member name="F:MindTouch.Data.IndexInfo.Table">
            <summary>
            Database table name.
            </summary>
        </member>
        <member name="F:MindTouch.Data.IndexInfo.XPath">
            <summary>
            Indexed XPath expression.
            </summary>
        </member>
        <member name="T:MindTouch.Data.IMysqlDocStoreIndexer">
            <summary>
            Provides an indexing service for use by a <see cref="T:MindTouch.Data.MysqlDocStore"/> instances.
            </summary>
        </member>
        <member name="M:MindTouch.Data.IMysqlDocStoreIndexer.QueueUpdate(System.Int32,System.Int32,MindTouch.Xml.XDoc)">
            <summary>
            Queue a document for indexing.
            </summary>
            <param name="id">Primary key of document.</param>
            <param name="revision">Revision of document.</param>
            <param name="doc">Document to be indexed.</param>
        </member>
        <member name="M:MindTouch.Data.IMysqlDocStoreIndexer.QueueDelete(System.Int32)">
            <summary>
            Queue a document for removal from all indicies.
            </summary>
            <param name="id">Primary key of document.</param>
        </member>
        <member name="M:MindTouch.Data.IMysqlDocStoreIndexer.GetIndexInfo(System.String)">
            <summary>
            Get the index information for a key.
            </summary>
            <param name="keyName">Name of index key.</param>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Data.IMysqlDocStoreIndexer.Config">
            <summary>
            Get the collection configuration.
            </summary>
        </member>
        <member name="P:MindTouch.Data.IMysqlDocStoreIndexer.Name">
            <summary>
            Get the collection name.
            </summary>
        </member>
        <member name="T:MindTouch.Data.MysqlDocStoreManager">
            <summary>
            Provides an implemenation of <see cref="T:MindTouch.Data.IMysqlDocStoreIndexer"/>
            </summary>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.#ctor(MindTouch.Data.IDataCatalog,MindTouch.Xml.XDoc)">
            <summary>
            Create a new storage manager.
            </summary>
            <param name="catalog">Database catalog to use.</param>
            <param name="config">Collection and index configuration.</param>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.AddIndex(System.String,System.String)">
            <summary>
            Manually add an index.
            </summary>
            <param name="keyName">Name of the index.</param>
            <param name="xpath">XPath expression to index.</param>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.ChangeIndex(System.String,System.String)">
            <summary>
            Modify an existing index.
            </summary>
            <param name="keyName">Name of existing index.</param>
            <param name="xpath">New XPath expression.</param>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.RemoveIndex(System.String)">
            <summary>
            Drop an an index.
            </summary>
            <param name="keyName">Name of the index.</param>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.RebuildIndex(System.String)">
            <summary>
            Rebuild all values in an index.
            </summary>
            <param name="keyName">Name of the index.</param>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.QueueUpdate(System.Int32,System.Int32,MindTouch.Xml.XDoc)">
            <summary>
            Queue a document for indexing.
            </summary>
            <param name="id">Primary key of document.</param>
            <param name="revision">Revision of document.</param>
            <param name="doc">Document to be indexed.</param>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.QueueDelete(System.Int32)">
            <summary>
            Queue a document for removal from all indicies.
            </summary>
            <param name="id">Primary key of document.</param>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.GetIndexInfo(System.String)">
            <summary>
            Get the index information for a key.
            </summary>
            <param name="keyName">Name of index key.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Data.MysqlDocStoreManager.DropDataStore(MindTouch.Data.IDataCatalog,System.String)">
            <summary>
            Drop the entire data store.
            </summary>
            <param name="catalog"></param>
            <param name="name"></param>
        </member>
        <member name="P:MindTouch.Data.MysqlDocStoreManager.Config">
            <summary>
            Get the collection configuration.
            </summary>
        </member>
        <member name="P:MindTouch.Data.MysqlDocStoreManager.Name">
            <summary>
            Get the collection name.
            </summary>
        </member>
        <member name="P:MindTouch.Data.MysqlDocStoreManager.Indicies">
            <summary>
            Get all Indicies defined for this indexer.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamServiceAttribute">
            <summary>
            Provides Dream Service meta-data for <see cref="T:MindTouch.Dream.IDreamService"/> implementations.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceAttribute.#ctor(System.String,System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="name">Dream Service name.</param>
            <param name="copyright">Copyright notice.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="name">Dream Service name.</param>
            <param name="copyright">Copyright notice.</param>
            <param name="info">Service information Uri.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceAttribute.GetSIDAsUris">
            <summary>
            Get all Service Identifiers as XUri array.
            </summary>
            <returns>Array of Service Identifiers.</returns>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceAttribute.Name">
            <summary>
            Dream Service name.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceAttribute.Copyright">
            <summary>
            Copyright notice.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceAttribute.Info">
            <summary>
            Service inforamtion Uri.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceAttribute.SID">
            <summary>
            Service Identifier Uris.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamServiceConfigAttribute">
            <summary>
            Provides meta data about expected service configuration key.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceConfigAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="name">Configuration Key.</param>
            <param name="type">Configuration Data Type.</param>
            <param name="description">Description of configuration value.</param>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceConfigAttribute.Name">
            <summary>
            Configuration key.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceConfigAttribute.ValueType">
            <summary>
            Configuration Data Type.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamServiceConfigAttribute.Description">
            <summary>
            Description of configuration value.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamServiceBlueprintAttribute">
            <summary>
            Provides addtional <see cref="T:MindTouch.Dream.IDreamService"/> blueprint meta-data.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamServiceBlueprintAttribute.Name">
            <summary>
            Name of meta-data key.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamServiceBlueprintAttribute.Value">
            <summary>
            Blueprint meta-data value.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceBlueprintAttribute.#ctor(System.String,System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="name">Name of meta-data key.</param>
            <param name="value">Blueprint meta-data value.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamServiceBlueprintAttribute.#ctor(System.String)">
            <summary>
            Create new attribute
            </summary>
            <param name="name">Name of meta-data key.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamFeatureAttribute">
            <summary>
            Marks a method as <see cref="T:MindTouch.Dream.DreamFeature"/> and provides feature meta-data.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamFeatureAttribute.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Obsolete: This form of the attribute construtor is deprecated. Please DreamFeatureAttribute(string,string) instead.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamFeatureAttribute.#ctor(System.String,System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="pattern">The Uri pattern that this feature responds to.</param>
            <param name="description">Description of the <see cref="T:MindTouch.Dream.DreamFeature"/>.</param>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureAttribute.Pattern">
            <summary>
            The Uri pattern that this feature responds to.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureAttribute.Description">
            <summary>
            Description of the <see cref="T:MindTouch.Dream.DreamFeature"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureAttribute.Info">
            <summary>
            Information Uri for this <see cref="T:MindTouch.Dream.DreamFeature"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureAttribute.Version">
            <summary>
            <see cref="T:MindTouch.Dream.DreamFeature"/> Version.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureAttribute.Obsolete">
            <summary>
            True if this feature is obsolete.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamFeatureParamAttribute">
            <summary>
            Defines a <see cref="T:MindTouch.Dream.DreamFeature"/> input parameter.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamFeatureParamAttribute.#ctor(System.String,System.String,System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="name">Name of the parameter.</param>
            <param name="type">Parameter Data Type.</param>
            <param name="description">Description of the parameter.</param>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureParamAttribute.Name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureParamAttribute.ValueType">
            <summary>
            Parameter Data Type.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureParamAttribute.Description">
            <summary>
            Description of the parameter.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamFeatureStatusAttribute">
            <summary>
            Provides <see cref="T:MindTouch.Dream.DreamFeature"/> meta-data about possible <see cref="T:MindTouch.Dream.DreamStatus"/> responses from feature.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamFeatureStatusAttribute.#ctor(MindTouch.Dream.DreamStatus,System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="status">Status message for Feature.</param>
            <param name="description">Description of scenario under which Status is returned.</param>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureStatusAttribute.Status">
            <summary>
            Status message for Feature.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeatureStatusAttribute.Description">
            <summary>
            Description of scenario under which Status is returned.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.HeaderAttribute">
            <summary>
            Defines a <see cref="T:MindTouch.Dream.DreamFeature"/> input header parameter.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.HeaderAttribute.#ctor">
            <summary>
            Create new attribute.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.HeaderAttribute.#ctor(System.String)">
            <summary>
            Create new attribute.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.HeaderAttribute.Name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.HeaderAttribute.Description">
            <summary>
            Description of the parameter.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.CookieAttribute">
            <summary>
            Defines a <see cref="T:MindTouch.Dream.DreamFeature"/> input cookie parameter.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.CookieAttribute.#ctor">
            <summary>
            Create new attribute.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.CookieAttribute.#ctor(System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="description">Description of the parameter.</param>
        </member>
        <member name="P:MindTouch.Dream.CookieAttribute.Name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.CookieAttribute.Description">
            <summary>
            Description of the parameter.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.PathAttribute">
            <summary>
            Defines a <see cref="T:MindTouch.Dream.DreamFeature"/> input path parameter.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.PathAttribute.#ctor">
            <summary>
            Create new attribute.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.PathAttribute.#ctor(System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="description">Description of the parameter.</param>
        </member>
        <member name="P:MindTouch.Dream.PathAttribute.Name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.PathAttribute.Description">
            <summary>
            Description of the parameter.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.QueryAttribute">
            <summary>
            Defines a <see cref="T:MindTouch.Dream.DreamFeature"/> input query parameter.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.QueryAttribute.#ctor">
            <summary>
            Create new attribute.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.QueryAttribute.#ctor(System.String)">
            <summary>
            Create new attribute.
            </summary>
            <param name="description">Description of the parameter.</param>
        </member>
        <member name="P:MindTouch.Dream.QueryAttribute.Name">
            <summary>
            Name of the parameter.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.QueryAttribute.Description">
            <summary>
            Description of the parameter.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.PlugEx">
            <summary>
            Provides extension methods for <see cref="T:MindTouch.Dream.Plug"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.PlugEx.Get(MindTouch.Dream.Plug,MindTouch.Tasking.Result{MindTouch.Xml.XDoc})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.GET"/> verb and no message body and return as a document result.
            </summary>
            <remarks>
            Since this method goes straight from a <see cref="T:MindTouch.Dream.DreamMessage"/> to a document, this method will set a
            <see cref="T:MindTouch.Dream.DreamResponseException"/> on the result, if <see cref="P:MindTouch.Dream.DreamMessage.IsSuccessful"/> is <see langword="False"/>.
            </remarks>
            <param name="plug">Plug instance to invoke.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="T:System.DebugUtil">
            <summary>
            Static utility class containing extension and helper methods for Debug instrumentation.
            </summary>
        </member>
        <member name="F:System.DebugUtil.CaptureStackTrace">
            <summary>
            Global flag to signal whether stack traces should be captured.
            </summary>
        </member>
        <member name="M:System.DebugUtil.SetCollectionInterval(System.TimeSpan)">
            <summary>
            Set an interval at which Garbage collection should be forced.
            </summary>
            <param name="t">Interval length.</param>
        </member>
        <member name="M:System.DebugUtil.GetStackTrace">
            <summary>
            Get the current StackTrace.
            </summary>
            <returns>Currently applicable StackTrace.</returns>
        </member>
        <member name="M:System.DebugUtil.Stopwatch(System.Action)">
            <summary>
            Wrap a stopwatch aroudn the execution of an action.
            </summary>
            <param name="handler">The action to be timed.</param>
            <returns>Time elapsed during the handler's execution.</returns>
        </member>
        <member name="T:System.Empty">
            <summary>
            Represents a static instance without a value.
            </summary>
        </member>
        <member name="F:System.Empty.Value">
            <summary>
            Default instance.
            </summary>
        </member>
        <member name="T:System.SysUtil">
            <summary>
            Static utility class containing base Class library level extension and helper methods as well as System properties.
            </summary>
        </member>
        <member name="F:System.SysUtil.NameTable">
            <summary>
            Global-use XmlNameTable
            </summary>
        </member>
        <member name="F:System.SysUtil.UseAsyncIO">
            <summary>
            Global switch for determining whether Async I/O should be used when calling Asychronous Method Pattern I/O methods.
            </summary>
            <remarks>
            The value of this field is set by the "async-io" configuration key, if present.
            Mono does not implement asychronous I/O, instead creating blocking threads in the default .NET threadpool for performaing "async" work.
            By default, if the configuration key is not set and <see cref="P:System.SysUtil.IsMono"/> is defined, <see cref="F:System.SysUtil.UseAsyncIO"/> is set to <see langword="False"/>,
            otherwise it is <see langword="True"/>.
            </remarks>
        </member>
        <member name="M:System.SysUtil.IsA``1(System.Object)">
            <summary>
            Checks if an object is of a given type or interface.
            </summary>
            <typeparam name="T">Type or interface to check.</typeparam>
            <param name="instance">Object to check.</param>
            <returns><see langword="True"/> if the object implements the interface or derives from type.</returns>
        </member>
        <member name="M:System.SysUtil.IsA``1(System.Type)">
            <summary>
            Checks if the type is of a given type or interface.
            </summary>
            <typeparam name="T">Type or interface to check.</typeparam>
            <param name="type">Type to check.</param>
            <returns><see langword="True"/> if the Type implements the interface or derives from type.</returns>
        </member>
        <member name="M:System.SysUtil.Rethrow(System.Exception)">
            <summary>
            Rethrow an existing exception.
            </summary>
            <remarks>
            Rethrow claims to return an exception so that it can be used as the argument to <see langword="throw"/> in a <see langword="try"/> block.
            This usage allows the compiler to see that the code cannot return from the block calling Rethrow, which is otherwise not discoverable.
            </remarks>
            <param name="exception">Exception to rethrow.</param>
            <returns>This method will never return an exception, since it always throws internally.</returns>
        </member>
        <member name="M:System.SysUtil.ChangeType(System.Object,System.Type)">
            <summary>
            Wrapper on top of <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/> to add handling of MindTouch Dream base types.
            </summary>
            <param name="value">Value to convert.</param>
            <param name="type">Type to convert value into.</param>
            <returns>Value converted to type, if possible.</returns>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:System.SysUtil.ChangeType``1(System.Object)">
            <summary>
            Generic version of <see cref="M:System.SysUtil.ChangeType(System.Object,System.Type)"/> to allow type change without having to cast the output to the desired type.
            </summary>
            <typeparam name="T">Type to convert the value into.</typeparam>
            <param name="value">Value to convert.</param>
            <returns>Converted value, if possible.</returns>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:System.SysUtil.CAS``1(``0@,``0,``0)">
            <summary>
            Excecute an atomic compare and exchange operation and determine whether it succeeded or not.
            </summary>
            <typeparam name="T">Type of value do perform compare and exchange on. Must be a class.</typeparam>
            <param name="location">The reference location of the value to be changed.</param>
            <param name="oldValue">The current value to expect for the swap to succeed.</param>
            <param name="newValue">The new value to swap into place, as long as location is still equal to the old value.</param>
            <returns><see langword="True"/>If the operation successfully replaced old value with new value.</returns>
        </member>
        <member name="M:System.SysUtil.TryParseEnum``1(System.String,``0@)">
            <summary>
            Try to parse a case-insensitive string into an enum value.
            </summary>
            <typeparam name="T">Enum type to convert into.</typeparam>
            <param name="text">Text value to parse.</param>
            <param name="value">Parsed enum value.</param>
            <returns><see langword="True"/> if an enum value could be parsed.</returns>
        </member>
        <member name="M:System.SysUtil.TryParseEnum``1(System.String)">
            <summary>
            Try to parse a case-insensitive string into an enum value.
            </summary>
            <typeparam name="T">Enum type to convert into.</typeparam>
            <param name="text">Text value to parse.</param>
            <returns>Parsed enum value or null.</returns>
        </member>
        <member name="M:System.SysUtil.ParseEnum``1(System.String)">
            <summary>
            Parse a case-insensitive string into an enum value.
            </summary>
            <typeparam name="T">Enum type to convert into.</typeparam>
            <param name="text">Text value to parse.</param>
            <returns>Parsed enum value.</returns>
        </member>
        <member name="P:System.SysUtil.IsMono">
            <summary>
            <see langword="True"/> if the program is running under the Mono runtime.
            </summary>
        </member>
        <member name="P:System.SysUtil.IsUnix">
            <summary>
            <see langword="True"/> if the program is running on a Unix platform.
            </summary>
        </member>
        <member name="T:MindTouch.Text.BOMEncodingDetector">
            <summary>
            Text encoding detector implementation checking for a stream byte-order marker (BOM).
            </summary>
        </member>
        <member name="T:MindTouch.Text.IEncodingDetector">
            <summary>
            Text encoding detector
            </summary>
        </member>
        <member name="M:MindTouch.Text.IEncodingDetector.Detect(System.IO.Stream)">
            <summary>
            Detect the encoding for a given stream.
            </summary>
            <param name="stream">Stream to examine</param>
            <returns>Detected encoding or null.</returns>
        </member>
        <member name="M:MindTouch.Text.BOMEncodingDetector.Detect(System.IO.Stream)">
            <summary>
            Detect the encoding for a given stream.
            </summary>
            <param name="stream">Stream to examine</param>
            <returns>Detected encoding or null.</returns>
        </member>
        <member name="T:MindTouch.Text.CharacterEncodingDetector">
            <summary>
            Text encoding detector using stream sampling to detect character encoding.
            </summary>
        </member>
        <member name="M:MindTouch.Text.CharacterEncodingDetector.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Text.CharacterEncodingDetector.#ctor(System.Int32)">
            <summary>
            Create a new instance.
            </summary>
            <param name="maxSampleSize">Maximum number of bytes to examine.</param>
        </member>
        <member name="M:MindTouch.Text.CharacterEncodingDetector.Detect(System.IO.Stream)">
            <summary>
            Detect the encoding for a given stream.
            </summary>
            <param name="stream">Stream to examine</param>
            <returns>Detected encoding or null.</returns>
        </member>
        <member name="T:MindTouch.Threading.DispatchQueueEx">
            <summary>
            Provides extension methods to <see cref="T:MindTouch.Threading.IDispatchQueue"/> to simplify enqueuing of work to be invoked in a specific <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithCurrentEnv(MindTouch.Threading.IDispatchQueue,System.Action)">
            <summary>
            Enqueue a callback as a work item to be invoked with the current <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithClonedEnv(MindTouch.Threading.IDispatchQueue,System.Action)">
            <summary>
            Enqueue a callback as a work item to be invoked with a clone of the current <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithEnv(MindTouch.Threading.IDispatchQueue,System.Action,MindTouch.Tasking.TaskEnv)">
            <summary>
            Enqueue a callback as a work item to be invoked with a provided <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
            <param name="env">Environment for work item invocation.</param>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithCurrentEnv(MindTouch.Threading.IDispatchQueue,System.Action,MindTouch.Tasking.Result)">
            <summary>
            Enqueue a callback as a work item to be invoked with the current <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
            <param name="result">Synchronization handle for work item.</param>
            <returns>The synchronization handle provided to the method.</returns>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithClonedEnv(MindTouch.Threading.IDispatchQueue,System.Action,MindTouch.Tasking.Result)">
            <summary>
            Enqueue a callback as a work item to be invoked with a clone of the current <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
            <param name="result">Synchronization handle for work item.</param>
            <returns>The synchronization handle provided to the method.</returns>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithEnv(MindTouch.Threading.IDispatchQueue,System.Action,MindTouch.Tasking.TaskEnv,MindTouch.Tasking.Result)">
            <summary>
            Enqueue a callback as a work item to be invoked with a provided <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
            <param name="env">Environment for work item invocation.</param>
            <param name="result">Synchronization handle for work item.</param>
            <returns>The synchronization handle provided to the method.</returns>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithCurrentEnv``1(MindTouch.Threading.IDispatchQueue,System.Func{``0})">
            <summary>
            Enqueue a callback as a work item to be invoked with the current <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <typeparam name="T">Result value type of callback.</typeparam>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithClonedEnv``1(MindTouch.Threading.IDispatchQueue,System.Func{``0})">
            <summary>
            Enqueue a callback as a work item to be invoked with a clone of the current <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <typeparam name="T">Result value type of callback.</typeparam>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithEnv``1(MindTouch.Threading.IDispatchQueue,System.Func{``0},MindTouch.Tasking.TaskEnv)">
            <summary>
            Enqueue a callback as a work item to be invoked with a provided <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <typeparam name="T">Result value type of callback.</typeparam>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
            <param name="env">Environment for work item invocation.</param>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithCurrentEnv``1(MindTouch.Threading.IDispatchQueue,System.Func{``0},MindTouch.Tasking.Result{``0})">
            <summary>
            Enqueue a callback as a work item to be invoked with the current <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <typeparam name="T">Result value type of callback.</typeparam>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
            <param name="result">Synchronization handle for work item.</param>
            <returns>The synchronization handle provided to the method.</returns>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithClonedEnv``1(MindTouch.Threading.IDispatchQueue,System.Func{``0},MindTouch.Tasking.Result{``0})">
            <summary>
            Enqueue a callback as a work item to be invoked with a clone of the current <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <typeparam name="T">Result value type of callback.</typeparam>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
            <param name="result">Synchronization handle for work item.</param>
            <returns>The synchronization handle provided to the method.</returns>
        </member>
        <member name="M:MindTouch.Threading.DispatchQueueEx.QueueWorkItemWithEnv``1(MindTouch.Threading.IDispatchQueue,System.Func{``0},MindTouch.Tasking.TaskEnv,MindTouch.Tasking.Result{``0})">
            <summary>
            Enqueue a callback as a work item to be invoked with a provided <see cref="T:MindTouch.Tasking.TaskEnv"/>.
            </summary>
            <typeparam name="T">Result value type of callback.</typeparam>
            <param name="dispatchQueue">DispatchQueue to enqueue work into.</param>
            <param name="callback">Work item callback.</param>
            <param name="env">Environment for work item invocation.</param>
            <param name="result">Synchronization handle for work item.</param>
            <returns>The synchronization handle provided to the method.</returns>
        </member>
        <member name="T:MindTouch.Threading.DispatchWorkItem">
            <summary>
            Value wrapper for work-itenms issued returned by <see cref="T:MindTouch.Threading.IDispatchHost"/>.
            </summary>
        </member>
        <member name="F:MindTouch.Threading.DispatchWorkItem.WorkItem">
            <summary>
            Work-item callback.
            </summary>
        </member>
        <member name="F:MindTouch.Threading.DispatchWorkItem.DispatchQueue">
            <summary>
            Dispatch queue associated with work-item.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.DispatchWorkItem.#ctor(System.Action,MindTouch.Threading.IDispatchQueue)">
            <summary>
            Create new work-item instance.
            </summary>
            <param name="workitem">Work-item callback.</param>
            <param name="queue">Dispatch queue associated with work-item.</param>
        </member>
        <member name="T:MindTouch.Threading.MonitorSemaphore">
            <summary>
            Provides a syncrhonization class based on <see cref="T:System.Threading.Monitor"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.MonitorSemaphore.#ctor">
            <summary>
            Create a new Monitor semaphore.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.MonitorSemaphore.#ctor(System.Int32)">
            <summary>
            Create a new monitor semaphore with a set number of watchers.
            </summary>
            <param name="initial"></param>
        </member>
        <member name="M:MindTouch.Threading.MonitorSemaphore.Signal">
            <summary>
            Signals a waiting thread and unlocks it.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.MonitorSemaphore.Wait(System.TimeSpan)">
            <summary>
            Blocks current thread until signaled.
            </summary>
            <param name="timeout"></param>
        </member>
        <member name="T:MindTouch.Threading.ReaderWriterLockSlimEx">
            <summary>
            Provides extension methods to invoke lambdas in the context of a <see cref="T:System.Threading.ReaderWriterLockSlim"/> instance.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.ReaderWriterLockSlimEx.ExecuteWithUpgradeableReadLock``1(System.Threading.ReaderWriterLockSlim,System.Func{``0})">
            <summary>
            Wrap's a lambda with an upgradeable read lock
            </summary>
            <typeparam name="T">Return Type of the lambda executed in the lock context.</typeparam>
            <param name="lockSlim">The lock to use for the lambda exectuion.</param>
            <param name="func">Lambda function to execute.</param>
            <returns>Return value of the lambda executed in the lock's context.</returns>
        </member>
        <member name="M:MindTouch.Threading.ReaderWriterLockSlimEx.ExecuteWithUpgradeableReadLock(System.Threading.ReaderWriterLockSlim,System.Action)">
            <summary>
            Wrap's a lambda with an upgradeable lock
            </summary>
            <param name="lockSlim">The lock to use for the lambda exectuion.</param>
            <param name="action">Lambda action to execute.</param>
        </member>
        <member name="M:MindTouch.Threading.ReaderWriterLockSlimEx.ExecuteWithReadLock``1(System.Threading.ReaderWriterLockSlim,System.Func{``0})">
            <summary>
            Wrap's a lambda with a read lock
            </summary>
            <typeparam name="T">Return Type of the lambda executed in the lock context.</typeparam>
            <param name="lockSlim">The lock to use for the lambda exectuion.</param>
            <param name="func">Lambda function to execute.</param>
            <returns>Return value of the lambda executed in the lock's context.</returns>
        </member>
        <member name="M:MindTouch.Threading.ReaderWriterLockSlimEx.ExecuteWithReadLock(System.Threading.ReaderWriterLockSlim,System.Action)">
            <summary>
            Wrap's a lambda with a read lock
            </summary>
            <param name="lockSlim">The lock to use for the lambda exectuion.</param>
            <param name="action">Lambda action to execute.</param>
        </member>
        <member name="M:MindTouch.Threading.ReaderWriterLockSlimEx.ExecuteWithWriteLock``1(System.Threading.ReaderWriterLockSlim,System.Func{``0})">
            <summary>
            Wrap's a lambda with a write lock
            </summary>
            <typeparam name="T">Return Type of the lambda executed in the lock context.</typeparam>
            <param name="lockSlim">The lock to use for the lambda exectuion.</param>
            <param name="func">Lambda function to execute.</param>
            <returns>Return value of the lambda executed in the lock's context.</returns>
        </member>
        <member name="M:MindTouch.Threading.ReaderWriterLockSlimEx.ExecuteWithWriteLock(System.Threading.ReaderWriterLockSlim,System.Action)">
            <summary>
            Wrap's a lambda with a write lock
            </summary>
            <param name="lockSlim">The lock to use for the lambda exectuion.</param>
            <param name="action">Lambda action to execute.</param>
        </member>
        <member name="T:MindTouch.Extensions.Time.TimeEx">
            <summary>
            Provides extension methods relating to <see cref="T:System.TimeSpan"/> and <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Hours(System.Int32)">
            <summary>
            Get a timespan of the hours specified.
            </summary>
            <param name="hours">Number of hours.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Hours(System.UInt32)">
            <summary>
            Get a timespan of the hours specified.
            </summary>
            <param name="hours">Number of hours.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Hours(System.Int64)">
            <summary>
            Get a timespan of the hours specified.
            </summary>
            <param name="hours">Number of hours.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Hours(System.UInt64)">
            <summary>
            Get a timespan of the hours specified.
            </summary>
            <param name="hours">Number of hours.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Hours(System.Double)">
            <summary>
            Get a timespan of the hours specified.
            </summary>
            <param name="hours">Number of hours.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Minutes(System.Int32)">
            <summary>
            Get a timespan of the minutes specified.
            </summary>
            <param name="minutes">Number of minutes.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Minutes(System.UInt32)">
            <summary>
            Get a timespan of the minutes specified.
            </summary>
            <param name="minutes">Number of minutes.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Minutes(System.Int64)">
            <summary>
            Get a timespan of the minutes specified.
            </summary>
            <param name="minutes">Number of minutes.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Minutes(System.UInt64)">
            <summary>
            Get a timespan of the minutes specified.
            </summary>
            <param name="minutes">Number of minutes.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Minutes(System.Double)">
            <summary>
            Get a timespan of the minutes specified.
            </summary>
            <param name="minutes">Number of minutes.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Seconds(System.Int32)">
            <summary>
            Get a timespan of the seconds specified.
            </summary>
            <param name="seconds">Number of seconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Seconds(System.UInt32)">
            <summary>
            Get a timespan of the seconds specified.
            </summary>
            <param name="seconds">Number of seconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Seconds(System.Int64)">
            <summary>
            Get a timespan of the seconds specified.
            </summary>
            <param name="seconds">Number of seconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Seconds(System.UInt64)">
            <summary>
            Get a timespan of the seconds specified.
            </summary>
            <param name="seconds">Number of seconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Seconds(System.Double)">
            <summary>
            Get a timespan of the seconds specified.
            </summary>
            <param name="seconds">Number of seconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Milliseconds(System.Int32)">
            <summary>
            Get a timespan of the milliseconds specified.
            </summary>
            <param name="milliseconds">Number of milliseconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Milliseconds(System.UInt32)">
            <summary>
            Get a timespan of the milliseconds specified.
            </summary>
            <param name="milliseconds">Number of milliseconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Milliseconds(System.Int64)">
            <summary>
            Get a timespan of the milliseconds specified.
            </summary>
            <param name="milliseconds">Number of milliseconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Milliseconds(System.UInt64)">
            <summary>
            Get a timespan of the milliseconds specified.
            </summary>
            <param name="milliseconds">Number of milliseconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Milliseconds(System.Double)">
            <summary>
            Get a timespan of the milliseconds specified.
            </summary>
            <param name="milliseconds">Number of milliseconds.</param>
            <returns>A TimeSpan instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Epoch(System.Int32)">
            <summary>
            Get a DateTime instance from utc-based unix epoch time.
            </summary>
            <param name="secondsSinceEpoch">Seconds since January 1, 1970 (UTC).</param>
            <returns>DateTime instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Epoch(System.UInt32)">
            <summary>
            Get a DateTime instance from utc-based unix epoch time.
            </summary>
            <param name="secondsSinceEpoch">Seconds since January 1, 1970 (UTC).</param>
            <returns>DateTime instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Epoch(System.Int64)">
            <summary>
            Get a DateTime instance from utc-based unix epoch time.
            </summary>
            <param name="secondsSinceEpoch">Seconds since January 1, 1970 (UTC).</param>
            <returns>DateTime instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Epoch(System.UInt64)">
            <summary>
            Get a DateTime instance from utc-based unix epoch time.
            </summary>
            <param name="secondsSinceEpoch">Seconds since January 1, 1970 (UTC).</param>
            <returns>DateTime instance.</returns>
        </member>
        <member name="M:MindTouch.Extensions.Time.TimeEx.Epoch(System.Double)">
            <summary>
            Get a DateTime instance from utc-based unix epoch time.
            </summary>
            <param name="secondsSinceEpoch">Seconds since January 1, 1970 (UTC).</param>
            <returns>DateTime instance.</returns>
        </member>
        <member name="T:MindTouch.Web.DreamCookieJar">
            <summary>
            Provides a hierarchical <see cref="T:MindTouch.Web.DreamCookie"/> container.
            </summary>
        </member>
        <member name="M:MindTouch.Web.DreamCookieJar.Clear">
            <summary>
            Clear all cookies from the jar.
            </summary>
        </member>
        <member name="M:MindTouch.Web.DreamCookieJar.Update(MindTouch.Web.DreamCookie,MindTouch.Dream.XUri)">
            <summary>
            Update the jar with a cookie.
            </summary>
            <param name="cookie">Cookie to store.</param>
            <param name="uri">Uri this cookie applies to.</param>
        </member>
        <member name="M:MindTouch.Web.DreamCookieJar.Update(System.Collections.Generic.List{MindTouch.Web.DreamCookie},MindTouch.Dream.XUri)">
            <summary>
            Update the jar with a collection cookies.
            </summary>
            <param name="collection">List of cookies to store.</param>
            <param name="uri">Uri cookies apply to.</param>
        </member>
        <member name="M:MindTouch.Web.DreamCookieJar.Fetch(MindTouch.Dream.XUri)">
            <summary>
            Retrieve all cookies that apply to a Uri.
            </summary>
            <param name="uri">Uri to match.</param>
            <returns>List of cookies.</returns>
        </member>
        <member name="P:MindTouch.Web.DreamCookieJar.Count">
            <summary>
            Total cookies in the jar.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookieJar.IsEmpty">
            <summary>
            <see langword="True"/> if there are no cookies in the jar.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamContext">
            <summary>
            Provides request context information for <see cref="T:MindTouch.Dream.DreamFeature"/> request processing.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.ITaskLifespan">
            <summary>
            Interface for marking objects whose lifespan is governed by a single <see cref="T:MindTouch.Tasking.TaskEnv"/>
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.ITaskLifespan.Clone">
            <summary>
            Appropriately duplicate the instance for attachment to another <see cref="T:MindTouch.Tasking.TaskEnv"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Tasking.ITaskLifespan.Dispose">
            <summary>
            Clean-up the instance at the conclusion of the owning <see cref="T:MindTouch.Tasking.TaskEnv"/>
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContext.Env">
            <summary>
            Dream environment.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContext.ID">
            <summary>
            Unique Identifier of the request.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContext.Verb">
            <summary>
            Request Http Verb.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContext.Uri">
            <summary>
            Request Uri.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContext.Feature">
            <summary>
            Dream feature responsible for handling the request.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContext.Request">
            <summary>
            Incoming request message.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContext.StartTime">
            <summary>
            Time the request started.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamContext.CacheKeyAndTimeout">
            <summary>
            Caching information for request.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.#ctor(MindTouch.Dream.IDreamEnvironment,System.String,MindTouch.Dream.XUri,MindTouch.Dream.DreamFeature,MindTouch.Dream.XUri,MindTouch.Dream.XUri,MindTouch.Dream.DreamMessage,System.Globalization.CultureInfo,System.Func{Autofac.IContainer})">
            <summary>
            Create instance.
            </summary>
            <param name="env">Dream Environment.</param>
            <param name="verb">Http request verb.</param>
            <param name="uri">Request Uri.</param>
            <param name="feature">Request handling feature.</param>
            <param name="publicUri">Public Uri for incoming request.</param>
            <param name="serverUri">Server Uri for Dream Host.</param>
            <param name="request">Request message.</param>
            <param name="culture">Request Culture.</param>
            <param name="requestContainerFactory">Factory delegate to create a request container on demand.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.AttachToCurrentTaskEnv">
            <summary>
            Attach the context to the current context.
            </summary>
            <remarks>
            Throws <see cref="T:MindTouch.Dream.DreamContextAccessException"/> if the context is already attached to
            a task environemnt of the task environment already has a context.
            </remarks>
            <exception cref="T:MindTouch.Dream.DreamContextAccessException">Context is either attached to a <see cref="T:MindTouch.Tasking.TaskEnv"/> or the current <see cref="T:MindTouch.Tasking.TaskEnv"/>
            already has a context attached.</exception>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.DetachFromTaskEnv">
            <summary>
            Detach the context from the its task environment.
            </summary>
            <remarks>
            Must be done in the context's task environment.
            </remarks>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.SetPublicUriOverride(MindTouch.Dream.XUri)">
            <summary>
            Override the <see cref="P:MindTouch.Dream.DreamContext.PublicUri"/> for this request.
            </summary>
            <param name="publicUri">Publicly accessible Uri.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.ClearPublicUriOverride">
            <summary>
            Remove any <see cref="P:MindTouch.Dream.DreamContext.PublicUri"/> override.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetSuffixCount">
            <summary>
            Number of suffixes for this feature path.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetSuffix(System.Int32,MindTouch.Dream.UriPathFormat)">
            <summary>
            Get a suffix.
            </summary>
            <param name="index">Index of path suffix.</param>
            <param name="format">Uri path format.</param>
            <returns>Suffix.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetSuffixes(MindTouch.Dream.UriPathFormat)">
            <summary>
            Get all suffixes.
            </summary>
            <param name="format">Uri path format for suffixes.</param>
            <returns>Array of suffixes.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetParams">
            <summary>
            Request parameters.
            </summary>
            <remarks>
            Parameters refers to both query and path parameters.
            </remarks>
            <returns>Array parameter key/value pairs.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetParams(System.String)">
            <summary>
            Get all values for a named parameter.
            </summary>
            <param name="key"><see cref="T:MindTouch.Dream.DreamFeatureParamAttribute"/> name.</param>
            <returns>Text values of parameter.</returns>
            <exception cref="T:MindTouch.Dream.DreamAbortException">Throws if parameter does not exist.</exception>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetParam(System.String)">
            <summary>
            Get a named parameter.
            </summary>
            <remarks>
            Will throw <see cref="T:MindTouch.Dream.DreamAbortException"/> if the named parameter does not exist.
            </remarks>
            <param name="key"><see cref="T:MindTouch.Dream.DreamFeatureParamAttribute"/> name.</param>
            <returns>Text value of parameter.</returns>
            <exception cref="T:MindTouch.Dream.DreamAbortException">Throws if parameter does not exist.</exception>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetParam``1(System.String)">
            <summary>
            Get a named parameter.
            </summary>
            <typeparam name="T">Type to convert parameter to.</typeparam>
            <param name="key"><see cref="T:MindTouch.Dream.DreamFeatureParamAttribute"/> name.</param>
            <returns>Parameter value converted to requested type.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetParam(System.String,System.String)">
            <summary>
            Get a named parameter.
            </summary>
            <param name="key"><see cref="T:MindTouch.Dream.DreamFeatureParamAttribute"/> name.</param>
            <param name="def">Default value to return in case parameter is not defined.</param>
            <returns>Text value of parameter</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetParam``1(System.String,``0)">
            <summary>
            Get a named parameter.
            </summary>
            <typeparam name="T">Type to convert parameter to.</typeparam>
            <param name="key"><see cref="T:MindTouch.Dream.DreamFeatureParamAttribute"/> name.</param>
            <param name="def">Default value to return in case parameter is not defined.</param>
            <returns>Parameter value converted to requested type.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.Relay(MindTouch.Dream.Plug,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Relay a request to another service using the current query parameters, service cookies and verb.
            </summary>
            <remarks>
            Must be yielded by a coroutine or invoked with <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/>.
            </remarks>
            <param name="plug">Location of relay recipient.</param>
            <param name="request">Request message to relay.</param>
            <param name="response">The <see cref="T:MindTouch.Tasking.Result`1"/> instance this coroutine will use as a synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> execution environment.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.Relay(MindTouch.Dream.Plug,System.String,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Relay a request to another service using the current query parameters and service cookies.
            </summary>
            <remarks>
            Must be yielded by a coroutine or invoked with <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/>.
            </remarks>
            <param name="plug">Location of relay recipient.</param>
            <param name="verb">Http verb to use for relay.</param>
            <param name="request">Request message to relay.</param>
            <param name="response">The <see cref="T:MindTouch.Tasking.Result`1"/> instance this coroutine will use as a synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> execution environment.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetState``1">
            <summary>
            Get a typed state variable
            </summary>
            <remarks>Since the type is used as the state key, can only contain one instance for this type. This call is thread-safe.</remarks>
            <typeparam name="T">Type of state variable.</typeparam>
            <returns>Instance or default for type.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.SetState``1(``0)">
            <summary>
            Store a typed state variable.
            </summary>
            <remarks>Since the type is used as the state key, can only contain one instance for this type. This call is thread-safe.</remarks>
            <typeparam name="T">Type of state variable.</typeparam>
            <param name="value">Instance to store.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.GetState``1(System.String)">
            <summary>
            Get a typed state variable by key.
            </summary>
            <remarks>This call is thread-safe.</remarks>
            <typeparam name="T">Type of state variable.</typeparam>
            <param name="key">State variable key.</param>
            <returns>Instance or default for type.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.SetState``1(System.String,``0)">
            <summary>
            Store a typed state variable by key.
            </summary>
            <remarks>This call is thread-safe.</remarks>
            <typeparam name="T">Type of state variable.</typeparam>
            <param name="key">State variable key.</param>
            <param name="value">Instance to store.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.AsLocalUri(MindTouch.Dream.XUri)">
            <summary>
            Convert a Uri to a host local Uri, if possible.
            </summary>
            <remarks>
            Will return the original Uri if there is no local equivalent.
            </remarks>
            <param name="uri">Uri to convert.</param>
            <returns>Local Uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.AsPublicUri(MindTouch.Dream.XUri)">
            <summary>
            Convert a Uri to uri relative to the requests public uri, if possible.
            </summary>
            <remarks>
            Will return the original Uri if there is no public equivalent.
            </remarks>
            <param name="uri">Uri to convert.</param>
            <returns>Public Uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.AsServerUri(MindTouch.Dream.XUri)">
            <summary>
            Convert a Uri to uri relative to the server's public uri, if possible.
            </summary>
            <remarks>
            Will return the original Uri if there is no public equivalent.
            </remarks>
            <param name="uri">Uri to convert.</param>
            <returns>Public Uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamContext.CloneStateFromContext(MindTouch.Dream.DreamContext)">
            <summary>
            Replace the context's own state with a clone of the state of another context.
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.Current">
            <summary>
            Singleton accessor for the current request context.
            </summary>
            <remarks> Will throw an <see cref="T:MindTouch.Dream.DreamContextAccessException"/> if there is no context defined.</remarks>
            <exception cref="T:MindTouch.Dream.DreamContextAccessException">Thrown if no context is defined in the current environment or the context has been disposed.</exception>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.CurrentOrNull">
            <summary>
            Singleton accessor to current request context or <see langword="null"/>, if none is defined.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.Service">
            <summary>
            Dream Service handling the request.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.HasState">
            <summary>
            <see langword="True"/> if the context has state attached to it.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.ServiceLicense">
            <summary>
            Service license for this request.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.IsTaskEnvDisposed">
            <summary>
            <see langword="True"/> if the underlying Task environment has disposed this context.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.PublicUri">
            <summary>
            Uri by which the host is known publicly in the context of this request.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.Culture">
            <summary>
            Culture of the request.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.ServerUri">
            <summary>
            Uri the Dream Host is registered for.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.User">
            <summary>
            User, if any, authenticated for this request.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.Container">
            <summary>
            Request Inversion of Control container.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamContext.State">
            <summary>
            Request State.
            </summary>
        </member>
        <member name="T:MindTouch.Web.DreamCookie">
            <summary>
            Provides encapsulation for an Http cookie.
            </summary>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.GetCookie(System.Collections.Generic.List{MindTouch.Web.DreamCookie},System.String)">
            <summary>
            Gets the matching cookie with the longest path from a collection of cookies.
            </summary>
            <param name="cookies">Collection of cookies.</param>
            <param name="name">Cookie name.</param>
            <returns>Matching cookie with longest path, or null if no cookies matched.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ParseCookieHeader(System.String)">
            <summary>
            Create a cookie collection from a cookie header.
            </summary>
            <param name="header">Http cookie header.</param>
            <returns>Cookie collection.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ParseSetCookieHeader(System.String)">
            <summary>
            Parse a collection cookies from a set cookie header.
            </summary>
            <param name="setCookieHeader">Http set cookie header.</param>
            <returns>Collection of cookies.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ParseAllSetCookieNodes(System.Collections.Generic.IEnumerable{MindTouch.Xml.XDoc})">
            <summary>
            Parse a collection of cookies from enumerable of xml serialized set cookies.
            </summary>
            <remarks>
            Since <see cref="T:MindTouch.Xml.XDoc"/> implements <see cref="T:System.Collections.Generic.IEnumerable`1"/>, the input to this method can be a single XDoc instance or the result
            of an Xpath query, in addition to a collection of <see cref="T:MindTouch.Xml.XDoc"/> instances.
            </remarks>
            <param name="setCookieElements">Enumerable of XDocs</param>
            <returns>Cookie collection.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ParseSetCookie(MindTouch.Xml.XDoc)">
            <summary>
            Parse a single cookie from a xml serialized cookie.
            </summary>
            <param name="cookie">Xml serialized cookie.</param>
            <returns>New cookie instance.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ParseAllCookieNodes(System.Collections.Generic.IEnumerable{MindTouch.Xml.XDoc})">
            <summary>
            Parse all cookies from an enumerable of xml serialized cookies.
            </summary>
            <remarks>
            Since <see cref="T:MindTouch.Xml.XDoc"/> implements <see cref="T:System.Collections.Generic.IEnumerable`1"/>, the input to this method can be a single XDoc instance or the result
            of an Xpath query, in addition to a collection of <see cref="T:MindTouch.Xml.XDoc"/> instances.
            </remarks>
            <param name="cookieElements">Enumerable of XDocs</param>
            <returns>Collection of cookies.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ParseCookie(MindTouch.Xml.XDoc)">
            <summary>
            Parse a single cookie from a xml serialized cookie.
            </summary>
            <param name="cookie">Xml serialized cookie.</param>
            <returns>New cookie instance.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.RenderCookieHeader(System.Collections.Generic.List{MindTouch.Web.DreamCookie})">
            <summary>
            Render a collection of cookies into a cookie header.
            </summary>
            <param name="cookies">Collection of cookies.</param>
            <returns>Http cookie header.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.NewSetCookie(System.String,System.String,MindTouch.Dream.XUri)">
            <summary>
            Create a new set cookie.
            </summary>
            <param name="name">Cookie name.</param>
            <param name="value">Cookie value.</param>
            <param name="uri">Cookie Uri.</param>
            <returns>New cookie instance.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.NewSetCookie(System.String,System.String,MindTouch.Dream.XUri,System.DateTime)">
            <summary>
            Create a new set cookie.
            </summary>
            <param name="name">Cookie name.</param>
            <param name="value">Cookie value.</param>
            <param name="uri">Cookie Uri.</param>
            <param name="expires">Cookie expiration.</param>
            <returns>New cookie instance.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.NewSetCookie(System.String,System.String,MindTouch.Dream.XUri,System.DateTime,System.Boolean,System.String,MindTouch.Dream.XUri)">
            <summary>
            Create a new set cookie.
            </summary>
            <param name="name">Cookie name.</param>
            <param name="value">Cookie value.</param>
            <param name="uri">Cookie Uri.</param>
            <param name="expires">Cookie expiration.</param>
            <param name="secure"><see langword="True"/> if the cookie should only be used on https requests.</param>
            <param name="comment">Comment.</param>
            <param name="commentUri">Uri for comment.</param>
            <returns>New cookie instance.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.NewSetCookie(System.String,System.String,MindTouch.Dream.XUri,System.DateTime,System.Boolean,System.String,MindTouch.Dream.XUri,System.Boolean)">
            <summary>
            Create a new set cookie.
            </summary>
            <param name="name">Cookie name.</param>
            <param name="value">Cookie value.</param>
            <param name="uri">Cookie Uri.</param>
            <param name="expires">Cookie expiration.</param>
            <param name="secure"><see langword="True"/> if the cookie should only be used on https requests.</param>
            <param name="comment">Comment.</param>
            <param name="commentUri">Uri for comment.</param>
            <param name="httpOnly"><see langword="True"/> if cookie is only accessible to the http transport, i.e. not client side scripts.</param>
            <returns>New cookie instance.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ConvertToPublic(System.Collections.Generic.List{MindTouch.Web.DreamCookie})">
            <summary>
            Convert a list of cookies with possibly internal Uri's to use public Uri's instead.
            </summary>
            <param name="cookies">Cookie collection.</param>
            <returns>Cookie collection.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.FormatCookieDateTimeString(System.DateTime)">
            <summary>
            Format <see cref="T:System.DateTime"/> in standard cookie format.
            </summary>
            <param name="date">Date.</param>
            <returns>Cookie datetime string.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.#ctor(System.String,System.String,MindTouch.Dream.XUri)">
            <summary>
            Create new instance.
            </summary>
            <param name="name">Cookie name.</param>
            <param name="value">Cookie value.</param>
            <param name="uri">Cookie Uri.</param>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.Equals(MindTouch.Web.DreamCookie)">
            <summary>
            Compare <see cref="T:MindTouch.Web.DreamCookie"/> instances for identical content.
            </summary>
            <param name="cookie">Cookie to compare.</param>
            <returns><see langword="True"/> if the cookies are the same.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.Equals(System.Object)">
            <summary>
            Comparison override for Cookies.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.GetHashCode">
            <summary>
            GetHashCode override to ensure that cookies with the same content generate the same hashcode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ToString">
            <summary>
            Human readable version of the cookie contents (not suitable as headers).
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.WithHostPort(System.String)">
            <summary>
            Create new cookie based on current instance with host/port.
            </summary>
            <param name="hostPort">Host/port to use for new instance.</param>
            <returns>New cookie.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.WithPath(System.String)">
            <summary>
            Create new cookie based on current instance with path.
            </summary>
            <param name="path">Path to use for new instance.</param>
            <returns>New Cookie.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.WithExpiration(System.DateTime)">
            <summary>
            Create new cookie based on current instance with expiration.
            </summary>
            <param name="expires">Cookie expiration.</param>
            <returns>New Cookie.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.WithDiscard(System.Boolean)">
            <summary>
            Create new cookie based on current instance with discard flag.
            </summary>
            <param name="discard"><see langword="True"/> if the cookie should be discarded.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ToCookieHeader">
            <summary>
            Create an Http cookie header from the current instance.
            </summary>
            <returns>Http cookie header string.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ToSetCookieHeader">
            <summary>
            Create an Http set-cookie header from the current instance.
            </summary>
            <returns>Http set-cookie header string.</returns>
        </member>
        <member name="M:MindTouch.Web.DreamCookie.ToPublicCookie">
            <summary>
            Create new cookie with public Uri, in case the current instance is using 
            </summary>
            <remarks>
            This call uses the public uri captured at cookie creation time, so can be used independently of request context.
            </remarks>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Uri">
            <summary>
            Cookie Uri (derived from Domain and Path).
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Domain">
            <summary>
            Cookie domain.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Path">
            <summary>
            Cookie Path.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Expires">
            <summary>
            Cookie expiration
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Version">
            <summary>
            Cookie version.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Value">
            <summary>
            Cookie value.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Name">
            <summary>
            Cookie name.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Expired">
            <summary>
            <see langword="True"/> if the cookie is already exipired.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Secure">
            <summary>
            <see langword="True"/> if the cookie is used on Https only.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Discard">
            <summary>
            <see langword="True"/> if the cookie is to be discarded.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.Comment">
            <summary>
            Cookie comment.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.CommentUri">
            <summary>
            Cookie comment uri.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.HttpOnly">
            <summary>
            <see langword="True"/> if cookie is only accessible to the http transport, i.e. not client side scripts.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.AsSetCookieDocument">
            <summary>
            Serialize the cookie as a set cookie xml document.
            </summary>
        </member>
        <member name="P:MindTouch.Web.DreamCookie.AsCookieDocument">
            <summary>
            Serialize the cookie as a cookie xml document.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamHeaders">
            <summary>
            Provides a http header collection for <see cref="T:MindTouch.Dream.DreamMessage"/>.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.ACCEPT">
            <summary>
            'Accept' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.ACCEPT_CHARSET">
            <summary>
            'Accept-Charset' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.ACCEPT_ENCODING">
            <summary>
            'Accept-Encoding' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.ACCEPT_LANGUAGE">
            <summary>
            'Accept-Language' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.ACCEPT_RANGES">
            <summary>
            'Accept-Ranges' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.ALLOW">
            <summary>
            'Allow' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.AUTHENTICATE">
            <summary>
            'WWW-Authenticate' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.AUTHORIZATION">
            <summary>
            'Authorization' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CACHE_CONTROL">
            <summary>
            'Cache-Control' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONNECTION">
            <summary>
            'Connection' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONTENT_DISPOSITION">
            <summary>
            '"Content-Disposition' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONTENT_ENCODING">
            <summary>
            'Content-Encoding' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONTENT_LANGUAGE">
            <summary>
            'Content-Language' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONTENT_LENGTH">
            <summary>
            'Content-Length' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONTENT_LOCATION">
            <summary>
            'Content-Location' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONTENT_MD5">
            <summary>
            'Content-MD5' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONTENT_RANGE">
            <summary>
            'Content-Range' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.CONTENT_TYPE">
            <summary>
            'Content-Type' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.COOKIE">
            <summary>
            'Cookie' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DATE">
            <summary>
            'Date' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.ETAG">
            <summary>
            'ETag' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.EXPECT">
            <summary>
            'Expect' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.FROM">
            <summary>
            'From' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.HOST">
            <summary>
            'Host' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.IF_MATCH">
            <summary>
            'If-Match' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.IF_MODIFIED_SINCE">
            <summary>
            'If-Modified-Since' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.IF_NONE_MATCH">
            <summary>
            'If-None-Match' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.IF_RANGE">
            <summary>
            'If-Range' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.IF_UNMODIFIED_SINCE">
            <summary>
            'If-Unmodified-Since' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.LAST_MODIFIED">
            <summary>
            'Last-Modified' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.LOCATION">
            <summary>
            'Location' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.MAX_FORWARDS">
            <summary>
            'Max-Forwards' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.PRAGMA">
            <summary>
            'Pragma' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.RANGE">
            <summary>
            'Range' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.REFERER">
            <summary>
            'Referer' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.RESPONSE_URI">
            <summary>
            'Response-Uri' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.RETRY_AFTER">
            <summary>
            'Retry-After' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.SERVER">
            <summary>
            'Server' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.SET_COOKIE">
            <summary>
            'Set-Cookie' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.TRANSFER_ENCODING">
            <summary>
            'Transfer-Encoding' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.USER_AGENT">
            <summary>
            'User-Agent' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.VARY">
            <summary>
            'Vary' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.PROXY_CONNECTION">
            <summary>
            'Proxy-Connection' Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_TRANSPORT">
            <summary>
            'X-Dream-Transport' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_SERVICE">
            <summary>
            'X-Dream-Service' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_PUBLIC_URI">
            <summary>
            'X-Dream-Public-Uri' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_USER_HOST">
            <summary>
            'X-Dream-User-Host' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_ORIGIN">
            <summary>
            'X-Dream-Origin' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_CLIENTIP">
            <summary>
            'X-Dream-ClientIP' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_EVENT_ID">
            <summary>
            'X-Dream-Event-Id' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_EVENT_CHANNEL">
            <summary>
            'X-Dream-Event-Channel' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_EVENT_RESOURCE">
            <summary>
            'X-Dream-Event-Resource-Uri' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_EVENT_ORIGIN">
            <summary>
            'X-Dream-Event-Origin-Uri' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_EVENT_RECIPIENT">
            <summary>
            'X-Dream-Event-Recipient-Uri' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_EVENT_VIA">
            <summary>
            'X-Dream-Event-Via-Uri' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.DREAM_REQUEST_ID">
            <summary>
            'X-Dream-Request-Id' Dream Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.XRDS_LOCATION">
            <summary>
            'X-XRDS-Location' Application-specific Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.METHOD_OVERRIDE">
            <summary>
            'X-HTTP-Method-Override' Application-specific Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.FRONT_END_HTTPS">
            <summary>
            'Front-End-Https' Application-specific Header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.FORWARDED_HOST">
            <summary>
            'X-Forwarded-Host' Apache mod_proxy Header (original Host header).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.FORWARDED_FOR">
            <summary>
            'X-Forwarded-For' Apache mod_proxy Header (original client IP).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamHeaders.FORWARDED_SERVER">
            <summary>
            'X-Forwarded-Server' Apache mod_proxy Header (server which did the forwarding).
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.#ctor">
            <summary>
            Create new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.#ctor(MindTouch.Dream.DreamHeaders)">
            <summary>
            Create new instance.
            </summary>
            <param name="headers">Headers to copy into new instance.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.#ctor(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Create new instance.
            </summary>
            <param name="headers">Header name/value pairs to copy into new instance.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Create new instance.
            </summary>
            <param name="headers">Header name/value pairs to copy into new instance.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.Clear">
            <summary>
            Clear all headers.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.Add(System.String,System.String)">
            <summary>
            Add a header.
            </summary>
            <param name="name">Header name.</param>
            <param name="value">Header value.</param>
            <returns>Current instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.AddRange(MindTouch.Dream.DreamHeaders)">
            <summary>
            Add a range of headers.
            </summary>
            <param name="headers">Header collection</param>
            <returns>Current instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.AddRange(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Add a range of headers.
            </summary>
            <param name="headers">Header collection.</param>
            <returns>Current instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Add a range of headers.
            </summary>
            <param name="headers">Key value pair collection</param>
            <returns>Current instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.Remove(System.String)">
            <summary>
            Remove a header.
            </summary>
            <param name="name">Header name.</param>
            <returns>Current instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamHeaders.GetValues(System.String)">
            <summary>
            Get header values.
            </summary>
            <param name="name">Header name.</param>
            <returns>Array of values.</returns>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Count">
            <summary>
            Total number of headers.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.HasCookies">
            <summary>
            <see langword="True"/> if the collection has a cookie header that is not empty.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Accept">
            <summary>
            'Accept' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.AcceptCharset">
            <summary>
            'Accept-Charset' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.AcceptEncoding">
            <summary>
            'Accept-Encoding' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.AcceptLanguage">
            <summary>
            'Accept-Language' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.AcceptRanges">
            <summary>
            'Accept-Ranges' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Allow">
            <summary>
            'Allow' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Authenticate">
            <summary>
            'WWW-Authenticate' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Authorization">
            <summary>
            'Authorization' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.CacheControl">
            <summary>
            'Cache-Control' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Connection">
            <summary>
            'Connection' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ContentDisposition">
            <summary>
            'Content-Disposition' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ContentEncoding">
            <summary>
            'Content-Encoding' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ContentLanguage">
            <summary>
            'Content-Language' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ContentLength">
            <summary>
            'Content-Length' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ContentLocation">
            <summary>
            'Content-Location' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ContentMd5">
            <summary>
            'Content-MD5' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ContentRange">
            <summary>
            'Content-Range' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ContentType">
            <summary>
            'Content-Type' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Cookies">
            <summary>
            'Cookie' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Date">
            <summary>
            'Date' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ETag">
            <summary>
            'ETag' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Expect">
            <summary>
            'Expect' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.From">
            <summary>
            'From' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Host">
            <summary>
            'Host' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.IfMatch">
            <summary>
            'If-Match' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.IfModifiedSince">
            <summary>
            'If-Modified-Since' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.IfNoneMatch">
            <summary>
            'If-None-Match' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.IfRange">
            <summary>
            'If-Range' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.IfUnmodifiedSince">
            <summary>
            'If-Unmodified-Since' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.LastModified">
            <summary>
            'Last-Modified' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Location">
            <summary>
            'Location' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.MaxForwards">
            <summary>
            'Max-Forwards' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Pragma">
            <summary>
            'Pragma' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Range">
            <summary>
            'Range' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Referer">
            <summary>
            'Referer' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ResponseUri">
            <summary>
            'Response-Uri' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.RetryAfter">
            <summary>
            'Retry-After' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Server">
            <summary>
            'Server' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.TransferEncoding">
            <summary>
            'Transfer-Encoding' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.UserAgent">
            <summary>
            'User-Agent' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Vary">
            <summary>
            'Vary' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ProxyConnection">
            <summary>
            'Proxy-Connection' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamTransport">
            <summary>
            'X-Dream-Transport' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamService">
            <summary>
            'X-Dream-Service' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamPublicUri">
            <summary>
            'X-Dream-Public-Uri' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamUserHost">
            <summary>
            'X-Dream-User-Host' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamOrigin">
            <summary>
            'X-Dream-Origin' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamClientIP">
            <summary>
            'X-Dream-ClientIP' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamEventId">
            <summary>
            'X-Dream-Event-Id' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamEventChannel">
            <summary>
            'X-Dream-Event-Channel' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamEventResource">
            <summary>
            'X-Dream-Event-Resource-Uri' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamEventOrigin">
            <summary>
            'X-Dream-Event-Origin-Uri' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamEventRecipients">
            <summary>
            'X-Dream-Recipient-Uri' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamEventVia">
            <summary>
            'X-Dream-Event-Via' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.DreamRequestId">
            <summary>
            'X-Dream-Request-Id' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.XrdsLocation">
            <summary>
            'X-XRDS-Location' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.MethodOverride">
            <summary>
            'X-HTTP-Method-Override' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.FrontEndHttps">
            <summary>
            'Front-End-Https' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ForwardedHost">
            <summary>
            'X-Forwarded-Host' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ForwardedFor">
            <summary>
            'X-Forwarded-For' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.ForwardedServer">
            <summary>
            'X-Forwarded-Server' Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamHeaders.Item(System.String)">
            <summary>
            Accessor to any header by name.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamMessage">
            <summary>
            Provides the Dream encapsulations of Http request and response objects.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Ok">
            <summary>
            New Message with HTTP status: Ok (200).
            </summary>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Ok(MindTouch.Xml.XDoc)">
            <summary>
            New Message with HTTP status: Ok (200).
            </summary>
            <param name="doc">Message body.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Ok(MindTouch.Dream.MimeType,MindTouch.Xml.XDoc)">
            <summary>
            New Message with HTTP status: Ok (200).
            </summary>
            <param name="contentType">Content Mime-Type.</param>
            <param name="doc">Message body.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Ok(MindTouch.Dream.MimeType,System.String)">
            <summary>
            New Message with HTTP status: Ok (200).
            </summary>
            <param name="contentType">Content Mime-Type.</param>
            <param name="text">Message body.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Ok(MindTouch.Dream.XUri)">
            <summary>
            Obsolete: Use <see cref="M:MindTouch.Dream.DreamMessage.Ok(System.Collections.Generic.KeyValuePair{System.String,System.String}[])"/> instead.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Ok(System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>
            New Message with HTTP status: Ok (200).
            </summary>
            <param name="values">Name/value pair body.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Ok(MindTouch.Dream.MimeType,System.Byte[])">
            <summary>
            New Message with HTTP status: Ok (200).
            </summary>
            <param name="contentType">Content Mime-Type.</param>
            <param name="content">Message body.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Ok(MindTouch.Dream.MimeType,System.Int64,System.IO.Stream)">
            <summary>
            New Message with HTTP status: Ok (200).
            </summary>
            <param name="contentType">Content Mime-Type.</param>
            <param name="contentLength">Content length.</param>
            <param name="content">Message body.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Created(MindTouch.Dream.XUri,MindTouch.Xml.XDoc)">
            <summary>
            New Message with HTTP status: Created (201).
            </summary>
            <param name="uri">Location of created resource.</param>
            <param name="doc">Message body.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.NotModified">
            <summary>
            New Message with HTTP status: Not Modified (304).
            </summary>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.NotFound(System.String)">
            <summary>
            New Message with HTTP status: Not Found (404).
            </summary>
            <param name="reason">Reason.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.BadRequest(System.String)">
            <summary>
            New Message with HTTP status: Bad Request (400).
            </summary>
            <param name="reason">Reason.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.NotImplemented(System.String)">
            <summary>
            New Message with HTTP status: Not Implemented (501).
            </summary>
            <param name="reason">Reason.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Conflict(MindTouch.Xml.XDoc)">
            <summary>
            New Message with HTTP status: Conflict (409).
            </summary>
            <param name="doc">Message body.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Conflict(System.String)">
            <summary>
            New Message with HTTP status: Conflict (409).
            </summary>
            <param name="reason">Reason.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Redirect(MindTouch.Dream.XUri)">
            <summary>
            New Message with HTTP status: Found (302)
            </summary>
            <param name="uri">Redirect target.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.AccessDenied(System.String,System.String)">
            <summary>
            New Message with HTTP status: Unauthorized (401)
            </summary>
            <param name="accessRealm">Access Realm.</param>
            <param name="reason">Reason.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.LicenseRequired(System.String)">
            <summary>
            New Message with HTTP status: LicenseRequired (402)
            </summary>
            <param name="reason">Reason.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Forbidden(System.String)">
            <summary>
            New Message with HTTP status: Forbidden (403)
            </summary>
            <param name="reason">Reason.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.MethodNotAllowed(System.String[],System.String)">
            <summary>
            New Message with HTTP status: Method Not Allowed (405)
            </summary>
            <param name="allowedMethods">Array of allowed request Verbs.</param>
            <param name="reason">Reason.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.InternalError">
            <summary>
            New Message with HTTP status: Internal Error (500)
            </summary>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.InternalError(System.String)">
            <summary>
            New Message with HTTP status: Internal Error (500)
            </summary>
            <param name="text">Error message.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.InternalError(System.Exception)">
            <summary>
            New Message with HTTP status: Internal Error (500)
            </summary>
            <param name="e">Exception responsible for internal error.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.FromFile(System.String)">
            <summary>
            Create a message from a file.
            </summary>
            <param name="filename">Path to file.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.FromFile(System.String,System.Boolean)">
            <summary>
            Create a message from a file.
            </summary>
            <param name="filename">Path to file.</param>
            <param name="omitFileContents">If <see langword="True"/> the contents of the file are omitted.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.FromFile(System.String,MindTouch.Dream.MimeType,System.String,System.Boolean)">
            <summary>
            Create a message from a file.
            </summary>
            <param name="filename">Path to file.</param>
            <param name="contentType">Mime-Type of message.</param>
            <param name="displayName">File name to emit.</param>
            <param name="omitFileContents">If <see langword="True"/> the contents of the file are omitted.</param>
            <returns>New DreamMessage.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.ForStreaming(MindTouch.Dream.MimeType,MindTouch.Dream.DreamMessage@,System.IO.Stream@)">
            <summary>
            Create a new message tied to a Stream for streaming data.
            </summary>
            <param name="mime">Content Mime-Type.</param>
            <param name="message">The message to be created.</param>
            <param name="writer">The stream that will supply the streaming data.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.GetStatusStringOrNull(MindTouch.Dream.DreamMessage)">
            <summary>
            Get a status string from a DreamMessage or null, or null, if the message is null.
            </summary>
            <param name="message">A DreamMessage instance or null.</param>
            <returns>The <see cref="F:MindTouch.Dream.DreamMessage.Status"/> as an information string message if a non-null message was provide, or null otherwise.</returns>
        </member>
        <member name="F:MindTouch.Dream.DreamMessage.Status">
            <summary>
            Http Status of message.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamMessage.Headers">
            <summary>
            Message Http header collection.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.#ctor(MindTouch.Dream.DreamStatus,MindTouch.Dream.DreamHeaders)">
            <summary>
            Create a new message.
            </summary>
            <param name="status">Http status.</param>
            <param name="headers">Header collection.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.#ctor(MindTouch.Dream.DreamStatus,MindTouch.Dream.DreamHeaders,MindTouch.Dream.MimeType,MindTouch.Xml.XDoc)">
            <summary>
            Create a new message.
            </summary>
            <param name="status">Http status.</param>
            <param name="headers">Header collection.</param>
            <param name="contentType">Content Mime-Type.</param>
            <param name="doc">Message body.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.#ctor(MindTouch.Dream.DreamStatus,MindTouch.Dream.DreamHeaders,MindTouch.Xml.XDoc)">
            <summary>
            Create a new message.
            </summary>
            <param name="status">Http status.</param>
            <param name="headers">Header collection.</param>
            <param name="doc">Message body.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.#ctor(MindTouch.Dream.DreamStatus,MindTouch.Dream.DreamHeaders,MindTouch.Dream.MimeType,System.Int64,System.IO.Stream)">
            <summary>
            Create a new message.
            </summary>
            <param name="status">Http status.</param>
            <param name="headers">Header collection.</param>
            <param name="contentType">Content Mime-Type</param>
            <param name="contentLength">Content byte langth</param>
            <param name="stream">Stream to uas as the source for the message's content.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.#ctor(MindTouch.Dream.DreamStatus,MindTouch.Dream.DreamHeaders,MindTouch.Dream.MimeType,System.Byte[])">
            <summary>
            Create a new message.
            </summary>
            <param name="status">Http status.</param>
            <param name="headers">Header collection.</param>
            <param name="contentType">Content Mime-Type.</param>
            <param name="bytes">Message body.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.#ctor(MindTouch.Dream.DreamStatus,MindTouch.Dream.DreamHeaders,MindTouch.Dream.MimeType,System.String)">
            <summary>
            Create a new message.
            </summary>
            <param name="status">Http status.</param>
            <param name="headers">Header collection.</param>
            <param name="contentType">Content Mime-Type.</param>
            <param name="text">Message body.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.ToDocument">
            <summary>
            Get the message body as a document.
            </summary>
            <returns>XDoc instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.ToStream">
            <summary>
            Get the message body as a Stream.
            </summary>
            <returns>Content Stream.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.ToBytes">
            <summary>
            Convert the message body into a byte array.
            </summary>
            <remarks>This method is potentially thread-blocking. Please avoid using it if possible.</remarks>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.ToText">
            <summary>
            Convert the message body to plain text.
            </summary>
            <returns>Content text.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.ToTextReader">
            <summary>
            Convert the message body to a text reader.
            </summary>
            <returns>New text reader instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.SetCacheMustRevalidate(System.DateTime)">
            <summary>
            Set Caching headers.
            </summary>
            <param name="timestamp">Last modified timestamp.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.CheckCacheRevalidation(System.DateTime)">
            <summary>
            Check if the cache needs ot be re-validated
            </summary>
            <param name="timestamp">Last modified timestamp.</param>
            <returns><see langword="True"/> if the cache needs to be re-validated.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Clone">
            <summary>
            Clone the current message.
            </summary>
            <returns>A new message instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Close">
            <summary>
            Close any underlying stream on the message.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Memorize(MindTouch.Tasking.Result)">
            <summary>
            Memorize the content stream.
            </summary>
            <param name="result">The synchronization handle to return.</param>
            <returns>Synchronization handle for memorization completion.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.Memorize(System.Int64,MindTouch.Tasking.Result)">
            <summary>
            Memorize the content stream.
            </summary>
            <param name="result">The synchronization handle to return.</param>
            <param name="max">Maximum number of bytes to memorize.</param>
            <returns>Synchronization handle for memorization completion.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.ToString">
            <summary>
            Convert the message into a string.
            </summary>
            <returns>String.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.AsDocument">
            <summary>
            AsDocument() is obsolete. Use <see cref="M:MindTouch.Dream.DreamMessage.ToDocument"/> instead.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.AsStream">
            <summary>
            AsStream() is obsolete. Use <see cref="M:MindTouch.Dream.DreamMessage.ToStream"/> instead.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.AsBytes">
            <summary>
            AsBytes() is obsolete. Use <see cref="M:MindTouch.Dream.DreamMessage.ToBytes"/> instead.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.AsText">
            <summary>
            AsText() is obsolete. Use <see cref="M:MindTouch.Dream.DreamMessage.ToText"/> instead.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamMessage.AsTextReader">
            <summary>
            AsTextReader() is obsolete. Use <see cref="M:MindTouch.Dream.DreamMessage.ToTextReader"/> instead.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.IsSuccessful">
            <summary>
            <see langword="True"/> if the Status indicates a successful response.
            </summary>
            <remarks>Requests are always marked as successful. Only responses use the status to convey information.</remarks>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.ContentType">
            <summary>
            Message Content Mime-Type.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.HasCookies">
            <summary>
            Message contains cookies.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.Cookies">
            <summary>
            Cookies.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.ContentDisposition">
            <summary>
            Content Disposition Header.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.IsClosed">
            <summary>
            <see langword="True"/> if the underlying content stream is closed.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.ContentLength">
            <summary>
            Total number of bytes in message.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.HasDocument">
            <summary>
            <see langword="True"/> if the message content can be retrieved as an <see cref="T:MindTouch.Xml.XDoc"/> instance.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamMessage.IsCloneable">
            <summary>
            Can this message be clone?
            </summary>
            <remarks>In general only false for closed messages and messages with non-memorized streams.</remarks>
        </member>
        <member name="T:MindTouch.Dream.DreamUtil">
            <summary>
            Provides common constants, properties, extension methods and static helpers for working with the Dream framework.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamUtil.TIMEOUT_DEFAULT">
            <summary>
            Default timeout (30 seconds).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamUtil.TIMEOUT_LONG">
            <summary>
            Long timeout (30 minutes).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamUtil.TIMEOUT_SHORT">
            <summary>
            Short timeout (10 seconds).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamUtil.DEFAULT_PACKETSIZE">
            <summary>
            Default Packetsize (1024 bytes).
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamUtil.PrepareIncomingMessage(MindTouch.Dream.DreamMessage,System.Text.Encoding,System.String,System.String,System.String)">
            <summary>
            Prepare an incoming message with host environment information.
            </summary>
            <param name="message"></param>
            <param name="contentEncoding"></param>
            <param name="transport"></param>
            <param name="requestClientIp"></param>
            <param name="userAgent"></param>
        </member>
        <member name="M:MindTouch.Dream.DreamUtil.AppendHeadersToInternallyForwardedMessage(MindTouch.Dream.DreamMessage,MindTouch.Dream.DreamMessage)">
            <summary>
            Append Dream specific headers from a source message to an internally forwarded one.
            </summary>
            <param name="original">Source messag.</param>
            <param name="forwarded">Message to be forwarded.</param>
            <returns>Message to be forwarded instance.</returns>
        </member>
        <member name="P:MindTouch.Dream.DreamUtil.DreamVersion">
            <summary>
            Dream Version.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamException">
            <summary>
            Provides the common base exception for Dream specific exceptions.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamException.#ctor">
            <summary>
            Create new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamException.#ctor(System.String)">
            <summary>
            Create new instance with a message about the error that cause the exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamException.#ctor(System.String,System.Exception)">
            <summary>
            Create new instance with the exception and a message about the cause of this error.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamRequestFatalException">
            <summary>
            Provides a common exception base for exceptions that should stop request processing from proceeding.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamRequestFatalException.#ctor">
            <summary>
            Create new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamRequestFatalException.#ctor(System.String)">
            <summary>
            Create new instance with a message about the error that cause the exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamRequestFatalException.#ctor(System.String,System.Exception)">
            <summary>
            Create new instance with the exception and a message about the cause of this error.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamContextAccessException">
            <summary>
            Provides an exception thrown by <see cref="T:MindTouch.Dream.DreamContext"/> when an invalid access is made by <see cref="P:MindTouch.Dream.DreamContext.Current"/> or <see cref="M:MindTouch.Dream.DreamContext.AttachToCurrentTaskEnv"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamContextAccessException.#ctor">
            <summary>
            Create new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamContextAccessException.#ctor(System.String)">
            <summary>
            Create new instance with a message about the error that cause the exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamContextAccessException.#ctor(System.String,System.Exception)">
            <summary>
            Create new instance with the exception and a message about the cause of this error.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamResponseException">
            <summary>
            Provides an exception that is thrown by blocking <see cref="T:MindTouch.Dream.Plug"/> calls when the response <see cref="T:MindTouch.Dream.DreamMessage"/> indicates an unsuccessful request.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamResponseException.Response">
            <summary>
            The response that caused this exception.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamResponseException.#ctor(MindTouch.Dream.DreamMessage)">
            <summary>
            Create new instance for an unsuccessful response.
            </summary>
            <param name="response">Unsuccessful response message.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamResponseException.#ctor(MindTouch.Dream.DreamMessage,System.String)">
            <summary>
            Create new instance for an unsuccessful response.
            </summary>
            <param name="response">Unsuccessful response message.</param>
            <param name="message">A message about why the response failed.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamResponseException.#ctor(MindTouch.Dream.DreamMessage,System.String,System.Exception)">
            <summary>
            Create a new instance for an unsuccessful response.
            </summary>
            <param name="response">Unsuccessful response message.</param>
            <param name="message">A message about why the response failed.</param>
            <param name="innerException">The exception that caused the message to be unsuccessful.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamResponseException.ToString">
            <summary>
            Creates and returns a string representation of the current exception.
            </summary>
            <returns>A string representation of the current exception.</returns>
        </member>
        <member name="T:MindTouch.Dream.DreamAbortException">
            <summary>
            Provides an exception to be thrown when a request is aborted because of an error.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamAbortException.Response">
            <summary>
            Message describing the reason for the aborted request.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamAbortException.#ctor(MindTouch.Dream.DreamMessage)">
            <summary>
            Create new instance with a message describing the reason for the aborted request.
            </summary>
            <param name="response">Message describing the reason for the aborted request.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamAbortException.#ctor(MindTouch.Dream.DreamMessage,System.String)">
            <summary>
            Create new instance with a message describing the reason for the aborted request.
            </summary>
            <param name="response">Message describing the reason for the aborted request.</param>
            <param name="message">Additional text message about the problem.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamAbortException.#ctor(MindTouch.Dream.DreamMessage,System.String,System.Exception)">
            <summary>
            Create new instance with a message describing the reason for the aborted request.
            </summary>
            <param name="response">Message describing the reason for the aborted request.</param>
            <param name="message">Additional text message about the problem.</param>
            <param name="innerException">The exception that caused the message to be unsuccessful.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamInternalErrorException">
            <summary>
            Provides a <see cref="T:MindTouch.Dream.DreamAbortException"/> with a <see cref="F:MindTouch.Dream.DreamStatus.InternalError"/> message.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamInternalErrorException.#ctor">
            <summary>
            Create a new instance for an <see cref="F:MindTouch.Dream.DreamStatus.InternalError"/> failure.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamInternalErrorException.#ctor(System.String)">
            <summary>
            Create a new instance for an <see cref="F:MindTouch.Dream.DreamStatus.InternalError"/> failure.
            </summary>
            <param name="message">Text message to use for <see cref="P:System.Exception.Message"/> and the internal <see cref="T:MindTouch.Dream.DreamMessage"/>.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamInternalErrorException.#ctor(System.Exception)">
            <summary>
            Create a new instance for a <see cref="F:MindTouch.Dream.DreamStatus.InternalError"/> condition.
            </summary>
            <param name="innerException">The exception that cause the internal error for the request.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamBadRequestException">
            <summary>
            Provides a <see cref="T:MindTouch.Dream.DreamAbortException"/> with a <see cref="F:MindTouch.Dream.DreamStatus.BadRequest"/> message.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamBadRequestException.#ctor(System.String)">
            <summary>
            Create a new instance for a <see cref="F:MindTouch.Dream.DreamStatus.BadRequest"/> condition.
            </summary>
            <param name="message">Text message to use for <see cref="P:System.Exception.Message"/> and the internal <see cref="T:MindTouch.Dream.DreamMessage"/>.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamForbiddenException">
            <summary>
            Provides a <see cref="T:MindTouch.Dream.DreamAbortException"/> with a <see cref="F:MindTouch.Dream.DreamStatus.Forbidden"/> message.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamForbiddenException.#ctor(System.String)">
            <summary>
            Create a new instance for a <see cref="F:MindTouch.Dream.DreamStatus.Forbidden"/> condition.
            </summary>
            <param name="message">Text message to use for <see cref="P:System.Exception.Message"/> and the internal <see cref="T:MindTouch.Dream.DreamMessage"/>.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamNotFoundException">
            <summary>
            Provides a <see cref="T:MindTouch.Dream.DreamAbortException"/> with a <see cref="F:MindTouch.Dream.DreamStatus.NotFound"/> message.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamNotFoundException.#ctor(System.String)">
            <summary>
            Create a new instance for a <see cref="F:MindTouch.Dream.DreamStatus.NotFound"/> condition.
            </summary>
            <param name="message">Text message to use for <see cref="P:System.Exception.Message"/> and the internal <see cref="T:MindTouch.Dream.DreamMessage"/>.</param>
        </member>
        <member name="T:MindTouch.Dream.FeatureArgumentParseException">
            <summary>
            Thrown at DreamFeature invocation if any of the arguments cannot be properly parsed from the incoming message.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.FeatureArgumentParseException.ArgumentName">
            <summary>
            Name of the feature argument that failed to parse.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.FeatureArgumentParseException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new exception for a <see cref="T:MindTouch.Dream.DreamFeature"/> argument parsing failure
            </summary>
            <param name="argumentName">Name of the feature argument that failed to parse.</param>
            <param name="e">Failure type.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamStatus">
            <summary>
            Enumerates the possible Http response codes.
            </summary>
            <remarks>
            Codes below 100 are specific to <see cref="T:MindTouch.Dream.Plug"/> and not part of Http.
            </remarks>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.UnableToConnect">
            <summary>
            Unable to connect (0).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.NoEndpointFound">
            <summary>
            No <see cref="T:MindTouch.Dream.IPlugEndpoint"/> could be found for Uri. (1).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.RequestIsNull">
            <summary>
            Request is null (10).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.RequestFailed">
            <summary>
            Request Failed (11).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.RequestConnectionTimeout">
            <summary>
            Request failed because the connection timed out (12).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.ResponseIsNull">
            <summary>
            Response is null (20).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.ResponseFailed">
            <summary>
            Response Failed (21).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.ResponseDataTransferTimeout">
            <summary>
            Response failed because the data transfer timed out (22).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Ok">
            <summary>
            Ok (200).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Created">
            <summary>
            Created (201).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Accepted">
            <summary>
            Accepted (202).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.NonAuthoritativeInformation">
            <summary>
            Non-authoritative Information (203).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.NoContent">
            <summary>
            No content (204).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.ResetContent">
            <summary>
            Reset content (205).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.PartialContent">
            <summary>
            Partial content (206).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.MultiStatus">
            <summary>
            Multi status (207).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.MultipleChoices">
            <summary>
            Multiple choices (300).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.MovedPermanently">
            <summary>
            Moved permanently (301).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Found">
            <summary>
            Found (302).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.SeeOther">
            <summary>
            See other (303).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.NotModified">
            <summary>
            Not modified (304).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.UseProxy">
            <summary>
            Use proxy (305).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.TemporaryRedirect">
            <summary>
            Temporary redirct (307).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.BadRequest">
            <summary>
            Bad Request (400).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Unauthorized">
            <summary>
            Unauthorized (401).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.LicenseRequired">
            <summary>
            License required (402).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Forbidden">
            <summary>
            Forbidden (403).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.NotFound">
            <summary>
            Not found (404).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.MethodNotAllowed">
            <summary>
            Method is not allowed (405).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.NotAcceptable">
            <summary>
            Not acceptable (406).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.ProxyAuthenticationRequired">
            <summary>
            Proxy authentication required (407).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.RequestTimeout">
            <summary>
            Request timeout (408).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Conflict">
            <summary>
            Conflict (409).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Gone">
            <summary>
            Gone (410).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.LengthRequired">
            <summary>
            Length required (411).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.PreconditionFailed">
            <summary>
            Precondition Failed (412).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.RequestEntityTooLarge">
            <summary>
            Request entity too large (413).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.RequestURIToLong">
            <summary>
            Request Uri is too long (414).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.UnsupportedMediaType">
            <summary>
            Unsupported media type (415).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.RequestedRangeNotSatisfiable">
            <summary>
            Request range not satisfiable (416).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.ExpectationFailed">
            <summary>
            Expecation failed (417).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.UnprocessableEntity">
            <summary>
            Unprocessable entity (422).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.Locked">
            <summary>
            Locked (423).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.FailedDependency">
            <summary>
            Failed dependency (424).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.InternalError">
            <summary>
            Internal error (500).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.NotImplemented">
            <summary>
            Not implemented (501).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.BadGateway">
            <summary>
            Bad Gateway (502).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.ServiceUnavailable">
            <summary>
            Service unavailable (503).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.GatewayTimeout">
            <summary>
            Gateway timeout (504).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.HTTPVersionNotSupported">
            <summary>
            Http version not supported (505).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamStatus.InsufficientStorage">
            <summary>
            Insuffient storage (507).
            </summary>
        </member>
        <member name="T:MindTouch.Dream.MimeType">
            <summary>
            Encapsulates a content mime type.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.MimeType.ANY">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance that can match any mime type.
            </summary>
            <remarks>Signature: <b>*/*</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.ANY_TEXT">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance that can match any text mime type.
            </summary>
            <remarks>Signature: <b>text/*</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.ATOM">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Atom content.
            </summary>
            <remarks>Signature: <b>application/atom+xml; UTF8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.BINARY">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for binary content.
            </summary>
            <remarks>Signature: <b>application/octet-stream</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.BMP">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for BMP Images.
            </summary>
            <remarks>Signature: <b>image/bmp</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.CSS">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for CSS.
            </summary>
            <remarks>Signature: <b>text/css; ASCII</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.DREAM_EXCEPTION">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for dream exception xml.
            </summary>
            <remarks>Signature: <b>application/x-dream-exception+xml; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.FORM_URLENCODED">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for wwww form urlencoded content.
            </summary>
            <remarks>Signature: <b>application/x-www-form-urlencoded; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.GIF">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for GIF images.
            </summary>
            <remarks>Signature: <b>image/gif</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.HTML">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Html content.
            </summary>
            <remarks>Signature: <b>text/html; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.HTTP">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Http Applications.
            </summary>
            <remarks>Signature: <b>application/http; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.JPEG">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for JPEG images.
            </summary>
            <remarks>Signature: <b>image/jpeg</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.JS">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for javascript source code.
            </summary>
            <remarks>Signature: <b>text/javascript; ASCII</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.JSON">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for javascript object notation content.
            </summary>
            <remarks>Signature: <b>application/json; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.MULTIPART_MIXED">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for multipart/mixed content.
            </summary>
            <remarks>Signature: <b>multipart/mixed</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.NOTHING">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance indidcating no content.
            </summary>
            <remarks>Signature: <b>-/-</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.PDF">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Adobe PDF.
            </summary>
            <remarks>Signature: <b>application/pdf</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.PHP">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for PHP source code.
            </summary>
            <remarks>Signature: <b>application/php; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.PNG">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for PNG images.
            </summary>
            <remarks>Signature: <b>image/png</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.RDF">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for RDF content.
            </summary>
            <remarks>Signature: <b>application/rdf+xml; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.RELAXNG">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Relax-NG schema content.
            </summary>
            <remarks>Signature: <b>application/relax-ng-compact-syntax; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.SVG">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for SVG images.
            </summary>
            <remarks>Signature: <b>image/svg+xml; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.TEXT">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for plain text content.
            </summary>
            <remarks>Signature: <b>text/plain; ASCII</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.TEXT_UTF8">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for UTF-8 encoded text content.
            </summary>
            <remarks>Signature: <b>text/plain; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.TEXT_XML">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for ASCII-encoded Xml content.
            </summary>
            <remarks>Signature: <b>text/xml; ASCII</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.TIFF">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for TIFF images.
            </summary>
            <remarks>Signature: <b>image/tiff</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.VCAL">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for VCal calendar files.
            </summary>
            <remarks>Signature: <b>text/calendar; ASCII</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.VERSIT">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for VCard files.
            </summary>
            <remarks>Signature: <b>application/x-versit; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.XHTML">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for XHtml content.
            </summary>
            <remarks>Signature: <b>application/xhtml+xml; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.XML">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Xml content.
            </summary>
            <remarks>Signature: <b>application/xml; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.XRDS">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Xrds content.
            </summary>
            <remarks>Signature: <b>application/xrds+xml; UTF-8</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.MSOFFICE_DOC">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Microsoft Office 2003 Word content.
            </summary>
            <remarks>Signature: <b>application/msword</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.MSOFFICE_DOCX">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Microsoft Office 2007/2010 Word content.
            </summary>
            <remarks>Signature: <b>application/vnd.openxmlformats-officedocument.wordprocessingml.document</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.MSOFFICE_XLS">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Microsoft Office 2003 Excel content.
            </summary>
            <remarks>Signature: <b>application/vnd.ms-excel</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.MSOFFICE_XLSX">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Microsoft Office 2007/2010 Excel content.
            </summary>
            <remarks>Signature: <b>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.MSOFFICE_PPT">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Microsoft Office 2003 Powerpoint content.
            </summary>
            <remarks>Signature: <b>application/vnd.ms-powerpoint</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.MSOFFICE_PPTX">
            <summary>
            Creates a <see cref="T:MindTouch.Dream.MimeType"/> instance for Microsoft Office 2007/2010 Powerpoint content.
            </summary>
            <remarks>Signature: <b>application/vnd.openxmlformats-officedocument.presentationml.presentation</b></remarks>
        </member>
        <member name="F:MindTouch.Dream.MimeType.DefaultMimeType">
            <summary>
            Default mimetype returned by <see cref="M:MindTouch.Dream.MimeType.FromFileExtension(System.String)"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.MimeType.New(System.String)">
            <summary>
            Create a new Mimetype instance with a manually specified content-type.
            </summary>
            <param name="contentTypeWithParameters">Content type string.</param>
            <returns>New mime type instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.MatchBestContentType(MindTouch.Dream.MimeType[],MindTouch.Dream.MimeType[])">
            <summary>
            Get the best matching Mimetype given a list of mime-type options and accepted mime-types.
            </summary>
            <param name="have">Array of possible mime-types.</param>
            <param name="accept">Array of mime-types accepted.</param>
            <returns>Best match mime-type instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.ParseAcceptHeader(System.String)">
            <summary>
            Parse an array of accepted mime-types from an <see cref="P:MindTouch.Dream.DreamHeaders.Accept"/> header.
            </summary>
            <param name="accept"><see cref="P:MindTouch.Dream.DreamHeaders.Accept"/> header value.</param>
            <returns>Array of accepted mime-types.</returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.RenderAcceptHeader(MindTouch.Dream.MimeType[])">
            <summary>
            Render an <see cref="P:MindTouch.Dream.DreamHeaders.Accept"/> header value from an array of mime-types.
            </summary>
            <param name="types">Array of mime-types.</param>
            <returns><see cref="P:MindTouch.Dream.DreamHeaders.Accept"/> header value string.</returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.FromFileExtension(System.String)">
            <summary>
            Derive a mime-type from a file extension.
            </summary>
            <remarks>The default mimetype returned is <see cref="F:MindTouch.Dream.MimeType.BINARY"/>.</remarks>
            <param name="filename">Filename to get extension from.</param>
            <returns>Best match mime-type.</returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.TryParse(System.String,MindTouch.Dream.MimeType@)">
            <summary>
            Try to parse a mime-type from a content-type string.
            </summary>
            <param name="contentTypeWithParameters">Content type string.</param>
            <param name="result">Mime-type instance return value.</param>
            <returns><see langword="True"/> if a mime-type could be parsed.</returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.TryParse(System.String,System.String@,System.String@,System.Collections.Generic.Dictionary{System.String,System.String}@)">
            <summary>
            Try to parse a mime-type components from a content-type string.
            </summary>
            <param name="contentTypeWithParameters">Content type string.</param>
            <param name="type">Main type return value.</param>
            <param name="subtype">Sub-type return value.</param>
            <param name="parameters">Dictionary of mime-type parameters.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.#ctor(System.String)">
            <summary>
            Create a new mime-type from an exact-match content-type string.
            </summary>
            <param name="contentTypeWithParameters">Content type string.</param>
        </member>
        <member name="M:MindTouch.Dream.MimeType.#ctor(System.String,System.Text.Encoding,System.Single)">
            <summary>
            Create a new mime-type from an exact-match content-type string.
            </summary>
            <param name="contentTypeWithParameters">Content type string.</param>
            <param name="charset">Encoding to set for mime-type.</param>
            <param name="quality">Match quality.</param>
        </member>
        <member name="M:MindTouch.Dream.MimeType.#ctor(System.String,System.Single)">
            <summary>
            Create a new mime-type from an exact-match content-type string.
            </summary>
            <param name="contentTypeWithParameters">Content type string.</param>
            <param name="quality">Match quality.</param>
        </member>
        <member name="M:MindTouch.Dream.MimeType.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Create a new mime-type from an exact-match content-type string.
            </summary>
            <param name="contentTypeWithParameters">Content type string.</param>
            <param name="charset">Encoding to set for mime-type.</param>
        </member>
        <member name="M:MindTouch.Dream.MimeType.Match(MindTouch.Dream.MimeType)">
            <summary>
            Try to match instance against another instance.
            </summary>
            <param name="other">Other mime-type.</param>
            <returns><see langword="True"/> if the two types match.</returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.GetParameter(System.String)">
            <summary>
            Get a named parameter.
            </summary>
            <param name="name">Parameter name.</param>
            <returns>Parameter value or null.</returns>
        </member>
        <member name="M:MindTouch.Dream.MimeType.ToString">
            <summary>
            Render mime-type as a string representation including parameters.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Dream.MimeType.MainType">
            <summary>
            Main type.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.MimeType.SubType">
            <summary>
            Sub type.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.MimeType.FullType">
            <summary>
            Full type (without parameters).
            </summary>
        </member>
        <member name="P:MindTouch.Dream.MimeType.Parameters">
            <summary>
            Type parameters.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.MimeType.Quality">
            <summary>
            Match quality value.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.MimeType.CharSet">
            <summary>
            Type Encoding.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.MimeType.IsXml">
            <summary>
            <see langword="True"/> if content represented by the mime-type is Xml.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamService">
            <summary>
            Base class for easily creating <see cref="T:MindTouch.Dream.IDreamService"/> implementations.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.IDreamService">
            <summary>
            Provides interface that all services hosted in Dream must implement.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.IDreamService.Initialize(MindTouch.Dream.IDreamEnvironment,MindTouch.Xml.XDoc)">
            <summary>
            Initialize a service instance.
            </summary>
            <param name="environment">Host environment.</param>
            <param name="blueprint">Service blueprint.</param>
        </member>
        <member name="M:MindTouch.Dream.IDreamService.DetermineAccess(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage)">
            <summary>
            Determine the access appropriate for an incoming request.
            </summary>
            <param name="context">Request context.</param>
            <param name="request">Request message.</param>
            <returns>Access level for request.</returns>
        </member>
        <member name="P:MindTouch.Dream.IDreamService.Env">
            <summary>
            <see cref="T:MindTouch.Dream.Plug"/> for Service's Host environment.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamService.Self">
            <summary>
            Service <see cref="T:MindTouch.Dream.Plug"/>
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamService.Cookies">
            <summary>
            Service cookie jar.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamService.Prologues">
            <summary>
            Prologue request stages to be executed before a Feature is executed.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamService.Epilogues">
            <summary>
            Epilogue request stages to be executed after a Feature has completed.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamService.ExceptionTranslators">
            <summary>
            Exception translators given an opportunity to rewrite an exception before it is returned to the initiator of a request.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamService.CreateServiceBlueprint(System.Type)">
            <summary>
            Create a service blueprint from reflection and attribute meta-data for an <see cref="T:MindTouch.Dream.IDreamService"/> implementation.
            </summary>
            <param name="type">Type of examine.</param>
            <returns>Xml formatted blueprint.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.#ctor">
            <summary>
            Base constructor, initializing private and internal access keys.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamService.GetConfig(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            <see cref="T:MindTouch.Dream.DreamFeature"/> for retrieve the service configuration.
            </summary>
            <param name="context">Feature request context.</param>
            <param name="request">Request message.</param>
            <param name="response">Response synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> to invoke the feature.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.PutConfig(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            <see cref="T:MindTouch.Dream.DreamFeature"/> for initializing the service with its configuration.
            </summary>
            <remarks>
            This feature is responsible for calling <see cref="M:MindTouch.Dream.DreamService.Start(MindTouch.Xml.XDoc,MindTouch.Tasking.Result)"/>.
            </remarks>
            <param name="context">Feature request context.</param>
            <param name="request">Request message.</param>
            <param name="response">Response synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> to invoke the feature.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.DeleteConfig(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            <see cref="T:MindTouch.Dream.DreamFeature"/> for deinitializing the service.
            </summary>
            <param name="context">Feature request context.</param>
            <param name="request">Request message.</param>
            <param name="response">Response synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> to invoke the feature.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.GetServiceBlueprint(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            <see cref="T:MindTouch.Dream.DreamFeature"/> for retrieving the service blueprint.
            </summary>
            <param name="context">Feature request context.</param>
            <param name="request">Request message.</param>
            <param name="response">Response synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> to invoke the feature.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.GetServiceInfo(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            <see cref="T:MindTouch.Dream.DreamFeature"/> for retrieving the service description.
            </summary>
            <param name="context">Feature request context.</param>
            <param name="request">Request message.</param>
            <param name="response">Response synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> to invoke the feature.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.DeleteService(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            <see cref="T:MindTouch.Dream.DreamFeature"/> for deleting the service (separate from deinitializing it.)
            </summary>
            <param name="context">Feature request context.</param>
            <param name="request">Request message.</param>
            <param name="response">Response synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> to invoke the feature.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.Initialize(MindTouch.Dream.IDreamEnvironment,MindTouch.Xml.XDoc)">
            <summary>
            Initialize a service instance.
            </summary>
            <param name="env">Host environment.</param>
            <param name="blueprint">Service blueprint.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamService.Start(MindTouch.Xml.XDoc,Autofac.IContainer,MindTouch.Tasking.Result)">
            <summary>
            Perform startup configuration of a service instance.
            </summary>
            <remarks>
            Should not be manually invoked and should only be overridden if <see cref="M:MindTouch.Dream.DreamService.Start(MindTouch.Xml.XDoc,MindTouch.Tasking.Result)"/> isn't already overriden.
            </remarks>
            <param name="config">Service configuration.</param>
            <param name="serviceContainer">Service level IoC container</param>
            <param name="result">Synchronization handle for coroutine invocation.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> execution environment.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.Start(MindTouch.Xml.XDoc,MindTouch.Tasking.Result)">
            <summary>
            Perform startup configuration of a service instance.
            </summary>
            <remarks>
            Should not be manually invoked and should only be overridden if <see cref="M:MindTouch.Dream.DreamService.Start(MindTouch.Xml.XDoc,Autofac.IContainer,MindTouch.Tasking.Result)"/> isn't already overriden.
            </remarks>
            <param name="config">Service configuration.</param>
            <param name="result">Synchronization handle for coroutine invocation.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> execution environment.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.Stop(MindTouch.Tasking.Result)">
            <summary>
            Perform shutdown cleanup of a service instance.
            </summary>
            <remarks>
            Should not be manually invoked.
            </remarks>
            <param name="result">Synchronization handle for coroutine invocation.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/> execution environment.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.CreateService(System.String,System.String,MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.Plug})">
            <summary>
            Create a service as a child of the current service.
            </summary>
            <param name="path">Relative path to locate new service at.</param>
            <param name="sid">Service Identifier.</param>
            <param name="config">Service configuration.</param>
            <param name="result">The result instance to be returned by this methods.</param>
            <returns>Synchronization handle for this method's invocation.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.TryGetServiceLicense(MindTouch.Dream.XUri)">
            <summary>
            No-op hook for retrieving a service license string from its Service Identifier uri.
            </summary>
            <param name="sid">Service Identifier.</param>
            <returns>Service license.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.DetermineAccess(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage)">
            <summary>
            Determine the access appropriate for an incoming request.
            </summary>
            <param name="context">Request context.</param>
            <param name="request">Request message.</param>
            <returns>Access level for request.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.InvokeInServiceContext(System.String,System.String,System.Action)">
            <summary>
            Invoke an action in the context of a service feature.
            </summary>
            <remarks>
            Assumes that there exists a current <see cref="T:MindTouch.Dream.DreamContext"/> that belongs to a request to another feature of this service.
            </remarks>
            <param name="verb">Http verb.</param>
            <param name="path">Feature path.</param>
            <param name="handler">Action to perform in this context.</param>
            <returns>Exception thrown by handler or null.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.CheckResponseCache(System.Object)">
            <summary>
            Check the service's response cache.
            </summary>
            <param name="key">Key to check.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamService.RemoveResponseCache(System.Object)">
            <summary>
            Remove a key from the service's response cache
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:MindTouch.Dream.DreamService.EmptyResponseCache">
            <summary>
            Clear out the service's response cache
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamService.DetermineAccess(MindTouch.Dream.DreamContext,System.String)">
            <summary>
            Provides a hook for overriding what access level the current request should be granted.
            </summary>
            <param name="context">Request context.</param>
            <param name="key">Authorization key of request.</param>
            <returns>Access level granted to the request.</returns>
        </member>
        <member name="M:MindTouch.Dream.DreamService.Authenticate(MindTouch.Dream.DreamContext,MindTouch.Dream.DreamMessage,System.String@,System.String@)">
            <summary>
            Provides a hook for overriding default authentication of incoming user credentials.
            </summary>
            <remarks>
            Overriding methods should throw <see cref="T:MindTouch.Dream.DreamAbortException"/> if the user cannot be authenticated.
            </remarks>
            <param name="context">Request context.</param>
            <param name="message">Request message.</param>
            <param name="username">Request user.</param>
            <param name="password">User password.</param>
        </member>
        <member name="P:MindTouch.Dream.DreamService.AuthenticationRealm">
            <summary>
            Authentication realm for service (default: dream).
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Config">
            <summary>
            Service configuration.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Env">
            <summary>
            <see cref="T:MindTouch.Dream.Plug"/> for hosting environment.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Self">
            <summary>
            Service <see cref="T:MindTouch.Dream.Plug"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Owner">
            <summary>
            <see cref="T:MindTouch.Dream.Plug"/> for service that created this service.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Storage">
            <summary>
            <see cref="T:MindTouch.Dream.Plug"/> for Storage Service.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.PubSub">
            <summary>
            <see cref="T:MindTouch.Dream.Plug"/> for PubSub Service.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.SID">
            <summary>
            Service Identifier used to create this instance.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Blueprint">
            <summary>
            Service blueprint.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Cookies">
            <summary>
            Service cookie jar.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.ServiceLicense">
            <summary>
            Service license (if one exists).
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Prologues">
            <summary>
            Prologue request stages to be executed before a Feature is executed.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.Epilogues">
            <summary>
            Epilogue request stages to be executed after a Feature has completed.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.ExceptionTranslators">
            <summary>
            Exception translators given an opportunity to rewrite an exception before it is returned to the initiator of a request.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.InternalAccessKey">
            <summary>
            Access Key for using internal features.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.PrivateAccessKey">
            <summary>
            Access Key for using any feature.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.IsStarted">
            <summary>
            <see langword="True"/> if the service has been started.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamService.TimerFactory">
            <summary>
            <see cref="T:MindTouch.Tasking.TaskTimerFactory"/> associated with this service.
            </summary>
            <remarks>
            Governs the lifecycle of TaskTimers created during the lifecycle of the service.
            </remarks>
        </member>
        <member name="T:MindTouch.Dream.XUriChildMap`1">
            <summary>
            Provides a <see cref="T:MindTouch.Dream.XUri"/> map for matching child uri's of an input Uri.
            </summary>
            <remarks>
            This map is a counterpart to <see cref="T:MindTouch.Dream.XUriMap`1"/>, which matches the closest parent uri, instead of the children.
            Parent/Child relationships are determined by scheme/hostpot/path similarity.
            </remarks>
            <typeparam name="T">Type of object that is associated with each <see cref="T:MindTouch.Dream.XUri"/> entry</typeparam>
        </member>
        <member name="M:MindTouch.Dream.XUriChildMap`1.#ctor">
            <summary>
            Create a scheme-sensitive map.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.XUriChildMap`1.#ctor(System.Boolean)">
            <summary>
            Create a map.
            </summary>
            <param name="ignoreScheme"><see langword="True"/> if this map ignores scheme differences in matches.</param>
        </member>
        <member name="M:MindTouch.Dream.XUriChildMap`1.Add(MindTouch.Dream.XUri,`0)">
            <summary>
            Add a uri to the map.
            </summary>
            <param name="uri">Uri to add.</param>
            <param name="registrant">The reference object for the uri.</param>
        </member>
        <member name="M:MindTouch.Dream.XUriChildMap`1.AddRange(System.Collections.Generic.IEnumerable{MindTouch.Dream.XUri},`0)">
            <summary>
            Add a range of uri's for a single reference object
            </summary>
            <param name="uris">Uris to add.</param>
            <param name="registrant">The reference object for the uri.</param>
        </member>
        <member name="M:MindTouch.Dream.XUriChildMap`1.GetMatches(MindTouch.Dream.XUri)">
            <summary>
            Get all matching reference objects for uri.
            </summary>
            <param name="uri">Uri to find child uri's for.</param>
            <returns>Collection of reference objects.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriChildMap`1.GetMatches(MindTouch.Dream.XUri,System.Collections.Generic.ICollection{`0})">
            <summary>
            Get all matching reference objects for uri that are also in the filter list.
            </summary>
            <param name="uri">Uri to find child uri's for.</param>
            <param name="filter">Collection of of matchable reference objects.</param>
            <returns>Filtered collection of reference objects.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriChildMap`1.Clear">
            <summary>
            Clear the map.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUriChildMap`1.IgnoresScheme">
            <summary>
            <see langword="True"/> if this map ignores scheme differences in matches.
            </summary>
        </member>
        <member name="T:MindTouch.IO.MultiFileQueueStream">
            <summary>
            A record store with semantics for sequentially writing and retrieving records, similar to a queue, except that a read removes the
            head next record, but does not delete it until delete is called, allowing for transactional dequeuing of records.
            </summary>
            <remarks>
            This implementation is backed by a series of binary files, rolling over into a new file when the maxFileBytes constructor parameters is
            exceeded. A file in the sequence is deleted when all records within that file are marked as deleted, allowing more granular storage
            recovery than <see cref="T:MindTouch.IO.SingleFileQueueStream"/>. Exists primarily for use with <see cref="T:MindTouch.Collections.TransactionalQueue`1"/>. This
            class is not threadsafe.
            </remarks>
        </member>
        <member name="T:MindTouch.IO.IQueueStream">
            <summary>
            A record store with semantics for sequentially writing and retrieving records, similar to a queue, except that a read removes the
            head next record, but does not delete it until delete is called, allowing for transactional dequeuing of records.
            </summary>
            <seealso cref="T:MindTouch.IO.SingleFileQueueStream"/>
            <seealso cref="T:MindTouch.IO.MultiFileQueueStream"/>
        </member>
        <member name="M:MindTouch.IO.IQueueStream.AppendRecord(System.IO.Stream,System.Int64)">
            <summary>
            Append the given stream as a new record. It is assumed that the stream's position is set to the appropriate position.
            </summary>
            <param name="stream">A stream containng the record to be stored</param>
            <param name="length">Number of bytes to read from the stream</param>
        </member>
        <member name="M:MindTouch.IO.IQueueStream.DeleteRecord(MindTouch.IO.IQueueStreamHandle)">
            <summary>
            Permanently remove a record from the stream, identified by the <see cref="T:MindTouch.IO.IQueueStreamHandle"/> attached to the <see cref="T:MindTouch.IO.QueueStreamRecord"/>
            returned by <see cref="M:MindTouch.IO.IQueueStream.ReadNextRecord"/>.
            </summary>
            <param name="location">
            The handle attached to the <see cref="T:MindTouch.IO.QueueStreamRecord"/> returned by <see cref="M:MindTouch.IO.IQueueStream.ReadNextRecord"/>
            </param>
        </member>
        <member name="M:MindTouch.IO.IQueueStream.ReadNextRecord">
            <summary>
            Read the next unread record from the stream. Will return <see cref="F:MindTouch.IO.QueueStreamRecord.Empty"/> if there is no next record in the stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.IO.IQueueStream.Truncate">
            <summary>
            Truncate the QueueStream and drop all records.
            </summary>
        </member>
        <member name="P:MindTouch.IO.IQueueStream.UnreadCount">
            <summary>
            Total number of records unread.
            </summary>
        </member>
        <member name="M:MindTouch.IO.MultiFileQueueStream.#ctor(System.String)">
            <summary>
            Create a new instance using the default maximum file bytes
            </summary>
            <param name="storageRoot">Path to directory in which the queue streamm will keep its data</param>
        </member>
        <member name="M:MindTouch.IO.MultiFileQueueStream.#ctor(System.String,System.Int64)">
            <summary>
            Create a new instance 
            </summary>
            <param name="storageRoot">Path to directory in which the queue streamm will keep its data</param>
            <param name="maxFileBytes">maximum number of bytes to keep in any one data file. This affects space reclamation on fragmented queues</param>
        </member>
        <member name="M:MindTouch.IO.MultiFileQueueStream.Dispose">
            <summary>
            Dispose the instance per <see cref="T:System.IDisposable"/> pattern
            </summary>
        </member>
        <member name="M:MindTouch.IO.MultiFileQueueStream.AppendRecord(System.IO.Stream,System.Int64)">
            <summary>
            Append the given stream as a new record. It is assumed that the stream's position is set to the appropriate position.
            </summary>
            <param name="stream">A stream containng the record to be stored</param>
            <param name="length">Number of bytes to read from the stream</param>
        </member>
        <member name="M:MindTouch.IO.MultiFileQueueStream.ReadNextRecord">
            <summary>
            Read the next unread record from the stream. Will return <see cref="F:MindTouch.IO.QueueStreamRecord.Empty"/> if there is no next record in the stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.IO.MultiFileQueueStream.Truncate">
            <summary>
            Truncate the QueueStream and drop all records.
            </summary>
        </member>
        <member name="M:MindTouch.IO.MultiFileQueueStream.DeleteRecord(MindTouch.IO.IQueueStreamHandle)">
            <summary>
            Permanently remove a record from the stream, identified by the <see cref="T:MindTouch.IO.IQueueStreamHandle"/> attached to the <see cref="T:MindTouch.IO.QueueStreamRecord"/>
            returned by <see cref="M:MindTouch.IO.MultiFileQueueStream.ReadNextRecord"/>.
            </summary>
            <param name="location">The handle attached to the <see cref="T:MindTouch.IO.QueueStreamRecord"/>
            returned by <see cref="M:MindTouch.IO.MultiFileQueueStream.ReadNextRecord"/></param>
        </member>
        <member name="P:MindTouch.IO.MultiFileQueueStream.UnreadCount">
            <summary>
            Count of all records not yet read in current session
            </summary>
            <remarks>
            Records that are read but not yet deleted are not reflected in Unreadcount
            </remarks>
        </member>
        <member name="T:MindTouch.IO.IQueueStreamHandle">
            <summary>
            Handle for a record returned by <see cref="T:MindTouch.IO.IQueueStream"/> for later deletion of that record. The handle has not behavior
            associated with it, but serves simply as an identifier for the originating stream.
            </summary>
        </member>
        <member name="T:MindTouch.IO.QueueStreamRecord">
            <summary>
            Value wrapper for Records returned by <see cref="M:MindTouch.IO.IQueueStream.ReadNextRecord"/> 
            </summary>
        </member>
        <member name="F:MindTouch.IO.QueueStreamRecord.Empty">
            <summary>
            Empty record instance
            </summary>
        </member>
        <member name="F:MindTouch.IO.QueueStreamRecord.Stream">
            <summary>
            Stream of the record
            </summary>
        </member>
        <member name="F:MindTouch.IO.QueueStreamRecord.Handle">
            <summary>
            Handle of record used by <see cref="M:MindTouch.IO.IQueueStream.DeleteRecord(MindTouch.IO.IQueueStreamHandle)"/> to identify the record to delete
            </summary>
            <remarks>
            The Handle is a separate object so that the caller does not have to hold on to a reference to the record stream between use of the stream
            deletion of the record
            </remarks>
        </member>
        <member name="M:MindTouch.IO.QueueStreamRecord.#ctor(System.IO.Stream,MindTouch.IO.IQueueStreamHandle)">
            <summary>
            Create a new record
            </summary>
            <remarks>
            Only used by implementors of <see cref="T:MindTouch.IO.IQueueStream"/>
            </remarks>
            <param name="stream">A stream containing the bytes of only this record. Should be positioned at the 0 byte</param>
            <param name="handle">An implementation of <see cref="T:MindTouch.IO.IQueueStreamHandle"/> used by the creator of this instance to track the record in question</param>
        </member>
        <member name="M:MindTouch.IO.QueueStreamRecord.op_Equality(MindTouch.IO.QueueStreamRecord,MindTouch.IO.QueueStreamRecord)">
            <summary>
            This class provides a custom == operator in order to support simple <see cref="M:System.ValueType.Equals(System.Object)"/> comparison, which is not
            supported by default by structs
            </summary>
            <param name="a">left hand side of equality comparison</param>
            <param name="b">right hand side of equality comparison</param>
            <returns><see langword="true"/> if both records contain the same values</returns>
        </member>
        <member name="M:MindTouch.IO.QueueStreamRecord.op_Inequality(MindTouch.IO.QueueStreamRecord,MindTouch.IO.QueueStreamRecord)">
            <summary>
            This class provides a custom == operator in order to support simple <see cref="M:System.ValueType.Equals(System.Object)"/> negation, which is not
            supported by default by structs
            </summary>
            <param name="a">left hand side of equality comparison</param>
            <param name="b">right hand side of equality comparison</param>
            <returns><see langword="true"/> if both records contain different values</returns>
        </member>
        <member name="T:MindTouch.IO.SingleFileQueueStream">
            <summary>
            A record store with semantics for sequentially writing and retrieving records, similar to a queue, except that a read removes the
            head next record, but does not delete it until delete is called, allowing for transactional dequeuing of records.
            </summary>
            <remarks>
            This implementation is backed by a single binary stream, which keeps growing until all records are marked as deleted, at which time
            the stream is truncacted. Exists primarily for use with <see cref="T:MindTouch.Collections.TransactionalQueue`1"/>. This class is not threadsafe.
            </remarks>
        </member>
        <member name="M:MindTouch.IO.SingleFileQueueStream.#ctor(System.String)">
            <summary>
            Create from file path. File will be opened for exclusive write and closed and disposed when the instance is disposed
            </summary>
            <param name="path">File path</param>
        </member>
        <member name="M:MindTouch.IO.SingleFileQueueStream.#ctor(System.IO.Stream)">
            <summary>
            Create from an existing stream and the stream will be disposed when the instance is disposed.
            </summary>
            <param name="stream">A <see cref="T:System.IO.Stream"/> that supports reading, writing and seeking</param>
        </member>
        <member name="M:MindTouch.IO.SingleFileQueueStream.Dispose">
            <summary>
            Dispose the instance per <see cref="T:System.IDisposable"/> pattern
            </summary>
        </member>
        <member name="M:MindTouch.IO.SingleFileQueueStream.AppendRecord(System.IO.Stream,System.Int64)">
            <summary>
            Append the given stream as a new record. It is assumed that the stream's position is set to the appropriate position.
            </summary>
            <param name="stream">A stream containng the record to be stored</param>
            <param name="length">Number of bytes to read from the stream</param>
        </member>
        <member name="M:MindTouch.IO.SingleFileQueueStream.DeleteRecord(MindTouch.IO.IQueueStreamHandle)">
            <summary>
            Permanently remove a record from the stream, identified by the <see cref="T:MindTouch.IO.IQueueStreamHandle"/> attached to the <see cref="T:MindTouch.IO.QueueStreamRecord"/>
            returned by <see cref="M:MindTouch.IO.SingleFileQueueStream.ReadNextRecord"/>.
            </summary>
            <param name="location">The handle returned by ReadNextRecord</param>
        </member>
        <member name="M:MindTouch.IO.SingleFileQueueStream.ReadNextRecord">
            <summary>
            Read the next unread record from the stream. Will return <see cref="F:MindTouch.IO.QueueStreamRecord.Empty"/> if there is no next record in the stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.IO.SingleFileQueueStream.Truncate">
            <summary>
            Truncate the QueueStream and drop all records.
            </summary>
        </member>
        <member name="P:MindTouch.IO.SingleFileQueueStream.UnreadCount">
            <summary>
            Count of all records not yet read in current session
            </summary>
            <remarks>
            Records that are read but not yet deleted are not reflected in Unreadcount
            </remarks>
        </member>
        <member name="T:MindTouch.IO.StreamUtil">
            <summary>
            A set of static and extension methods to simplify common stream opreations and add <see cref="T:MindTouch.Tasking.Result"/> based asynchronous operations
            </summary>
        </member>
        <member name="F:MindTouch.IO.StreamUtil.BUFFER_SIZE">
            <summary>
            Common size for internal byte buffer used for Stream operations
            </summary>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.Write(System.IO.Stream,System.Text.Encoding,System.String,System.Object[])">
            <summary>
            Write a string to <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="stream">Target <see cref="T:System.IO.Stream"/></param>
            <param name="encoding">Encoding to use to convert the string to bytes</param>
            <param name="text">Regular string or composite format string to write to the <see cref="T:System.IO.Stream"/></param>
            <param name="args">An System.Object array containing zero or more objects to format.</param>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.Write(System.IO.Stream,System.Byte[])">
            <summary>
            Write an entire buffer to a <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="stream">Target <see cref="T:System.IO.Stream"/></param>
            <param name="buffer">An array of bytes to write to the <see cref="T:System.IO.Stream"/></param>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.IsStreamMemorized(System.IO.Stream)">
            <summary>
            Determine whether a <see cref="T:System.IO.Stream"/> contents are in memory
            </summary>
            <param name="stream">Target <see cref="T:System.IO.Stream"/></param>
            <returns><see langword="true"/> If the <see cref="T:System.IO.Stream"/> contents are in memory</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.Read(System.IO.Stream,System.Byte[],System.Int32,System.Int32,MindTouch.Tasking.Result{System.Int32})">
            <summary>
            Asynchronously read from a <see cref="T:System.IO.Stream"/>
            </summary>
            <param name="stream">Source <see cref="T:System.IO.Stream"/></param>
            <param name="buffer">Byte array to fill from the source</param>
            <param name="offset">Position in buffer to start writing to</param>
            <param name="count">Number of bytes to read from the <see cref="T:System.IO.Stream"/></param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/> instance to be returned by the call.</param>
            <returns>Synchronization handle for the number of bytes read.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.Write(System.IO.Stream,System.Byte[],System.Int32,System.Int32,MindTouch.Tasking.Result)">
            <summary>
            Asynchronously write to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">Target <see cref="T:System.IO.Stream"/>.</param>
            <param name="buffer">Byte array to write to the target.</param>
            <param name="offset">Position in buffer to start reading from.</param>
            <param name="count">Number of bytes to read from buffer.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/> instance to be returned by the call.</param>
            <returns>Synchronization handle for the number of bytes read.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.CopyTo(System.IO.Stream,System.IO.Stream,System.Int64)">
            <summary>
            Synchronous copying of one stream to another.
            </summary>
            <param name="source">Source <see cref="T:System.IO.Stream"/>.</param>
            <param name="target">Target <see cref="T:System.IO.Stream"/>.</param>
            <param name="length">Number of bytes to copy from source to target.</param>
            <returns>Actual bytes copied.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.CopyTo(System.IO.Stream,System.IO.Stream,System.Int64,MindTouch.Tasking.Result{System.Int64})">
            <summary>
            Asynchronous copying of one stream to another.
            </summary>
            <param name="source">Source <see cref="T:System.IO.Stream"/>.</param>
            <param name="target">Target <see cref="T:System.IO.Stream"/>.</param>
            <param name="length">Number of bytes to copy from source to target.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/> instance to be returned by the call.</param>
            <returns>Synchronization handle for the number of bytes copied.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.CopyTo(System.IO.Stream,System.IO.Stream[],System.Int64,MindTouch.Tasking.Result{System.Nullable{System.Int64}[]})">
            <summary>
            Asynchrounously copy a <see cref="T:System.IO.Stream"/> to several targets
            </summary>
            <param name="source">Source <see cref="T:System.IO.Stream"/></param>
            <param name="targets">Array of target <see cref="T:System.IO.Stream"/> objects</param>
            <param name="length">Number of bytes to copy from source to targets</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/> instance to be returned by the call.</param>
            <returns>Synchronization handle for the number of bytes copied to each target.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.CopyToFile(System.IO.Stream,System.String,System.Int64)">
            <summary>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </summary>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.Pad(System.IO.Stream,System.Int64,System.Byte,MindTouch.Tasking.Result)">
            <summary>
            Asychronously Pad a stream with a sequence of bytes
            </summary>
            <param name="stream">Target <see cref="T:System.IO.Stream"/></param>
            <param name="count">Number of bytes to pad</param>
            <param name="value">Byte value to use for padding</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/> instance to be returned by the call.</param>
            <returns>Synchronization handle for completion of padding action.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.ComputeHash(System.IO.Stream)">
            <summary>
            Compute the MD5 hash.
            </summary>
            <param name="stream">Stream to hash.</param>
            <returns>MD5 hash.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.ComputeHashString(System.IO.Stream)">
            <summary>
            Compute the MD5 hash string.
            </summary>
            <param name="stream">Stream to hash.</param>
            <returns>MD5 hash string.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.ReadBytes(System.IO.Stream,System.Int64)">
            <summary>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </summary>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.ToMemoryStream(System.IO.Stream,System.Int64,MindTouch.Tasking.Result{System.IO.MemoryStream})">
            <summary>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </summary>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.ToChunkedMemoryStream(System.IO.Stream,System.Int64,MindTouch.Tasking.Result{MindTouch.IO.ChunkedMemoryStream})">
            <summary>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </summary>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.DetectEncoding(System.IO.Stream)">
            <summary>
            Detect stream encoding.
            </summary>
            <param name="stream">Stream to examine</param>
            <returns>Encoding type detected or null</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.DupStream(System.IO.Stream,System.Int64,System.Int32)">
            <summary>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </summary>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.FileOpenExclusive(System.String)">
            <summary>
            Try to open a file for exclusive read/write access
            </summary>
            <param name="filename">Path to file</param>
            <returns>A <see cref="T:System.IO.Stream"/> for the opened file, or <see langword="null"/> on failure to open the file.</returns>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.CreatePipe(System.IO.Stream@,System.IO.Stream@)">
            <summary>
            Create a pipe
            </summary>
            <param name="writer">The writer endpoint of the pipe</param>
            <param name="reader">The reader endpoint of the pipe</param>
        </member>
        <member name="M:MindTouch.IO.StreamUtil.CreatePipe(System.Int32,System.IO.Stream@,System.IO.Stream@)">
            <summary>
            Create a pipe
            </summary>
            <param name="size">The size of the pipe buffer</param>
            <param name="writer">The writer endpoint of the pipe</param>
            <param name="reader">The reader endpoint of the pipe</param>
        </member>
        <member name="T:MindTouch.IO.TrimmingStringReader">
            <summary>
            Provides a <see cref="T:System.IO.TextReader"/> that automatically trims leading and trailing waitspace as it reads.
            </summary>
        </member>
        <member name="M:MindTouch.IO.TrimmingStringReader.#ctor(System.String)">
            <summary>
            Create a new text reader.
            </summary>
            <param name="text">Text to read.</param>
        </member>
        <member name="M:MindTouch.IO.TrimmingStringReader.Dispose(System.Boolean)">
            <summary>
            Override of <see cref="M:System.IO.TextReader.Dispose(System.Boolean)"/> that also clears out internal string storage.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:MindTouch.IO.TrimmingStringReader.Peek">
            <summary>
            Reads the next character without changing the state of the reader or the character source.
            Returns the next available character without actually reading it from the input stream.
            </summary>
            <returns>
            An integer representing the next character to be read, or -1 if no more characters are available or the stream does not support seeking.
            </returns>
        </member>
        <member name="M:MindTouch.IO.TrimmingStringReader.Read">
            <summary>
            Reads the next character from the input stream and advances the character position by one character.
            </summary>
            <returns>
            The next character from the input stream, or -1 if no more characters are available. The default implementation returns -1.
            </returns>
        </member>
        <member name="M:MindTouch.IO.TrimmingStringReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a maximum of count characters from the current stream and writes the data to buffer, beginning at index.
            </summary>
            <param name="buffer">
            When this method returns, contains the specified character array with the values between index and (index + count - 1)
            replaced by the characters read from the current source.
            </param>
            <param name="index">The place in buffer at which to begin writing.</param>
            <param name="count">
            The maximum number of characters to read. If the end of the stream is reached before count of characters is read into buffer,
            the current method returns.
            </param>
            <returns>
            The number of characters that have been read. The number will be less than or equal to count, depending on whether the data is 
            available within the stream. This method returns zero if called when no more characters are left to read.
            </returns>
        </member>
        <member name="M:MindTouch.IO.TrimmingStringReader.ReadLine">
            <summary>
            Reads a line of characters from the current stream and returns the data as a string.
            </summary>
            <returns>The next line from the input stream, or null if all characters have been read.</returns>
        </member>
        <member name="M:MindTouch.IO.TrimmingStringReader.ReadToEnd">
            <summary>
            Reads all characters from the current position to the end of the TextReader and returns them as one string.
            </summary>
            <returns>A string containing all characters from the current position to the end of the TextReader.</returns>
        </member>
        <member name="T:MindTouch.IO.TrimmingTextReader">
            <summary>
            Provides a wrapping reader around any <see cref="T:System.IO.TextReader"/> implementation to trim leading and trailing whitespace.
            </summary>
        </member>
        <member name="M:MindTouch.IO.TrimmingTextReader.#ctor(System.IO.TextReader)">
            <summary>
            Wrap a <see cref="T:System.IO.TextReader"/> with the trimming reader.
            </summary>
            <param name="original">Original text reader instance.</param>
        </member>
        <member name="M:MindTouch.IO.TrimmingTextReader.Dispose(System.Boolean)">
            <summary>
            Override of <see cref="M:System.IO.TextReader.Dispose(System.Boolean)"/> that also disposes any wrapped <see cref="T:System.IO.TextReader"/> instance.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:MindTouch.IO.TrimmingTextReader.Peek">
            <summary>
            Reads the next character without changing the state of the reader or the character source.
            Returns the next available character without actually reading it from the input stream.
            </summary>
            <returns>
            An integer representing the next character to be read, or -1 if no more characters are available or the stream does not support seeking.
            </returns>
        </member>
        <member name="M:MindTouch.IO.TrimmingTextReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads a buffer of characters from the reader.
            </summary>
            <param name="buffer">Character buffer to fill.</param>
            <param name="index">Index into buffer to start filling at.</param>
            <param name="count">Maximum number of characters to read.</param>
            <returns>Number of characters actually read. 0 if the reader has reached the end of the underlying reader.</returns>
        </member>
        <member name="M:MindTouch.IO.TrimmingTextReader.Read">
            <summary>
            Reads the next character from the input stream and advances the character position by one character.
            </summary>
            <returns>
            The next character from the input stream, or -1 if no more characters are available. The default implementation returns -1.
            </returns>
        </member>
        <member name="M:MindTouch.IO.TrimmingTextReader.ReadToEnd">
            <summary>
            Reads all characters from the current position to the end of the TextReader and returns them as one string.
            </summary>
            <returns>A string containing all characters from the current position to the end of the TextReader.</returns>
        </member>
        <member name="M:MindTouch.IO.TrimmingTextReader.ReadLine">
            <summary>
            Reads a line of characters from the current stream and returns the data as a string.
            </summary>
            <returns>The next line from the input stream, or null if all characters have been read.</returns>
        </member>
        <member name="T:MindTouch.IO.ChunkedMemoryStream">
            <summary>
            Provides an altnerate implementation of <see cref="T:System.IO.MemoryStream"/> that keeps its internal data buffers in several chunks to avoid
            memory fragmenation.
            </summary>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.#ctor">
            <summary>
            Create a writeable and resizable memory stream
            </summary>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.#ctor(System.Int32)">
            <summary>
            Create a writeable and resizable memory stream with an initial capacity
            </summary>
            <param name="capacity">Minimum of available bytes pre-allocated.</param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.#ctor(System.Byte[])">
            <summary>
            Initializes a new non-resizable instance based on the specified byte array.
            </summary>
            <remarks>
            When the memory stream is initialized with a byte buffer, the following behavior should be excepted:
            <list type="bullet">
            <item>The stream cannot be resized.</item>
            <item>The stream is writeable.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer"/> throws <see cref="T:System.UnauthorizedAccessException"/>.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.SetLength(System.Int64)"/> throws <see cref="T:System.NotSupportedException"/> if trying to make the stream
            larger than the initial buffer size.</item>
            <item>Attempting to change <see cref="P:MindTouch.IO.ChunkedMemoryStream.Capacity"/> throws <see cref="T:System.NotSupportedException"/>.</item>
            </list>
            </remarks>
            <param name="buffer">Backing buffer to use.</param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initializes a new non-resizable instance based on the specified byte array with the <see cref="P:MindTouch.IO.ChunkedMemoryStream.CanWrite"/> property set as specified.
            </summary>
            <remarks>
            When the memory stream is initialized with this constructor, the following behavior should be excepted:
            <list type="bullet">
            <item>The stream cannot be resized.</item>
            <item>The stream may be writeable, as indicated by <see cref="P:MindTouch.IO.ChunkedMemoryStream.CanWrite"/>.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer"/> throws <see cref="T:System.UnauthorizedAccessException"/>.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.SetLength(System.Int64)"/> throws <see cref="T:System.NotSupportedException"/> if trying to make the stream
            larger than the initial buffer size.</item>
            <item>Attempting to change <see cref="P:MindTouch.IO.ChunkedMemoryStream.Capacity"/> throws <see cref="T:System.NotSupportedException"/>.</item>
            </list>
            </remarks>
            <param name="buffer"> The array of unsigned bytes from which to create the current stream.</param>
            <param name="writable">The setting of the <see cref="P:MindTouch.IO.ChunkedMemoryStream.CanWrite"/> property, which determines whether the stream supports writing.</param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initializes a new non-resizable instance based on the specified region (index) of a byte array.
            </summary>
            <remarks>
            When the memory stream is initialized with a byte buffer, the following behavior should be excepted:
            <list type="bullet">
            <item>The stream cannot be resized.</item>
            <item>The stream is writeable.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer"/> throws <see cref="T:System.UnauthorizedAccessException"/>.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.SetLength(System.Int64)"/> throws <see cref="T:System.NotSupportedException"/> if trying to make the stream
            larger than the initial buffer size.</item>
            <item>Attempting to change <see cref="P:MindTouch.IO.ChunkedMemoryStream.Capacity"/> throws <see cref="T:System.NotSupportedException"/>.</item>
            </list>
            </remarks>
            <param name="buffer"> The array of unsigned bytes from which to create the current stream.</param>
            <param name="index">The index into buffer at which the stream begins.</param>
            <param name="count">The length of the stream in bytes.</param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance based on the specified region of a byte array, with the <see cref="P:MindTouch.IO.ChunkedMemoryStream.CanWrite"/> 
            property set as specified, and the ability to call <see cref="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer"/> set as specified.
            </summary>
            <remarks>
            When the memory stream is initialized with a byte buffer, the following behavior should be excepted:
            <list type="bullet">
            <item>The stream cannot be resized.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer"/> throws <see cref="T:System.UnauthorizedAccessException"/>.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.SetLength(System.Int64)"/> throws <see cref="T:System.NotSupportedException"/> if trying to make the stream
            larger than the initial buffer size.</item>
            <item>Attempting to change <see cref="P:MindTouch.IO.ChunkedMemoryStream.Capacity"/> throws <see cref="T:System.NotSupportedException"/>.</item>
            </list>
            </remarks>
            <param name="buffer"> The array of unsigned bytes from which to create the current stream.</param>
            <param name="index">The index into buffer at which the stream begins.</param>
            <param name="count">The length of the stream in bytes.</param>
            <param name="writable">The setting of the <see cref="P:MindTouch.IO.ChunkedMemoryStream.CanWrite"/> property, which determines whether the stream supports writing.</param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance based on the specified region of a byte array, with the <see cref="P:MindTouch.IO.ChunkedMemoryStream.CanWrite"/> 
            property set as specified, and the ability to call <see cref="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer"/> set as specified.
            </summary>
            
            <remarks>
            When the memory stream is initialized with a byte buffer, the following behavior should be excepted:
            <list type="bullet">
            <item>The stream cannot be resized.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer"/> throws <see cref="T:System.UnauthorizedAccessException"/>.</item>
            <item><see cref="M:MindTouch.IO.ChunkedMemoryStream.SetLength(System.Int64)"/> throws <see cref="T:System.NotSupportedException"/> if trying to make the stream
            larger than the initial buffer size.</item>
            <item>Attempting to change <see cref="P:MindTouch.IO.ChunkedMemoryStream.Capacity"/> throws <see cref="T:System.NotSupportedException"/>.</item>
            </list>
            </remarks>
            <param name="buffer"> The array of unsigned bytes from which to create the current stream.</param>
            <param name="index">The index into buffer at which the stream begins.</param>
            <param name="count">The length of the stream in bytes.</param>
            <param name="writable">The setting of the <see cref="P:MindTouch.IO.ChunkedMemoryStream.CanWrite"/> property, which determines whether the stream supports writing.</param>
            <param name="publiclyVisible">
            <see langword="True"/> to enable <see cref="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer"/>, which returns the unsigned byte array from which
            the stream was created; otherwise, false.
            </param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.Flush">
            <summary>
            This override of <see cref="M:System.IO.Stream.Flush"/> is a no-op, except for the case that the stream has been closed in which case it
            will throw an <see cref="T:System.ObjectDisposedException"/>. 
            </summary>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.GetBuffer">
            <summary>
            Retrieve the internal chunked buffer representation as a single byte array. Only works if buffer was created with publicly
            visible option, otherwise throws <see cref="T:System.UnauthorizedAccessException"/>.
            </summary>
            <returns>A byte array of all stream bytes.</returns>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
            <param name="buffer">
            An array of bytes. When this method returns, the buffer contains the specified byte array with the values between offset 
            and (offset + count - 1) replaced by the bytes read from the current source.
            </param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes 
            are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="offset">A byte offset relative to the origin parameter.</param>
            <param name="origin">A value of type System.IO.SeekOrigin indicating the reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the current stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes.</param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.ToArray">
            <summary>
            Similar to GetBuffer, but creates its output by reading from the internal representation, rather than
            consolidating the chunks into a single buffer first.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
            <param name="buffer">An array of bytes. This method copies count bytes from buffer to the current stream.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.WriteTo(System.IO.Stream)">
            <summary>
            Write the entire memory stream to another stream.
            </summary>
            <param name="stream">Target stream.</param>
        </member>
        <member name="M:MindTouch.IO.ChunkedMemoryStream.Dispose(System.Boolean)">
            <summary>
            Dispose of the stream's held resource and call the base class <see cref="M:System.IO.Stream.Dispose(System.Boolean)"/>.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:MindTouch.IO.ChunkedMemoryStream.CanRead">
            <summary>
            <see langword="True"/> if the stream is not closed.
            </summary>
        </member>
        <member name="P:MindTouch.IO.ChunkedMemoryStream.CanSeek">
            <summary>
            <see langword="True"/> if the stream is not closed.
            </summary>
        </member>
        <member name="P:MindTouch.IO.ChunkedMemoryStream.CanWrite">
            <summary>
            <see langword="True"/> if the stream is not closed and isn't a read-only stream.
            </summary>
        </member>
        <member name="P:MindTouch.IO.ChunkedMemoryStream.Capacity">
            <summary>
            Change the capacity of the stream. If the stream was created from a byte array, this will throw <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:MindTouch.IO.ChunkedMemoryStream.Length">
            <summary>
            Length of stream.
            </summary>
        </member>
        <member name="P:MindTouch.IO.ChunkedMemoryStream.Position">
            <summary>
            Current position in the stream.
            </summary>
        </member>
        <member name="T:MindTouch.IO.TrimmingTextReaderUtil">
            <summary>
            Provides an extension method for <see cref="T:System.IO.TextReader"/> instances to determine whether a given reader is a
            trimming reader.
            </summary>
        </member>
        <member name="M:MindTouch.IO.TrimmingTextReaderUtil.IsTrimmingReader(System.IO.TextReader)">
            <summary>
            Determine whether a <see cref="T:System.IO.TextReader"/> is a trimming reader.
            </summary>
            <param name="reader">Source reader.</param>
            <returns><see langword="True"/> if </returns>
        </member>
        <member name="T:MindTouch.Dream.IPlugEndpoint">
            <summary>
            Provides a handler contract for registering a <see cref="T:MindTouch.Dream.Plug"/> request invocation endpoint.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.IPlugEndpoint.GetScoreWithNormalizedUri(MindTouch.Dream.XUri,MindTouch.Dream.XUri@)">
            <summary>
            Called by <see cref="T:MindTouch.Dream.Plug"/> to let the endpoint determine whether it wants to handle the endpoint and to what level of priority.
            </summary>
            <remarks>
            Multiple endpoints can be candidates for handling an invocation. <see cref="T:MindTouch.Dream.Plug"/> uses the returned score to determine which
            endpoint to dispatch to.
            </remarks>
            <param name="uri">Uri to match.</param>
            <param name="normalized">Output of the uri normalized into the form local to the endpoint.</param>
            <returns>
            Returning 0 or less indicates that the endpoint does not handle the uri, while <see cref="F:System.Int32.MaxValue"/>
            is usually used to force interception. Generally, a handler should use <see cref="M:MindTouch.Dream.XUri.Similarity(MindTouch.Dream.XUri)"/> to match
            an incoming uri to it's handled uri.
            </returns>
        </member>
        <member name="M:MindTouch.Dream.IPlugEndpoint.Invoke(MindTouch.Dream.Plug,System.String,MindTouch.Dream.XUri,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Handle the invocation of a plug.
            </summary>
            <remarks>
            <para>It is the responsibility of the caller to close the request, so Invoke should never close the request.</para>
            <para>This method is a coroutine and should never be invoked directly.</para>
            </remarks>
            <param name="plug">Plug to handle.</param>
            <param name="verb">Invocation verb.</param>
            <param name="uri">Invocation uri.</param>
            <param name="request">Request message.</param>
            <param name="response">
            The <see cref="T:MindTouch.Tasking.Result`1"/> instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Security.Cryptography.CryptoEx">
            <summary>
            Static utility class containing extension methods related to Cryptography.
            </summary>
        </member>
        <member name="M:MindTouch.Security.Cryptography.CryptoEx.VerifySignature(System.Byte[],System.String,System.Security.Cryptography.RSACryptoServiceProvider)">
            <summary>
            Verify a data payload against a signature.
            </summary>
            <param name="data">Data to be verified.</param>
            <param name="signature">Signature string.</param>
            <param name="rsa">The Crypto Service Provider to be used.</param>
            <returns><see langword="True"/> if the data is signed by the signature.</returns>
        </member>
        <member name="M:MindTouch.Security.Cryptography.CryptoEx.SignData(System.Byte[],System.Security.Cryptography.RSACryptoServiceProvider)">
            <summary>
            Create a crytographic signature for a block of data.
            </summary>
            <param name="data">The data to be signed.</param>
            <param name="rsa">The Crypto Service Provider to be used.</param>
            <returns>The signature string for the data block.</returns>
        </member>
        <member name="T:MindTouch.Security.Cryptography.RSAUtil">
            <summary>
            Static utility class containing factory methods for creation <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider"/> instances.
            </summary>
        </member>
        <member name="M:MindTouch.Security.Cryptography.RSAUtil.ProviderFromFile(System.String)">
            <summary>
            Create a <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider"/>.
            </summary>
            <param name="path">Path to the file containing the provider data.</param>
            <returns>New Crypto service Provider.</returns>
        </member>
        <member name="M:MindTouch.Security.Cryptography.RSAUtil.ProviderFrom(System.Byte[])">
            <summary>
            Create a <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider"/>.
            </summary>
            <param name="bytes">Data block to create provider from.</param>
            <returns>New Crypto service Provider.</returns>
        </member>
        <member name="M:MindTouch.Security.Cryptography.RSAUtil.ProviderFrom(System.Reflection.Assembly)">
            <summary>
            Create a <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider"/>.
            </summary>
            <param name="assembly">Assembly, whose public key is to be used to create a provider.</param>
            <returns>New Crypto service Provider.</returns>
        </member>
        <member name="M:MindTouch.Security.Cryptography.RSAUtil.ProviderFrom(System.IO.BinaryReader)">
            <summary>
            Create a <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider"/>.
            </summary>
            <param name="reader">Reader containing provider data.</param>
            <returns>New Crypto service Provider.</returns>
        </member>
        <member name="T:MindTouch.Tasking.AResultEx">
            <summary>
            A static utility class containing helpers and extension methods for working with <see cref="T:MindTouch.Tasking.AResult"/> based objects.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.AResultEx.Join``1(System.Collections.Generic.IEnumerable{``0},MindTouch.Tasking.Result)">
            <summary>
            Get a result object for joining the completion of a sequence of <see cref="T:MindTouch.Tasking.Result"/> instances.
            </summary>
            <remarks>
            This extension is useful for executing some action once all Results complete, but does not provide the Results waited on.
            If access to the finished is needed, they need to be manually captured in the synchronization handler.
            </remarks>
            <typeparam name="TResult">Type of the result enumerable to operate on.</typeparam>
            <param name="enumerable">Enumerable of <see cref="T:MindTouch.Tasking.AResult"/> instances to wait on.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/> instance this method will return.</param>
            <returns>The passed in <see cref="T:MindTouch.Tasking.Result"/> object to be used as a synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.AResultEx.Alt``1(MindTouch.Tasking.Result{``0}[],MindTouch.Tasking.Result{``0},System.Action{``0})">
            <summary>
            Get a result object to capture the first completion in an sequence of alternative <see cref="T:MindTouch.Tasking.Result`1"/> objects. 
            </summary>
            <typeparam name="T">Type of the result value</typeparam>
            <param name="alternatives">Array of alternative <see cref="T:MindTouch.Tasking.Result`1"/> objects.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/> instance this method will return.</param>
            <param name="discard">Callback for alternatives that complete after the first completion, and did not get cancelled.</param>
            <returns>The passed in <see cref="T:MindTouch.Tasking.Result"/> object to be used as a synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.AResultEx.Alt(MindTouch.Tasking.Result[],MindTouch.Tasking.Result)">
            <summary>
            Get a result object to capture the first completion in an sequence of alternative <see cref="T:MindTouch.Tasking.Result"/> objects. 
            </summary>
            <param name="alternatives">Array of alternative <see cref="T:MindTouch.Tasking.Result"/> objects.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/> instance this method will return.</param>
            <returns>The passed in <see cref="T:MindTouch.Tasking.Result"/> object to be used as a synchronization handle.</returns>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineMissingResultException">
            <summary>
            Thrown by <see cref="T:MindTouch.Tasking.Coroutine"/> if the called method completes without error but does not have a result set.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineUtil">
            <summary>
            Provides Extension methods on <see cref="T:MindTouch.Tasking.AResult"/>, <see cref="T:MindTouch.Tasking.Result"/> and <see cref="T:MindTouch.Tasking.Result`1"/> for working with them in
            the context of <see cref="T:MindTouch.Tasking.Coroutine"/> execution.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.Catch``1(``0)">
            <summary>
            Sets the current coroutine's behavior to catch its exception so that the invoking context can examine the exception, rather than it
            bubbling up the Coroutine stack.
            </summary>
            <remarks>
            The <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> analog to calling a method with a try/catch around it.
            </remarks>
            <typeparam name="T">Type of AResult derivative value.</typeparam>
            <param name="result">Coroutine synchronization handle.</param>
            <returns>Coroutine synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.Catch(MindTouch.Tasking.Result)">
            <summary>
            Sets the current's coroutine behavior to catch its exception so that the invoking context can examine the exception, rather than it
            bubbling up the Coroutine stack.
            </summary>
            <remarks>
            The <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> analog to calling a method with a try/catch around it.
            </remarks>
            <param name="result">Coroutine synchronization handle.</param>
            <returns>Coroutine synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.Catch``1(MindTouch.Tasking.Result{``0})">
            <summary>
            Sets the current coroutine's behavior to catch its exception so that the invoking context can examine the exception, rather than it
            bubbling up the Coroutine stack.
            </summary>
            <remarks>
            The <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> analog to calling a method with a try/catch around it.
            </remarks>
            <typeparam name="T">Type of result's value.</typeparam>
            <param name="result">Coroutine synchronization handle.</param>
            <returns>Coroutine synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.CatchAndLog(MindTouch.Tasking.AResult,log4net.ILog)">
            <summary>
            Sets the current coroutine's behavior to catch any exception thrown by a coroutine and log the exception,
            but continue with the caller's context.
            </summary>
            <param name="result">Coroutine synchronization handle.</param>
            <param name="log">Logger instance to use for the exception logging.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.CatchAndLog(MindTouch.Tasking.AResult,log4net.ILog,System.String)">
            <summary>
            Sets the current coroutine's behavior to catch any exception thrown by a coroutine and log the exception,
            but continue with the caller's context.
            </summary>
            <param name="result">Coroutine synchronization handle.</param>
            <param name="log">Logger instance to use for the exception logging.</param>
            <param name="message">Additional message to log along with exception</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.Set``1(MindTouch.Tasking.Result{``0},System.Action{``0})">
            <summary>
            Sets a callback for capturing the result's value.
            </summary>
            <remarks>
            Using the callback allows the value to be captured into a local variable rather than having to define
            a result instance before invoking the coroutine that would only be used to extract the value from after invocation.</remarks>
            <typeparam name="T">Type of result's value.</typeparam>
            <param name="result">Coroutine synchronization handle.</param>
            <param name="callback">Callback action to invoke on successful completion of the synchronization handle.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.Join``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Yield execution of the current coroutine untill all the results have completed.
            </summary>
            <typeparam name="TResult">Type of the result value.</typeparam>
            <param name="list">List of result instances to yield execution to.</param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.GetCoroutineInfo(System.Exception)">
            <summary>
            Extract the coroutine context from an exception that was thrown as part of an invoke.
            </summary>
            <param name="exception">Exception to examine.</param>
            <returns>The coroutine instance if the exception was thrown in the context of a coroutine, <see langword="null"/> otherwise.</returns>
        </member>
        <member name="M:MindTouch.Tasking.CoroutineUtil.GetCoroutineStackTrace(System.Exception)">
            <summary>
            Get the coroutine invocation stack trace, including exception stack traces, and values of inner exceptions' coroutine stack traces.
            </summary>
            <param name="exception">Exception to examine.</param>
            <returns>
            A string representation of stack trace if the exception was thrown in the context of a coroutine, <see langword="null"/> otherwise.
            </returns>
        </member>
        <member name="T:MindTouch.Tasking.IYield">
            <summary>
            Provides the iterator interface used by <see cref="T:MindTouch.Tasking.Coroutine"/> to execute methods as coroutines.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.IYield.CanContinueImmediately(MindTouch.Tasking.IContinuation)">
            <summary>
            <see langword="True"/> If the co-routine can continue immediately, rather than be enqueued in a worker pool.
            </summary>
            <param name="continuation">The continuation to use to continue to execute the iterator.</param>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Tasking.IYield.Exception">
            <summary>
            Current iterator has an exception.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.IContinuation">
            <summary>
            Provides the interface for an iterator value that can continue coroutine execution.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.IContinuation.Continue">
            <summary>
            Continue to execute the current coroutine.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.AResult">
            <summary>
            Provides a base class for a synchronization handle for asychronous processing.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult.DEFAULT_TIMEOUT">
            <summary>
            The default result timeout is 10 minutes.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult._pendingCounter">
            <summary>
            Total number of pending results in process.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult._state">
            <summary>
            The current state of the Result.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult._env">
            <summary>
            The task environment to execute the callbacks in.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.AResult.#ctor(System.TimeSpan,MindTouch.Tasking.TaskEnv)">
            <summary>
            Base class constructor.
            </summary>
            <param name="timeout">Result timeout.</param>
            <param name="env">Result environment.</param>
        </member>
        <member name="M:MindTouch.Tasking.AResult.CallCleanupCanceled">
            <summary>
            Unimplemented hook for clean-up being canceled.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.AResult.CallCleanupError(System.Exception)">
            <summary>
            Unimplemented hook for performing clean-up on error.
            </summary>
            <param name="exception">Exception causing the clean-up event.</param>
        </member>
        <member name="M:MindTouch.Tasking.AResult.Confirm">
            <summary>
            Confirm that the result does not have an exception. If it has a an exception, it will be rethrown by this call.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.AResult.Throw(System.Exception)">
            <summary>
            Set an exception on the result.
            </summary>
            <param name="exception">The exception instance to set on the result.</param>
        </member>
        <member name="M:MindTouch.Tasking.AResult.Cancel">
            <summary>
            Mark the handle as canceled, to notify the pending action that execution should be aborted.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.AResult.ConfirmCancel">
            <summary>
            Signal that the executing end has acknowledged the cancel action of the invokee.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.AResult.EnsureFinished">
            <summary>
            Behaves as a no-op if the result has finished, otherwise throws <see cref="T:System.InvalidProgramException"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if <see cref="P:MindTouch.Tasking.AResult.HasFinished"/> is <see langword="True"/>.</exception>
        </member>
        <member name="M:MindTouch.Tasking.AResult.SetStateError(System.Exception)">
            <summary>
            Try to set the state to <see cref="F:MindTouch.Tasking.AResult.ResultState.Error"/>.
            </summary>
            <param name="exception">The exception to set as the error.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the result is already in a completed state.</exception>
        </member>
        <member name="M:MindTouch.Tasking.AResult.SetStateCancel(System.Exception)">
            <summary>
            Try to set the state to <see cref="F:MindTouch.Tasking.AResult.ResultState.Cancel"/>.
            </summary>
            <param name="exception">The cancelation exception.</param>
            <returns><see langword="True"/> if state was set to cancel, <see langword="False"/> if the current state didn't allow cancellation or if the state was already <see cref="F:MindTouch.Tasking.AResult.ResultState.Cancel"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.AResult.SetStateConfirmCancel">
            <summary>
            Try to set the state to <see cref="F:MindTouch.Tasking.AResult.ResultState.ConfirmedCancel"/>. Will throw <see cref="T:System.InvalidOperationException"/> if the state transition is invalid.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if state transition is invalid.</exception>
        </member>
        <member name="M:MindTouch.Tasking.AResult.CallCompletion">
            <summary>
            Cancels any internal timer and calls the completion.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.AResult.Block">
            <summary>
            Block on the current thread until the result completes either successfully or with an exception.
            </summary>
            <remarks>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </remarks>
            <returns>The current result instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.AResult.Block(System.Threading.AutoResetEvent)">
            <summary>
            Block on the current thread until the result completes either successfully or with an exception.
            </summary>
            <remarks>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </remarks>
            <param name="signal">The reset event to use for the blocking operation.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Tasking.AResult.Wait">
            <summary>
            Block on the current thread until the result completes. Will throw if an exception triggers completion.
            </summary>
            <remarks>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </remarks>
        </member>
        <member name="M:MindTouch.Tasking.AResult.Wait(System.Threading.AutoResetEvent)">
            <summary>
            Block on the current thread until the result completes. Will throw if an exception triggers completion.
            </summary>
            <param name="signal">The reset event to use for the blocking operation.</param>
            <remarks>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </remarks>
        </member>
        <member name="M:MindTouch.Tasking.AResult.WhenDone(System.Action{MindTouch.Tasking.AResult})">
            <summary>
            Register a callback handler that is invoked when the result completes.
            </summary>
            <param name="handler">Completion callback.</param>
            <returns>The current result instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.AResult.WhenDone``1(System.Action{``0})">
            <summary>
            Register a callback for result completion.
            </summary>
            <typeparam name="TResult">Type of result</typeparam>
            <param name="completion">Completion callback.</param>
            <returns>The result instance this method was called on.</returns>
        </member>
        <member name="P:MindTouch.Tasking.AResult.PendingCounter">
            <summary>
            Returns the number of pending AResult instances in the process.
            A pending AResult instance has a continuation, but has not been signaled yet.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.ValueType">
            <summary>
            Type of value that the result encapsulates (if any).
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.UntypedValue">
            <summary>
            Accessor to encapsulated value as an object, if set.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.HasCleanup">
            <summary>
            <see langword="True"/> if the result has a clean-up handler.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.HasException">
            <summary>
            The result has an exception set on it.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.HasValue">
            <summary>
            The result has a value set on it.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.HasTimedOut">
            <summary>
            The result has failed to complete because it timed out.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.IsCanceled">
            <summary>
            The result will not complete because it was canceled.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.HasFinished">
            <summary>
            The action using the result as a synchronization handle has completed.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.Timeout">
            <summary>
            Amount of time this result will wait before it has to be signaled to succeed.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.Env">
            <summary>
            The environment in which this result is being used.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.Exception">
            <summary>
            The exception set on the result if <see cref="P:MindTouch.Tasking.AResult.HasException"/> is <see langword="True"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.AResult.HasCompletion">
            <summary>
            <see langword="True"/> if the Result has a completion callback.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.AResult.ResultState">
            <summary>
            Possible states a result can be in.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult.ResultState.New">
            <summary>
            New result.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult.ResultState.Value">
            <summary>
            Result has a value (i.e. completed successfully).
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult.ResultState.Error">
            <summary>
            Result finished with an error.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult.ResultState.Cancel">
            <summary>
            Result has been asked to be canceled.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult.ResultState.ConfirmedCancel">
            <summary>
            Executing Result handle holder has confirmed that the cancel was accepted.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.AResult.ResultState.ObservedCancel">
            <summary>
            A canceled Result has been observed as being canceled.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.Result">
            <summary>
            A value-less implemenation of <see cref="T:MindTouch.Tasking.AResult"/>. Use <see cref="T:MindTouch.Tasking.Result`1"/> if the invoked action needs to return a value.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Result.#ctor">
            <summary>
            Create a new instance with the default timeout.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Result.#ctor(System.TimeSpan)">
            <summary>
            Create a new instance with a timeout.
            </summary>
            <param name="timeout">Time to wait for completion before setting completion as a <see cref="T:System.TimeoutException"/>.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result.#ctor(MindTouch.Tasking.TaskEnv)">
            <summary>
            Create a new instance with a given environment.
            </summary>
            <param name="env">Environment to use for the result invocation.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result.#ctor(System.TimeSpan,MindTouch.Tasking.TaskEnv)">
            <summary>
            Create a new instance with a given environment and timeout
            </summary>
            <param name="timeout">Time to wait for completion before setting completion as a <see cref="T:System.TimeoutException"/>.</param>
            <param name="env">Environment to use for the result invocation.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result.WithCleanup(System.Action{MindTouch.Tasking.Result})">
            <summary>
            Register a clean-up callback to allow disposal of <see cref="T:System.IDisposable"/> resources used in invocation.
            </summary>
            <remarks>
            Doing clean-up in <see cref="M:MindTouch.Tasking.Result.WhenDone(System.Action{MindTouch.Tasking.Result})"/> is not safe, since the completion
            may have been triggered by a cancel, while the the invokee has not acknowledged the cancel and is still using the 
            resource.
            </remarks>
            <param name="callback">Callback action on completion of the invokee.</param>
            <returns>The current result index.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Result.CallCleanupCanceled">
            <summary>
            Try to call the clean-up callback on result cancelation.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Result.CallCleanupError(System.Exception)">
            <summary>
            Try to call the clean-up callback on result error.
            </summary>
            <param name="exception">Exception instance that caused the error state transition.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result.Block">
            <summary>
            Block on the current thread until the result completes either successfully or with an exception.
            </summary>
            <remarks>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </remarks>
            <returns>The current result instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Result.Block(System.Threading.AutoResetEvent)">
            <summary>
            Block on the current thread until the result completes either successfully or with an exception.
            </summary>
            <remarks>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </remarks>
            <param name="signal">The reset event to use for the blocking operation.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Tasking.Result.WhenDone(System.Action{MindTouch.Tasking.Result})">
            <summary>
            Register a callback handler that is invoked when the result completes.
            </summary>
            <param name="handler">Completion callback.</param>
            <returns>The current result instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Result.WhenDone(System.Action,System.Action{System.Exception})">
            <summary>
            Register a success and an error callback handler for invocation depending on result completion.
            </summary>
            <param name="success">Callback to be called on successful completion.</param>
            <param name="error">Callback to be called if the result completes due to an exception.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Tasking.Result.Return">
            <summary>
            Set successful completion on the result. Will throw <see cref="T:System.InvalidOperationException"/> if the result can not transition into
            the successful completion state.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Result.TryReturn">
            <summary>
            Try to set successful completion on the result. Unlike <see cref="M:MindTouch.Tasking.Result.Return"/> and <see cref="M:MindTouch.Tasking.Result.Return(MindTouch.Tasking.Result)"/>
            does not throw.
            </summary>
            <returns><see langword="False"/> if the state transition failed.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Result.Return(MindTouch.Tasking.Result)">
            <summary>
            Use another <see cref="T:MindTouch.Tasking.Result"/>'s completion to trigger completion of this instance.
            </summary>
            <param name="result">The result instance to slave to.</param>
        </member>
        <member name="P:MindTouch.Tasking.Result.ValueType">
            <summary>
            Type of value that the result encapsulates (if any).
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Result.UntypedValue">
            <summary>
            This method will throw <see cref="T:System.InvalidOperationException"/>, because this implementation of <see cref="T:MindTouch.Tasking.AResult"/> does not have a value
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Result.HasCleanup">
            <summary>
            <see langword="True"/> if the instance has a clean-up callback.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.Result`1">
            <summary>
            An implemenation of <see cref="T:MindTouch.Tasking.AResult"/> that has a value on successful completion.
            Use <see cref="T:MindTouch.Tasking.Result"/> if no return value is desired.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.#ctor">
            <summary>
            Create a new instance with the default timeout.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.#ctor(System.TimeSpan)">
            <summary>
            Create a new instance with a timeout.
            </summary>
            <param name="timeout">Time to wait for completion before setting completion as a <see cref="T:System.TimeoutException"/>.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.#ctor(MindTouch.Tasking.TaskEnv)">
            <summary>
            Create a new instance with a given environment.
            </summary>
            <param name="env">Environment to use for the result invocation.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.#ctor(System.TimeSpan,MindTouch.Tasking.TaskEnv)">
            <summary>
            Create a new instance with a given environment and timeout
            </summary>
            <param name="timeout">Time to wait for completion before setting completion as a <see cref="T:System.TimeoutException"/>.</param>
            <param name="env">Environment to use for the result invocation.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.WithCleanup(System.Action{MindTouch.Tasking.Result{`0}})">
            <summary>
            Register a clean-up callback to allow disposal of <see cref="T:System.IDisposable"/> resources used in invocation.
            </summary>
            <remarks>
            Doing clean-up in <see cref="M:MindTouch.Tasking.Result`1.WhenDone(System.Action{MindTouch.Tasking.Result{`0}})"/> is not safe, since the completion
            may have been triggered by a cancel, while the the invokee has not acknowledged the cancel and is still using the 
            resource.
            </remarks>
            <param name="callback">Callback action on completion of the invokee.</param>
            <returns>The current result index.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.CallCleanupCanceled">
            <summary>
            Try to call the clean-up callback on result cancelation.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.CallCleanupError(System.Exception)">
            <summary>
            Try to call the clean-up callback on result error.
            </summary>
            <param name="exception">Exception instance that caused the error state transition.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.Block">
            <summary>
            Block on the current thread until the result completes either successfully or with an exception.
            </summary>
            <remarks>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </remarks>
            <returns>The current result instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.Block(System.Threading.AutoResetEvent)">
            <summary>
            Block on the current thread until the result completes either successfully or with an exception.
            </summary>
            <remarks>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </remarks>
            <param name="signal">The reset event to use for the blocking operation.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.Wait">
            <summary>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.Wait(System.Threading.AutoResetEvent)">
            <summary>
            WARNING: This method is thread-blocking. Please avoid using it if possible.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.WhenDone(System.Action{MindTouch.Tasking.Result{`0}})">
            <summary>
            Register a callback handler that is invoked when the result completes.
            </summary>
            <param name="handler">Completion callback.</param>
            <returns>The current result instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.WhenDone(System.Action{`0},System.Action{System.Exception})">
            <summary>
            Register a success and an error callback handler for invocation depending on result completion.
            </summary>
            <param name="success">Callback to be called on successful completion.</param>
            <param name="error">Callback to be called if the result completes due to an exception.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.Return(`0)">
            <summary>
            Set successful completion on the result. Will throw <see cref="T:System.InvalidOperationException"/> if the result can not transition into
            the successful completion state.
            </summary>
            <param name="value">Value to return.</param>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.TryReturn(`0)">
            <summary>
            Try to set successful completion on the result. Unlike <see cref="M:MindTouch.Tasking.Result`1.Return(`0)"/> and <see cref="M:MindTouch.Tasking.Result`1.Return(MindTouch.Tasking.Result{`0})"/>
            does not throw.
            </summary>
            <param name="value">Value to return.</param>
            <returns><see langword="False"/> if the state transition failed.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Result`1.Return(MindTouch.Tasking.Result{`0})">
            <summary>
            Use another <see cref="T:MindTouch.Tasking.Result"/>'s completion to trigger completion of this instance.
            </summary>
            <param name="result">The result instance to slave to.</param>
        </member>
        <member name="P:MindTouch.Tasking.Result`1.ValueType">
            <summary>
            Type of value that the result encapsulates (if any).
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Result`1.UntypedValue">
            <summary>
            Accessor to encapsulated value as an object, if set.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Result`1.HasCleanup">
            <summary>
            <see langword="True"/> if the instance has a clean-up callback.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Result`1.Value">
            <summary>
            The value set on the result on successful completion.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.CanceledException">
            <summary>
            Set as <see cref="P:MindTouch.Tasking.AResult.Exception"/> on a result when <see cref="M:MindTouch.Tasking.AResult.Cancel"/> is called.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.TaskEnv">
            <summary>
            Environment propagated along with a task as it transitions between threads.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.New(MindTouch.Threading.IDispatchQueue)">
            <summary>
            Create a new environment.
            </summary>
            <param name="dispatchQueue">Dispatch queue to use for the environment.</param>
            <returns>A new <see cref="T:MindTouch.Tasking.TaskEnv"/> instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Clone(MindTouch.Threading.IDispatchQueue)">
            <summary>
            Clone the current task environment with a provided dispatch queue.
            </summary>
            <param name="dispatchQueue">Dispatch queue to use for the environment.</param>
            <returns>A new <see cref="T:MindTouch.Tasking.TaskEnv"/> instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.New(MindTouch.Threading.IDispatchQueue,MindTouch.Tasking.TaskTimerFactory)">
            <summary>
            Create a new environment.
            </summary>
            <param name="dispatchQueue">Dispatch queue to use for the environment.</param>
            <param name="taskTimerFactory"><see cref="T:MindTouch.Dream.TaskTimer"/> factory to use for the environment.</param>
            <returns>A new <see cref="T:MindTouch.Tasking.TaskEnv"/> instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Clone(MindTouch.Threading.IDispatchQueue,MindTouch.Tasking.TaskTimerFactory)">
            <summary>
             Clone the current task environment with a provided dispatch queue and task timer factory.
            </summary>
            <param name="dispatchQueue">Dispatch queue to use for the environment.</param>
            <param name="taskTimerFactory"><see cref="T:MindTouch.Dream.TaskTimer"/> factory to use for the environment.</param>
            <returns>A new <see cref="T:MindTouch.Tasking.TaskEnv"/> instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.New(MindTouch.Tasking.TaskTimerFactory)">
            <summary>
            Create a new environment.
            </summary>
            <param name="taskTimerFactory"><see cref="T:MindTouch.Dream.TaskTimer"/> factory to use for the environment.</param>
            <returns>A new <see cref="T:MindTouch.Tasking.TaskEnv"/> instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Clone(MindTouch.Tasking.TaskTimerFactory)">
            <summary>
             Clone the current task environment with a task timer factory.
            </summary>
            <param name="taskTimerFactory"><see cref="T:MindTouch.Dream.TaskTimer"/> factory to use for the environment.</param>
            <returns>A new <see cref="T:MindTouch.Tasking.TaskEnv"/> instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.New">
            <summary>
            Create a new environment.
            </summary>
            <returns>A new <see cref="T:MindTouch.Tasking.TaskEnv"/> instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Clone">
            <summary>
            Clone the current task environment.
            </summary>
            <returns>A new <see cref="T:MindTouch.Tasking.TaskEnv"/> instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.ExecuteNew(System.Action)">
            <summary>
            Execute an action in a new environment.
            </summary>
            <param name="handler">Action to execute.</param>
            <returns><see langword="null"/> if the handler was executed sucessfully, the captured exception otherwise.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.ExecuteNew(System.Action,MindTouch.Tasking.TaskTimerFactory)">
            <summary>
            Execute an action in a new environment.
            </summary>
            <param name="handler">Action to execute.</param>
            <param name="timerFactory">The <see cref="T:MindTouch.Dream.TaskTimer"/> factory to use in the execution environment.</param>
            <returns><see langword="null"/> if the handler was executed sucessfully, the captured exception otherwise.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.GetState``1">
            <summary>
            Retrieve a typed state variable.
            </summary>
            <typeparam name="T">Type of the state variable.</typeparam>
            <returns>Value for the type, or type default if the variable is not set.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.SetState``1(``0)">
            <summary>
            Set a typed state variable.
            </summary>
            <typeparam name="T">Type of the state variable.</typeparam>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.RemoveState``1(``0)">
            <summary>
            Remove a typed state variable
            </summary>
            <remarks>Throws <see cref="T:System.InvalidOperationException"/> if the given value is different from the one stored for the given type.</remarks>
            <typeparam name="T">Type of the state variable.</typeparam>
            <param name="value">Value to remove.</param>
            <returns><see langword="False"/> if the value was not found.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the given value is different from the one stored for the given type.</exception>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.GetState``1(System.String)">
            <summary>
            Retrieve a keyed state variable.
            </summary>
            <typeparam name="T">Type of the state variable.</typeparam>
            <param name="key">Key the variable is indexed under.</param>
            <returns>Value for the type, or type default if the variable is not set.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.SetState``1(System.String,``0)">
            <summary>
            Set a keyed state variable.
            </summary>
            <typeparam name="T">Type of the state variable.</typeparam>
            <param name="key">Key the variable is indexed under.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.GetState``1(System.Object)">
            <summary>
            Retrieve a keyed state variable.
            </summary>
            <typeparam name="T">Type of the state variable.</typeparam>
            <param name="key">Key the variable is indexed under.</param>
            <returns>Value for the type, or type default if the variable is not set.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.RemoveState(System.Object)">
            <summary>
            Rmove a keyed state variable.
            </summary>
            <param name="key">Key the variable is indexed under.</param>
            <returns><see langword="False"/> if the key was not found.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Acquire">
            <summary>
            Acquire the environment, prevent it from being disposed.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Release">
            <summary>
            Release the environment, possibly making it eligble for disposal.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Reset">
            <summary>
            Reset all aquisitions and dispose the environment.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.InvokeNow(System.Action)">
            <summary>
            Invoke an action in place.
            </summary>
            <param name="handler">Action to invoke.</param>
            <returns><see langword="null"/> if the handler was executed sucessfully, the captured exception otherwise.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Invoke(System.Action)">
            <summary>
            Invoke a zero arg action.
            </summary>
            <param name="handler">Action to invoke.</param>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Invoke``1(System.Action{``0},``0)">
            <summary>
            Invoke a one argument action.
            </summary>
            <typeparam name="T1">Type of first argument.</typeparam>
            <param name="handler">Action to invoke.</param>
            <param name="arg1">First argument.</param>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Invoke``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Invoke a two argument action.
            </summary>
            <typeparam name="T1">Type of first argument.</typeparam>
            <typeparam name="T2">Type of second argument.</typeparam>
            <param name="handler">Action to invoke.</param>
            <param name="arg1">First argument.</param>
            <param name="arg2">Second argument.</param>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.Invoke``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Invoke a three argument action.
            </summary>
            <typeparam name="T1">Type of first argument.</typeparam>
            <typeparam name="T2">Type of second argument.</typeparam>
            <typeparam name="T3">Type of third argument.</typeparam>
            <param name="handler">Action to invoke.</param>
            <param name="arg1">First argument.</param>
            <param name="arg2">Second argument.</param>
            <param name="arg3">Third argument.</param>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.MakeAction(System.Action)">
            <summary>
            Wrap a method call, delegate or lambda in an environment for later invocation.
            </summary>
            <param name="action">Call to wrap.</param>
            <returns>Handler for invocation in the environment.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.MakeAction(System.Action,MindTouch.Tasking.Result)">
            <summary>
            Wrap a method call, delegate or lambda in an environment for later invocation.
            </summary>
            <param name="action">Call to wrap.</param>
            <param name="result">Synchronization handle for the returned handler.</param>
            <returns>Handler for invocation in the environment.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.MakeAction``1(System.Func{``0})">
            <summary>
            Wrap a method call, delegate or lambda in an environment for later invocation.
            </summary>
            <typeparam name="T">Return type of wrapped call.</typeparam>
            <param name="func">Call to wrap.</param>
            <returns>Handler for invocation in the environment.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskEnv.MakeAction``1(System.Func{``0},MindTouch.Tasking.Result{``0})">
            <summary>
            Wrap a method call, delegate or lambda in an environment for later invocation.
            </summary>
            <typeparam name="T">Return type of wrapped call.</typeparam>
            <param name="func">Call to wrap.</param>
            <param name="result">Synchronization handle for the returned handler.</param>
            <returns>Handler for invocation in the environment.</returns>
        </member>
        <member name="P:MindTouch.Tasking.TaskEnv.Instantaneous">
            <summary>
            Get the instantaneous execution environment.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskEnv.None">
            <summary>
            Get the environment-less marker value.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskEnv.CurrentOrNull">
            <summary>
            Get the current task environment. Returns <see langword="null"/> if there is no current environment.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskEnv.Current">
            <summary>
            Get the current task environment. Will create a new task environment if none exists.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskEnv.DispatchQueue">
            <summary>
            Dispatch queue of the environment.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskEnv.TimerFactory">
            <summary>
            <see cref="T:MindTouch.Dream.TaskTimer"/> factory used by the environment.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.TaskTimerFactory">
            <summary>
            Provides a factory for creating new <see cref="T:MindTouch.Dream.TaskTimer"/> instances whose lifetime is goverened by the creating factory lifetime.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.TaskTimerFactory.Create(System.Object)">
            <summary>
            Create a new factory.
            </summary>
            <param name="owner">
            The entity that this factory belongs to. Owner is used for usage tracking and is stored as a weak reference, which means
            that the factory will not prevent the owner from being garbage collected.
            </param>
            <returns>New factory instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskTimerFactory.GetStatistics">
            <summary>
            Get statistical information about all active factories.
            </summary>
            <returns>A statics object.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskTimerFactory.ShutdownAll">
            <summary>
            Globally shut down all task timers and factories.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.TaskTimerFactory.New(System.Action{MindTouch.Dream.TaskTimer},System.Object)">
            <summary>
            Create a new timer.
            </summary>
            <param name="handler">The action to invoke when the timer fires.</param>
            <param name="state">A state object to associate with the timer.</param>
            <returns>New timer instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskTimerFactory.New(System.DateTime,System.Action{MindTouch.Dream.TaskTimer},System.Object,MindTouch.Tasking.TaskEnv)">
            <summary>
            Create a new timer and set its fire time.
            </summary>
            <param name="when">Absolute time when the timer should fire.</param>
            <param name="handler">The action to invoke when the timer fires.</param>
            <param name="state">A state object to associate with the timer.</param>
            <param name="env">The environment in which the timer should fire.</param>
            <returns>New timer instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskTimerFactory.New(System.TimeSpan,System.Action{MindTouch.Dream.TaskTimer},System.Object,MindTouch.Tasking.TaskEnv)">
            <summary>
            Create a new timer and set its fire time.
            </summary>
            <param name="when">Relateive time from now until when the timer should fire.</param>
            <param name="handler">The action to invoke when the timer fires.</param>
            <param name="state">A state object to associate with the timer.</param>
            <param name="env">The environment in which the timer should fire.</param>
            <returns>New timer instance.</returns>
        </member>
        <member name="M:MindTouch.Tasking.TaskTimerFactory.Shutdown">
            <summary>
            Shut down all timers related to this factory.
            </summary>
            <remarks>
            Warning: this call is thread-blocking. It will try to execute all pending timers immediately, but
            will wait for each timer to complete.
            </remarks>
        </member>
        <member name="M:MindTouch.Tasking.TaskTimerFactory.Dispose">
            <summary>
            Shutdown the factory.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.Default">
            <summary>
            The global default factory.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.Current">
            <summary>
            The currently active factory.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.Factories">
            <summary>
            All active factories.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.Owner">
            <summary>
            Weak-reference accessor to factory owner (i.e. the factory will not stop the owner from being garbage collected.)
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.OwnerType">
            <summary>
            Type of owner object. This value will remain populated even if the actual owner is garbage collected.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.IsAbandoned">
            <summary>
            Determine whether the owner was garbage collected. In proper usage, the owner should always have shut down the
            factory before it went away.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.NextMaintenance">
            <summary>
            Time until the next <see cref="T:MindTouch.Dream.TaskTimer"/> maintenance.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.Pending">
            <summary>
            A collection of all timers currently pending.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.TaskTimerFactory.Next">
            <summary>
            The timer that will fire next.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.TaskTimerFactory.TaskTimerStatistics">
            <summary>
            Statistical information about all <see cref="T:MindTouch.Tasking.TaskTimerFactory"/>.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.TaskTimerFactory.TaskTimerStatistics.PendingTimers">
            <summary>
            Total number of <see cref="T:MindTouch.Dream.TaskTimer"/> instances pending.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.TaskTimerFactory.TaskTimerStatistics.QueuedTimers">
            <summary>
            Total number of <see cref="T:MindTouch.Dream.TaskTimer"/> instances queued.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.TaskTimerFactory.TaskTimerStatistics.Retries">
            <summary>
            Total number of retries that have occured when trying to change <see cref="T:MindTouch.Dream.TaskTimer"/> states.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.TaskTimerFactory.TaskTimerStatistics.Last">
            <summary>
            Last factory tick.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.TaskTimerFactory.TaskTimerStatistics.Counter">
            <summary>
            Total factory ticks.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.HandlerUtil">
            <summary>
            Extension methods to wrap a <see cref="T:System.Func`1"/> or <see cref="T:System.Action"/> with an <see cref="T:MindTouch.Tasking.TaskEnv"/> for use in invocation.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.HandlerUtil.WithEnv``1(System.Func{``0},MindTouch.Tasking.TaskEnv)">
            <summary>
            Wrap a <see cref="T:System.Func`1"/> with an execution environment.
            </summary>
            <remarks>
            This method is deprecated. Use <see cref="M:MindTouch.Tasking.TaskEnv.MakeAction``1(System.Func{``0})"/> instead.
            </remarks>
            <typeparam name="T">Return value of func.</typeparam>
            <param name="handler">The func to wrap.</param>
            <param name="env">The environment to wrap with.</param>
            <returns>An action that when invoked will execute the func in the given environment.</returns>
        </member>
        <member name="M:MindTouch.Tasking.HandlerUtil.WithEnv``1(System.Func{``0},MindTouch.Tasking.TaskEnv,MindTouch.Tasking.Result{``0})">
            <summary>
            Wrap a <see cref="T:System.Func`1"/> with an execution environment.
            </summary>
            <remarks>
            This method is deprecated. Use <see cref="M:MindTouch.Tasking.TaskEnv.MakeAction``1(System.Func{``0},MindTouch.Tasking.Result{``0})"/> instead.
            </remarks>
            <typeparam name="T">Return value of func.</typeparam>
            <param name="handler">The func to wrap.</param>
            <param name="env">The environment to wrap with.</param>
            <param name="result">Synchronization handle for the returned action.</param>
            <returns>An action that when invoked will execute the func in the given environment.</returns>
        </member>
        <member name="M:MindTouch.Tasking.HandlerUtil.WithEnv(System.Action,MindTouch.Tasking.TaskEnv)">
            <summary>
            Wrap a <see cref="T:System.Action"/> with an execution environment.
            </summary>
            <remarks>
            This method is deprecated. Use <see cref="M:MindTouch.Tasking.TaskEnv.MakeAction(System.Action)"/> instead.
            </remarks>
            <param name="handler">The action to wrap.</param>
            <param name="env">The environment to wrap with.</param>
            <returns>An action that when invoked will execute the action in the given environment.</returns>
        </member>
        <member name="M:MindTouch.Tasking.HandlerUtil.WithEnv(System.Action,MindTouch.Tasking.TaskEnv,MindTouch.Tasking.Result)">
            <summary>
            Wrap a <see cref="T:System.Action"/> with an execution environment.
            </summary>
            <remarks>
            This method is deprecated. Use <see cref="M:MindTouch.Tasking.TaskEnv.MakeAction(System.Action,MindTouch.Tasking.Result)"/> instead.
            </remarks>
            <param name="handler">The action to wrap.</param>
            <param name="env">The environment to wrap with.</param>
            <param name="result">Synchronization handle for the returned action.</param>
            <returns>An action that when invoked will execute the action in the given environment.</returns>
        </member>
        <member name="T:MindTouch.Threading.ElasticPriorityThreadPool">
            <summary>
            ElasticPriorityThreadPool provides a thread pool that can have a variable number of threads going from a minimum number of reserved
            threads to a maximum number of parallel threads.
            </summary>
            <remarks>
            The threads are obtained from the DispatchThreadScheduler and shared across all other clients of the DispatchThreadScheduler.
            Obtained threads are released automatically if the thread pool is idle for long enough.  Reserved threads are never released.
            </remarks>
        </member>
        <member name="T:MindTouch.Threading.IDispatchHost">
            <summary>
            IDispatchHost interface provides methods for requesting new work-items and processing them.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.IDispatchHost.RequestWorkItem(MindTouch.Threading.DispatchThread,MindTouch.Tasking.Result{MindTouch.Threading.DispatchWorkItem})">
            <summary>
            Invoked by an assigned DispatchThread when request a new work-item.
            </summary>
            <param name="thread">DispatchThread requesting the work-item.</param>
            <param name="result">Result object on which to submit the work-item.</param>
        </member>
        <member name="M:MindTouch.Threading.IDispatchHost.IncreaseThreadCount(System.String)">
            <summary>
            Invoked by DispatchThreadScheduler to indicate that dispatch host should request additional threads if needed.
            </summary>
            <param name="reason">Reason for invoking this method (used for debug output).</param>
        </member>
        <member name="M:MindTouch.Threading.IDispatchHost.MaintainThreadCount(System.String)">
            <summary>
            Invoked by DispatchThreadScheduler to indicate that dispatch host should neither request new threads, nor release threads that are in use.
            </summary>
            <param name="reason">Reason for invoking this method (used for debug output).</param>
        </member>
        <member name="M:MindTouch.Threading.IDispatchHost.DecreaseThreadCount(System.String)">
            <summary>
            Invoked by DispatchThreadScheduler to indicate that dispatch host should release threads if possible.
            </summary>
            <param name="reason">Reason for invoking this method (used for debug output).</param>
        </member>
        <member name="P:MindTouch.Threading.IDispatchHost.PendingWorkItemCount">
            <summary>
            Number of items that are waiting to be dispatched.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.IDispatchHost.MinThreadCount">
            <summary>
            Minimum number of threads used by the dispatch host.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.IDispatchHost.MaxThreadCount">
            <summary>
            Maximum number of threads used by the dispatch host.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.IDispatchHost.ThreadCount">
            <summary>
            Current number of threads used by the dispatch host.
            </summary>
        </member>
        <member name="F:MindTouch.Threading.ElasticPriorityThreadPool.MAX_RESERVED_THREADS">
            <summary>
            Maximum number of threads that can be reserved by a single instance.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.ElasticPriorityThreadPool.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new ElasticPriorityThreadPool instance.
            </summary>
            <param name="minReservedThreads">Minium number of threads to reserve for the thread pool.</param>
            <param name="maxParallelThreads">Maximum number of parallel threads used by the thread pool.</param>
            <param name="maxPriority">Maximum priority number (inclusive upper bound).</param>
            <exception cref="T:MindTouch.InsufficientResourcesException">The ElasticPriorityThreadPool instance was unable to obtain the minimum reserved threads.</exception>
        </member>
        <member name="M:MindTouch.Threading.ElasticPriorityThreadPool.Dispose">
            <summary>
            Shutdown the ElasticThreadPool instance.  This method blocks until all pending items have finished processing.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.ElasticPriorityThreadPool.ToString">
            <summary>
            Convert the dispatch queue into a string.
            </summary>
            <returns>String.</returns>
        </member>
        <member name="P:MindTouch.Threading.ElasticPriorityThreadPool.MinReservedThreads">
            <summary>
            Number of minimum reserved threads.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.ElasticPriorityThreadPool.MaxParallelThreads">
            <summary>
            Number of maxium parallel threads.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.ElasticPriorityThreadPool.ThreadCount">
            <summary>
            Number of threads currently used.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.ElasticPriorityThreadPool.WorkItemCount">
            <summary>
            Number of items pending for execution.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.ElasticPriorityThreadPool.MaxPriority">
            <summary>
            Max priority for work items.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.ElasticPriorityThreadPool.Item(System.Int32)">
            <summary>
            Accessor for prioritized dispatch queue.
            </summary>
            <param name="priority">Dispatch queue priority level (between 0 and MaxPriority).</param>
            <returns>Prioritized dispatch queue.</returns>
        </member>
        <member name="T:MindTouch.Threading.IDispatchQueue">
            <summary>
            IDispatchQueue interface provides methods for submitting work-items to execute on a thread.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.IDispatchQueue.QueueWorkItem(System.Action)">
            <summary>
            Adds a work-item to the thread pool.  Depending on the implementation, this method may block the invoker
            or throw an exception if the thread pool cannot accept more items.
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
        </member>
        <member name="M:MindTouch.Threading.IDispatchQueue.TryQueueWorkItem(System.Action)">
            <summary>
            Attempts to add a work-item to the thread pool.
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
            <returns>Returns true if the item was successfully added to the thread pool.</returns>
        </member>
        <member name="T:MindTouch.InsufficientResourcesException">
            <summary>
            Thrown by <see cref="T:MindTouch.Threading.ElasticThreadPool"/> and <see cref="T:MindTouch.Threading.ElasticPriorityThreadPool"/> on instantiation, if the requested min
            reserved threads cannot be acquired.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.PlugHandler">
            <summary>
            Provides a contract for intercepting and modifying <see cref="T:MindTouch.Dream.Plug"/> requests and responses in the invocation pipeline.
            </summary>
            <param name="verb">Verb of the intercepted invocation.</param>
            <param name="uri">Uri of the intercepted invocation.</param>
            <param name="normalizedUri">Normalized version of the uri of the intercepted invocation.</param>
            <param name="message">Message of the intercepted invocation.</param>
            <returns>The message to return as the result of the interception.</returns>
        </member>
        <member name="T:MindTouch.Dream.Plug">
            <summary>
            Provides a fluent, immutable interface for building request/response invocation  against a resource. Mostly used as an interface
            for making Http requests, but can be extended for any resource that can provide request/response semantics.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Plug.DEFAULT_MAX_AUTO_REDIRECTS">
            <summary>
            Default number of redirects plug uses when no value is specified.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Plug.BASE_ENDPOINT_SCORE">
            <summary>
            Base score normal priorty <see cref="T:MindTouch.Dream.IPlugEndpoint"/> implementations should use to signal a successful match.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Plug.DEFAULT_TIMEOUT">
            <summary>
            Default timeout of 60 seconds for <see cref="T:MindTouch.Dream.Plug"/> invocations.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Plug.GlobalCookies">
            <summary>
            Default, shared cookie jar for all plugs.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Plug.op_Implicit(MindTouch.Dream.Plug)~MindTouch.Dream.XUri">
            <summary>
            Implicit conversion operator for casting a <see cref="T:MindTouch.Dream.Plug"/> to a <see cref="T:MindTouch.Dream.XUri"/>.
            </summary>
            <param name="plug">Plug instance to convert.</param>
            <returns>New uri instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.New(System.String)">
            <summary>
            Create a new <see cref="T:MindTouch.Dream.Plug"/> instance from a uri string.
            </summary>
            <param name="uri">Uri string.</param>
            <returns>New plug instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.New(System.String,System.TimeSpan)">
            <summary>
            Create a new <see cref="T:MindTouch.Dream.Plug"/> instance from a uri string.
            </summary>
            <param name="uri">Uri string.</param>
            <param name="timeout">Invocation timeout.</param>
            <returns>New plug instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.New(System.Uri)">
            <summary>
            Create a new <see cref="T:MindTouch.Dream.Plug"/> instance from a <see cref="F:MindTouch.Dream.Plug.Uri"/>.
            </summary>
            <param name="uri">Uri instance.</param>
            <returns>New plug instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.New(System.Uri,System.TimeSpan)">
            <summary>
            Create a new <see cref="T:MindTouch.Dream.Plug"/> instance from a <see cref="F:MindTouch.Dream.Plug.Uri"/>.
            </summary>
            <param name="uri">Uri instance.</param>
            <param name="timeout">Invocation timeout.</param>
            <returns>New plug instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.New(MindTouch.Dream.XUri)">
            <summary>
            Create a new <see cref="T:MindTouch.Dream.Plug"/> instance from a <see cref="T:MindTouch.Dream.XUri"/>.
            </summary>
            <param name="uri">Uri instance.</param>
            <returns>New plug instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.New(MindTouch.Dream.XUri,System.TimeSpan)">
            <summary>
            Create a new <see cref="T:MindTouch.Dream.Plug"/> instance from a <see cref="T:MindTouch.Dream.XUri"/>.
            </summary>
            <param name="uri">Uri instance.</param>
            <param name="timeout">Invocation timeout.</param>
            <returns>New plug instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.AddEndpoint(MindTouch.Dream.IPlugEndpoint)">
            <summary>
            Manually add a plug endpoint for handling invocations.
            </summary>
            <param name="endpoint">Factory instance to add.</param>
        </member>
        <member name="M:MindTouch.Dream.Plug.RemoveEndpoint(MindTouch.Dream.IPlugEndpoint)">
            <summary>
            Manually remove a plug endpoint from the handler pool.
            </summary>
            <param name="endpoint">Factory instance to remove.</param>
        </member>
        <member name="M:MindTouch.Dream.Plug.WaitAndConfirm(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Blocks on a Plug synchronization handle to wait for it ti complete and confirm that it's a non-error response.
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="result">Plug synchronization handle.</param>
            <returns>Successful reponse message.</returns>
        </member>
        <member name="F:MindTouch.Dream.Plug.Uri">
            <summary>
            Uri of the instance.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Plug.Timeout">
            <summary>
            Timeout for invocation.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Plug.Credentials">
            <summary>
            If not null, the creditials to use for the invocation.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.Plug.#ctor(MindTouch.Dream.XUri,System.TimeSpan,MindTouch.Dream.DreamHeaders,System.Collections.Generic.List{MindTouch.Dream.PlugHandler},System.Collections.Generic.List{MindTouch.Dream.PlugHandler},System.Net.ICredentials,MindTouch.Web.DreamCookieJar,System.UInt16)">
            <summary>
            Create a new instance.
            </summary>
            <param name="uri">Uri to the resource to make the request against.</param>
            <param name="timeout">Invocation timeout.</param>
            <param name="headers">Header collection for request.</param>
            <param name="preHandlers">Optional pre-invocation handlers.</param>
            <param name="postHandlers">Optional post-invocation handlers.</param>
            <param name="credentials">Optional request credentials.</param>
            <param name="cookieJarOverride">Optional cookie jar to override global jar shared by <see cref="T:MindTouch.Dream.Plug"/> instances.</param>
            <param name="maxAutoRedirects">Maximum number of redirects to follow, 0 if non redirects should be followed.</param>
        </member>
        <member name="M:MindTouch.Dream.Plug.At(System.String[])">
            <summary>
            Create a copy of the instance with new path segments appended to its Uri.
            </summary>
            <param name="segments">Segements to add.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.AtPath(System.String)">
            <summary>
            Create a copy of the instance with a path/query/fragement appended to its Uri.
            </summary>
            <param name="path">Path/Query/fragment string.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.With(System.String,System.String)">
            <summary>
            Create a copy of the instance with a query key/value pair added.
            </summary>
            <param name="key">Query key.</param>
            <param name="value">Query value.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.With(System.String,System.Boolean)">
            <summary>
            Create a copy of the instance with a query key/value pair added.
            </summary>
            <param name="key">Query key.</param>
            <param name="value">Query value.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.With(System.String,System.Int32)">
            <summary>
            Create a copy of the instance with a query key/value pair added.
            </summary>
            <param name="key">Query key.</param>
            <param name="value">Query value.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.With(System.String,System.Int64)">
            <summary>
            Create a copy of the instance with a query key/value pair added.
            </summary>
            <param name="key">Query key.</param>
            <param name="value">Query value.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.With(System.String,System.Decimal)">
            <summary>
            Create a copy of the instance with a query key/value pair added.
            </summary>
            <param name="key">Query key.</param>
            <param name="value">Query value.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.With(System.String,System.Double)">
            <summary>
            Create a copy of the instance with a query key/value pair added.
            </summary>
            <param name="key">Query key.</param>
            <param name="value">Query value.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.With(System.String,System.DateTime)">
            <summary>
            Create a copy of the instance with a query key/value pair added.
            </summary>
            <param name="key">Query key.</param>
            <param name="value">Query value.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithParams(System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>
            Create a copy of the instance with additional query parameters.
            </summary>
            <param name="args">Array of query key/value pairs.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithQuery(System.String)">
            <summary>
            Create a copy of the instance with the provided querystring added.
            </summary>
            <param name="query">Query string.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithParamsFrom(MindTouch.Dream.XUri)">
            <summary>
            Create a copy of the instance with parameters from another uri added.
            </summary>
            <param name="uri">Uri to extract parameters from.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithCredentials(System.String,System.String)">
            <summary>
            Create a copy of the instance with the given credentials
            </summary>
            <remarks>
            Using the user/password signature will always try to send a basic auth header. If negotiation of auth method is desired
            (i.e. digest auth may be an option), use <see cref="M:MindTouch.Dream.Plug.WithCredentials(System.Net.ICredentials)"/> instead.
            </remarks>
            <param name="user">User.</param>
            <param name="password">Password.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithCredentials(System.Net.ICredentials)">
            <summary>
            Create a copy of the instance with the given credentials
            </summary>
            <param name="credentials">Credential instance.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithoutCredentials">
            <summary>
            Create a copy of the instance with credentials removed.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithCookieJar(MindTouch.Web.DreamCookieJar)">
            <summary>
            Create a copy of the instance with an override cookie jar.
            </summary>
            <param name="cookieJar">Cookie jar to use.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithoutCookieJar">
            <summary>
            Create a copy of the instance with any override cookie jar removed.
            </summary>
            <remarks>Will fall back on <see cref="T:MindTouch.Dream.DreamContext"/> or global jar.</remarks>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithAutoRedirects">
            <summary>
            Turn on auto redirect behavior with the <see cref="F:MindTouch.Dream.Plug.DEFAULT_MAX_AUTO_REDIRECTS"/> number of redirects to follow.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithAutoRedirects(System.UInt16)">
            <summary>
            Turn on auto redirect behavior with the specified number of redirects.
            </summary>
            <param name="maxRedirects">Maximum number of redirects to follow before giving up.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithoutAutoRedirects">
            <summary>
            Turn off auto-redirect behavior.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithHeader(System.String,System.String)">
            <summary>
            Create a copy of the instance with a header added.
            </summary>
            <param name="name">Header name.</param>
            <param name="value">Header value.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithHeaders(MindTouch.Dream.DreamHeaders)">
            <summary>
            Create a copy of the instance with a header collection added.
            </summary>
            <param name="headers">Header collection</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithoutHeader(System.String)">
            <summary>
            Create a copy of the instance with a header removed.
            </summary>
            <param name="name">Name of the header to remove.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithoutHeaders">
            <summary>
            Create a copy of the instance with all headers removed.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithPreHandler(MindTouch.Dream.PlugHandler[])">
            <summary>
            Create a copy of the instance with a pre-invocation handler added.
            </summary>
            <param name="preHandlers">Pre-invocation handler.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithPostHandler(MindTouch.Dream.PlugHandler[])">
            <summary>
            Create a copy of the instance with a post-invocation handler added.
            </summary>
            <param name="postHandlers">Post-invocation handler.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithoutHandlers">
            <summary>
            Create a copy of the instance with all handlers removed.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithTimeout(System.TimeSpan)">
            <summary>
            Create a copy of the instance with a new timeout.
            </summary>
            <param name="timeout">Invocation timeout.</param>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithTrailingSlash">
            <summary>
            Create a copy of the instance with a trailing slash.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithoutTrailingSlash">
            <summary>
            Create a copy of the instance without a trailing slash.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithSegmentDoubleEncoding">
            <summary>
            Turn on double-encoding of segments when the Plug's <see cref="F:MindTouch.Dream.Plug.Uri"/> is converted to a <see cref="T:System.Uri"/>.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithoutSegmentDoubleEncoding">
            <summary>
            Turn off double-encoding of segments when the Plug's <see cref="F:MindTouch.Dream.Plug.Uri"/> is converted to a <see cref="T:System.Uri"/>.
            </summary>
            <returns>New instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.ToString">
            <summary>
            Provide a string representation of the Uri of the instance.
            </summary>
            <returns>Uri string.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Post">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Post(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Post(MindTouch.Xml.XDoc)">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Post(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Post(MindTouch.Dream.DreamMessage)">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Post(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.PostAsForm">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.PostAsForm(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Put(MindTouch.Xml.XDoc)">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Put(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Put(MindTouch.Dream.DreamMessage)">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Put(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Get">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Get(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Get(MindTouch.Dream.DreamMessage)">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Get(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Head">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Head(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Options">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Options(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Delete">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Delete(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Delete(MindTouch.Xml.XDoc)">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Delete(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Delete(MindTouch.Dream.DreamMessage)">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Delete(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Invoke(System.String,MindTouch.Dream.DreamMessage)">
            <summary>
            Blocking version of <see cref="M:MindTouch.Dream.Plug.Invoke(System.String,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/>
            </summary>
            <remarks>
            WARNING: This method is thread-blocking.  Please avoid using it if possible.
            </remarks>
            <param name="verb"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Post(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.POST"/> verb and an empty message.
            </summary>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Post(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.POST"/> verb.
            </summary>
            <param name="doc">Document to send.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Post(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.POST"/> verb.
            </summary>
            <param name="message">Message to send.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.PostAsForm(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.POST"/> verb with <see cref="F:MindTouch.Dream.Verb.GET"/> query arguments converted as form post body.
            </summary>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Put(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.PUT"/> verb.
            </summary>
            <param name="doc">Document to send.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Put(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.PUT"/> verb.
            </summary>
            <param name="message">Message to send.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Get(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.GET"/> verb and no message body.
            </summary>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Get(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.GET"/> verb.
            </summary>
            <param name="message">The message to send</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Head(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.HEAD"/> verb and no message body.
            </summary>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Options(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.OPTIONS"/> verb and no message body.
            </summary>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Delete(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.DELETE"/> verb and no message body.
            </summary>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Delete(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.DELETE"/> verb.
            </summary>
            <param name="doc">Document to send.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Delete(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug with the <see cref="F:MindTouch.Dream.Verb.DELETE"/> verb.
            </summary>
            <param name="message">Message to send.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.Invoke(System.String,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug.
            </summary>
            <param name="verb">Request verb.</param>
            <param name="request">Request message.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.InvokeEx(System.String,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Invoke the plug, but leave the stream unread so that the returned <see cref="T:MindTouch.Dream.DreamMessage"/> can be streamed.
            </summary>
            <param name="verb">Request verb.</param>
            <param name="request">Request message.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithParams(System.Collections.Specialized.NameValueCollection)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.WithParams(System.Collections.Generic.KeyValuePair{System.String,System.String}[])"/> instead.
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.WithHeaders(System.Collections.Specialized.NameValueCollection)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.WithHeaders(MindTouch.Dream.DreamHeaders)"/> instead.
            </summary>
            <param name="headers"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.PostAsync">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Post(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.PostAsync(MindTouch.Xml.XDoc)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Post(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.PostAsync(MindTouch.Dream.DreamMessage)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Post(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.PostAsFormAsync">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.PostAsForm(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.PutAsync(MindTouch.Xml.XDoc)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Put(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.PutAsync(MindTouch.Dream.DreamMessage)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Put(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.GetAsync">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Get(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.GetAsync(MindTouch.Dream.DreamMessage)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Get(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.HeadAsync">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Head(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.OptionsAsync">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Options(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.DeleteAsync">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Delete(MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.DeleteAsync(MindTouch.Xml.XDoc)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Delete(MindTouch.Xml.XDoc,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.DeleteAsync(MindTouch.Dream.DreamMessage)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Delete(MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.Plug.InvokeAsync(System.String,MindTouch.Dream.DreamMessage)">
            <summary>
            This method is deprecated. Please use <see cref="M:MindTouch.Dream.Plug.Invoke(System.String,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})"/> instead.
            </summary>
            <param name="verb"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Dream.Plug.Headers">
            <summary>
            Request header collection.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.Plug.PreHandlers">
            <summary>
            Pre-invocation handlers.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.Plug.PostHandlers">
            <summary>
            Post-invocation handlers.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.Plug.CookieJar">
            <summary>
            Cookie jar for the request.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.Plug.AutoRedirect">
            <summary>
            True if this plug will automatically follow redirects (301,302 &amp; 307).
            </summary>
        </member>
        <member name="P:MindTouch.Dream.Plug.MaxAutoRedirects">
            <summary>
            Maximum number of redirect to follow before giving up.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.ProxyPlugEndpoint">
            <summary>
            Provides an implementation of <see cref="T:MindTouch.Dream.IPlugEndpoint"/> to intercept <see cref="F:MindTouch.Dream.Verb.GET"/> plug invocations
            and proxy the response to a document held by the instance.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.ProxyPlugEndpoint.Add(MindTouch.Dream.XUri,MindTouch.Xml.XDoc)">
            <summary>
            Add a document for a uri.
            </summary>
            <param name="uri">Uri to intercept.</param>
            <param name="doc">Document to return for interception.</param>
        </member>
        <member name="M:MindTouch.Dream.ProxyPlugEndpoint.Remove(MindTouch.Dream.XUri)">
            <summary>
            Remove a uri from the proxy.
            </summary>
            <param name="uri">Uri to remove.</param>
        </member>
        <member name="T:MindTouch.Dream.DreamAccess">
            <summary>
            Dream Feature Access level.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamAccess.Public">
            <summary>
            Feature can be called by anyone
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamAccess.Internal">
            <summary>
            Feature access requries the internal or private service key.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamAccess.Private">
            <summary>
            Feature access requires the private service key.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.IDreamEnvironment">
            <summary>
            Provides the interface for the Dream host environment.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.Initialize(MindTouch.Xml.XDoc)">
            <summary>
            Initialize the host.
            </summary>
            <param name="config">Configuration document.</param>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.Deinitialize">
            <summary>
            Shut down the host.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.SubmitRequestAsync(System.String,MindTouch.Dream.XUri,System.Security.Principal.IPrincipal,MindTouch.Dream.DreamMessage,MindTouch.Tasking.Result{MindTouch.Dream.DreamMessage})">
            <summary>
            Asynchronously submit a request to the host.
            </summary>
            <param name="verb">Request Http verb.</param>
            <param name="uri">Request Uri.</param>
            <param name="user">Request user, if applicable.</param>
            <param name="request">Request message.</param>
            <param name="response">The response message synchronization instance to be returned by this method.</param>
            <returns>Synchronization handle for request.</returns>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.WaitUntilShutdown">
            <summary>
            Block execution until host has shut down.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.AddActivityDescription(System.Object,System.String)">
            <summary>
            Add an activity.
            </summary>
            <param name="key">Activity key.</param>
            <param name="description">Activity description.</param>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.RemoveActivityDescription(System.Object)">
            <summary>
            Remove an activity.
            </summary>
            <param name="key">Activity key.</param>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.UpdateInfoMessage(System.String,System.String)">
            <summary>
            Update the information message for a source.
            </summary>
            <param name="source">Source to update.</param>
            <param name="message">Info message.</param>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.CheckResponseCache(MindTouch.Dream.IDreamService,System.Object)">
            <summary>
            Check response cache for a service.
            </summary>
            <param name="service">Service whose cache to check.</param>
            <param name="key">Cache key.</param>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.RemoveResponseCache(MindTouch.Dream.IDreamService,System.Object)">
            <summary>
            Remove an item from a service's cache.
            </summary>
            <param name="service">Service whose cache to check.</param>
            <param name="key">Cache key.</param>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.EmptyResponseCache(MindTouch.Dream.IDreamService)">
            <summary>
            Empty entire cache for a service.
            </summary>
            <param name="service">Service to clear the cache for.</param>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.CreateServiceContainer(MindTouch.Dream.IDreamService)">
            <summary>
            Called by <see cref="T:MindTouch.Dream.IDreamService"/> on startup to have the environment create and initialize a service level container.
            </summary>
            <remarks>
            Returned instance should only be used to configure the container. For any type resolution, <see cref="P:MindTouch.Dream.DreamContext.Container"/> should be used
            instead.
            </remarks>
            <param name="service"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.IDreamEnvironment.DisposeServiceContainer(MindTouch.Dream.IDreamService)">
            <summary>
            Must be called at <see cref="T:MindTouch.Dream.IDreamService"/> shutdown to dispose of the service level container.
            </summary>
            <param name="service"></param>
        </member>
        <member name="P:MindTouch.Dream.IDreamEnvironment.GlobalId">
            <summary>
            Host Globally Unique Identifier.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamEnvironment.IsRunning">
            <summary>
            <see langword="True"/> if the host is running.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamEnvironment.IsDebugEnv">
            <summary>
            <see langword="True"/> if the current environment is in debug mode
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamEnvironment.LocalMachineUri">
            <summary>
            The host's local uri.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamEnvironment.Self">
            <summary>
            <see cref="T:MindTouch.Dream.Plug"/> for host.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamEnvironment.ActivityMessages">
            <summary>
            Current Activity messages.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.IDreamServiceLicense">
            <summary>
            Interface for <see cref="T:MindTouch.Dream.IDreamService"/> implementations that require a service license.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.IDreamServiceLicense.ServiceLicense">
            <summary>
            License for service.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.Verb">
            <summary>
            Common Http verbs.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Verb.POST">
            <summary>
            POST verb.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Verb.PUT">
            <summary>
            PUT verb.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Verb.GET">
            <summary>
            GET verb.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Verb.DELETE">
            <summary>
            DELETE verb.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Verb.HEAD">
            <summary>
            HEAD verb.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Verb.OPTIONS">
            <summary>
            OPTIONS verb.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.Scheme">
            <summary>
            Common URI schemes
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Scheme.HTTP">
            <summary>
            Hyper-text transport protocol.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Scheme.HTTPS">
            <summary>
            Secure Hyper-text transport protocol.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Scheme.XRI">
            <summary>
            eXtensible Resource Identifier.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.Scheme.LOCAL">
            <summary>
            Dream Host internal transport.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamInParam">
            <summary>
            Dream specific input query parameters.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamInParam.FORMAT">
            <summary>
            Request message format
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamInParam.HOST">
            <summary>
            Request originating host.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamInParam.ROOT">
            <summary>
            Request originating path root.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamInParam.VERB">
            <summary>
            Request originating verb.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamInParam.ORIGIN">
            <summary>
            Request origin.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamInParam.SCHEME">
            <summary>
            Request originating scheme.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamInParam.URI">
            <summary>
            Original request uri.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.DreamOutParam">
            <summary>
            Dream specific output query parameters.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamOutParam.FORMAT">
            <summary>
            Expected response message format.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamOutParam.PREFIX">
            <summary>
            Response prefix.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamOutParam.POSTFIX">
            <summary>
            Response postix.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamOutParam.CALLBACK">
            <summary>
            Response callback.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamOutParam.SELECT">
            <summary>
            Response selector.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamOutParam.CHUNK">
            <summary>
            Response chunk.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamOutParam.TYPE">
            <summary>
            Response type.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamOutParam.SAVEAS">
            <summary>
            Response 'Save As' directive.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.ExceptionTranslator">
            <summary>
            Delegate type for implemting an exception translator.
            </summary>
            <param name="context">Request context.</param>
            <param name="e">Original exception.</param>
            <returns>DreamMessage formatted exception, or null, if the translator declines to handle the exception.</returns>
        </member>
        <member name="T:MindTouch.Dream.DreamFeature">
            <summary>
            Encapsulation of processing chain for a feature in an <see cref="T:MindTouch.Dream.IDreamService"/>
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeature.Service">
            <summary>
            Owning Service.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeature.ServiceUri">
            <summary>
            Uri for Service.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeature.Verb">
            <summary>
            Request Verb.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeature.Stages">
            <summary>
            Request stages.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeature.PathSegments">
            <summary>
            Request path segments.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeature.OptionalSegments">
            <summary>
            Number of optional segments
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeature.MainStageIndex">
            <summary>
            Index into <see cref="F:MindTouch.Dream.DreamFeature.Stages"/> for the <see cref="T:MindTouch.Dream.DreamFeatureAttribute"/> marked stage for this request.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.DreamFeature.ExceptionTranslators">
            <summary>
            Exception translators for this request.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.DreamFeature.#ctor(MindTouch.Dream.IDreamService,MindTouch.Dream.XUri,System.Int32,MindTouch.Dream.DreamFeatureStage[],System.String,System.String)">
            <summary>
            Create a new feature instance.
            </summary>
            <param name="service">Owning Service.</param>
            <param name="serviceUri">Service Uri.</param>
            <param name="mainStageIndex">Main stage index.</param>
            <param name="stages">Feature stages.</param>
            <param name="verb">Request verb.</param>
            <param name="signature">Feature signature.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamFeature.ExtractArguments(MindTouch.Dream.XUri,System.String[]@,System.Collections.Generic.Dictionary{System.String,System.String[]}@)">
            <summary>
            Extract a list of suffixes and a dictionary of arguments from the request.
            </summary>
            <param name="uri">Request Uri.</param>
            <param name="suffixes">Extracted suffixes.</param>
            <param name="pathParams">Extracted path parameters.</param>
        </member>
        <member name="M:MindTouch.Dream.DreamFeature.IncreaseHitCounter">
            <summary>
            Increment the feature hit counter.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeature.Signature">
            <summary>
            Feature signature.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeature.Path">
            <summary>
            Feature path.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeature.VerbSignature">
            <summary>
            <see cref="F:MindTouch.Dream.DreamFeature.Verb"/> + ":" + <see cref="P:MindTouch.Dream.DreamFeature.Signature"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeature.VerbPath">
            <summary>
            <see cref="F:MindTouch.Dream.DreamFeature.Verb"/> + ":" + <see cref="P:MindTouch.Dream.DreamFeature.Path"/>. 
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeature.HitCounter">
            <summary>
            Number of times this Feature has been called in current instance.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.DreamFeature.MainStage">
            <summary>
            Main feature Stage.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.ContentDisposition">
            <summary>
            Encapsulation for Http Content-Disposition header.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.ContentDisposition.Inline">
            <summary>
            Inline content.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.ContentDisposition.CreationDate">
            <summary>
            Content creation date.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.ContentDisposition.ModificationDate">
            <summary>
            Content modification date.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.ContentDisposition.ReadDate">
            <summary>
            Date content was read.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.ContentDisposition.FileName">
            <summary>
            Local filename for content.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.ContentDisposition.Size">
            <summary>
            Content file size (if available).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.ContentDisposition.UserAgent">
            <summary>
            Content target user agent.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.ContentDisposition.#ctor">
            <summary>
            Create a new content disposition.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.ContentDisposition.#ctor(System.String)">
            <summary>
            Create a new content dispisition from a Content-Disposition header string.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MindTouch.Dream.ContentDisposition.#ctor(System.Boolean,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.String,System.Nullable{System.Int64})">
            <summary>
            Create a new content disposition.
            </summary>
            <param name="inline">Inline the content.</param>
            <param name="created">Creation date.</param>
            <param name="modified">Modification date.</param>
            <param name="read">Read date.</param>
            <param name="filename">Content filename.</param>
            <param name="size">Content size.</param>
        </member>
        <member name="M:MindTouch.Dream.ContentDisposition.#ctor(System.Boolean,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.String,System.Nullable{System.Int64},System.String)">
            <summary>
            Create a new content disposition.
            </summary>
            <param name="inline">Inline the content.</param>
            <param name="created">Creation date.</param>
            <param name="modified">Modification date.</param>
            <param name="read">Read date.</param>
            <param name="filename">Content filename.</param>
            <param name="size">File size.</param>
            <param name="userAgent">Target user agent.</param>
        </member>
        <member name="M:MindTouch.Dream.ContentDisposition.ToString">
            <summary>
            Convert to Content-Disposition header string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MindTouch.Dream.UriPathFormat">
            <summary>
            Uri Path string encoding format
            </summary>
        </member>
        <member name="F:MindTouch.Dream.UriPathFormat.Original">
            <summary>
            Leave path segment as is.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.UriPathFormat.Decoded">
            <summary>
            Uri decode path segment.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.UriPathFormat.Normalized">
            <summary>
            Normalize encoding.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.UriEncoding">
            <summary>
            Uri encoding options.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.UriEncoding.Default">
            <summary>
            Use only default encoding.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.UriEncoding.UserInfo">
            <summary>
            Perform additional encoding for <see cref="P:MindTouch.Dream.XUri.UserInfo"/>
            </summary>
        </member>
        <member name="F:MindTouch.Dream.UriEncoding.Segment">
            <summary>
            Perform additional encoding for <see cref="P:MindTouch.Dream.XUri.Segments"/>
            </summary>
        </member>
        <member name="F:MindTouch.Dream.UriEncoding.Query">
            <summary>
            Perform additional encoding for <see cref="P:MindTouch.Dream.XUri.Query"/>
            </summary>
        </member>
        <member name="F:MindTouch.Dream.UriEncoding.Fragment">
            <summary>
            Perform additionalencoding for <see cref="F:MindTouch.Dream.XUri.Fragment"/>
            </summary>
        </member>
        <member name="T:MindTouch.Dream.XUri">
            <summary>
            Encapsulation of a Uniform Resource Identifier as an immutable class with a fluent interface for modification.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.URI_REGEX">
            <summary>
            Regular expression used to parse a full Uri string.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.SCHEME_REGEX">
            <summary>
            Regular expression to match Uri scheme.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.USERINFO_REGEX">
            <summary>
            Regular expression to match Uri User Info.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.HOST_REGEX">
            <summary>
            Regular expression to match Uri host.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.SEGMENT_REGEX">
            <summary>
            Regular expression for matching path segments.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.QUERY_REGEX">
            <summary>
            Regular expression for matching query name/value pairs.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.FRAGMENT_REGEX">
            <summary>
            Regular expression for matching fragment elements.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.EMPTY_ARRAY">
            <summary>
            An empty string array.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.INVARIANT">
            <summary>
            Invariant string comparer (using <see cref="P:System.StringComparer.Ordinal"/> by default).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.INVARIANT_IGNORE_CASE">
            <summary>
            Invariant, case-insensitive string comparer (using <see cref="P:System.StringComparer.OrdinalIgnoreCase"/> by default).
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.Localhost">
            <summary>
            XUri for localhost.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.XUri.op_Equality(MindTouch.Dream.XUri,MindTouch.Dream.XUri)">
            <summary>
            Equality operator overload for Uri comparison.
            </summary>
            <param name="left">Left Uri.</param>
            <param name="right">Right Uri.</param>
            <returns><see langword="True"/> if left and right represent the same Uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.op_Inequality(MindTouch.Dream.XUri,MindTouch.Dream.XUri)">
            <summary>
            Inequality operator overload for Uri comparison.
            </summary>
            <param name="left">Left Uri.</param>
            <param name="right">Right Uri.</param>
            <returns><see langword="True"/> if left and right do not represent the same Uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.op_Implicit(MindTouch.Dream.XUri)~System.Uri">
            <summary>
            Implicit conversion operator to convert <see cref="T:System.Uri"/> into an <see cref="T:MindTouch.Dream.XUri"/>.
            </summary>
            <param name="uri">Uri to convert.</param>
            <returns>New XUri instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.TryParse(System.String)">
            <summary>
            Try to parse a string into a valid Uri.
            </summary>
            <param name="text">Uri string.</param>
            <returns>New XUri instance or null.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.TryParse(System.String,MindTouch.Dream.XUri@)">
            <summary>
            Try to parse a string into a valid Uri.
            </summary>
            <param name="text">Uri string.</param>
            <param name="uri">Output for parsed Uri.</param>
            <returns><see langword="True"/> if the text was successfully parsed.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.ParseParamsAsPairs(System.String)">
            <summary>
            Extract query parameters as key/value pairs.
            </summary>
            <param name="query">Query string.</param>
            <returns>Array of key/value pairs.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.ParsePath(System.String,System.Boolean,System.String[]@,System.Boolean@)">
            <summary>
            Parse a path into segments.
            </summary>
            <param name="path">Path string to parse.</param>
            <param name="relative"><see langword="True"/> if the path is a relative path.</param>
            <param name="segments">Output for an array of path segments.</param>
            <param name="trailingSlash">Output of <see langword="True"/> if the path had a trailing slash.</param>
        </member>
        <member name="M:MindTouch.Dream.XUri.RenderParams(System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>
            Render an parameter key/value pairs into a query string.
            </summary>
            <param name="params">Array of key/value pairs.</param>
            <returns>Query string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.Decode(System.String)">
            <summary>
            Url decode a string.
            </summary>
            <param name="text">Input text.</param>
            <returns>Decoded text.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.DoubleDecode(System.String)">
            <summary>
            Double decode a string.
            </summary>
            <param name="text">Input text.</param>
            <returns>Decoded text.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.Encode(System.String,MindTouch.Dream.UriEncoding)">
            <summary>
            Uri encode a string.
            </summary>
            <param name="text">Input text.</param>
            <param name="level">Encoding level.</param>
            <returns>Encoded string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.DoubleEncode(System.String,MindTouch.Dream.UriEncoding)">
            <summary>
            Double encode a string.
            </summary>
            <param name="text">Input text.</param>
            <param name="level">Encoding level.</param>
            <returns>Encoded string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.Encode(System.String)">
            <summary>
            Uri encode a string.
            </summary>
            <param name="text">Input text.</param>
            <returns>Encoded string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.DoubleEncode(System.String)">
            <summary>
            Double encode a string.
            </summary>
            <param name="text">Input text.</param>
            <returns>Encoded string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.EncodeSegment(System.String)">
            <summary>
            Encode a path segment.
            </summary>
            <param name="text">Input segment.</param>
            <returns>Encoded segment.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.DoubleEncodeSegment(System.String)">
            <summary>
            Double encode a path segment.
            </summary>
            <param name="text">Input segment.</param>
            <returns>Encoded segment.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.EncodeQuery(System.String)">
            <summary>
            Encode a query string.
            </summary>
            <param name="text">Input query.</param>
            <returns>Encoded query.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.EncodeFragment(System.String)">
            <summary>
            Encode a fragment string.
            </summary>
            <param name="text">Input fragement.</param>
            <returns>Encoded fragment.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.EncodeUserInfo(System.String)">
            <summary>
            Encode a Uri user info.
            </summary>
            <param name="text">Input user info.</param>
            <returns>Encoded user info.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.IsValidScheme(System.String)">
            <summary>
            Validate a scheme.
            </summary>
            <param name="scheme">Input scheme.</param>
            <returns><see langword="True"/> if the scheme is valid</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.IsValidHost(System.String)">
            <summary>
            Validate a host string.
            </summary>
            <param name="host">Input host.</param>
            <returns><see langword="True"/> if the host is valid</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.IsValidSegment(System.String)">
            <summary>
            Validate a segment.
            </summary>
            <param name="segment">Input segment.</param>
            <returns><see langword="True"/> if the segment is valid</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.IsValidCharInUri(System.Char,MindTouch.Dream.UriEncoding)">
            <summary>
            Validate that a character is valid for a uri at a specific encoding level.
            </summary>
            <param name="ch">Character to check.</param>
            <param name="level">Encoding level.</param>
            <returns><see langword="True"/> if the character is valid for the uri.</returns>
        </member>
        <member name="F:MindTouch.Dream.XUri.Scheme">
            <summary>
            Uri scheme.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.Host">
            <summary>
            Uri host.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.Port">
            <summary>
            Uri port.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.User">
            <summary>
            User portion of user info.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.Password">
            <summary>
            Password portion of user info.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.Fragment">
            <summary>
            Uri fragment.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.TrailingSlash">
            <summary>
            <see langword="True"/> if the Uri has a trailing slash.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.XUri.UsesDefaultPort">
            <summary>
            <see langword="True"/> if the Uri uses the default port for it's scheme.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.XUri.#ctor(System.Uri)">
            <summary>
            Create a new XUri from an <see cref="T:System.Uri"/>
            </summary>
            <param name="uri">Input uri.</param>
        </member>
        <member name="M:MindTouch.Dream.XUri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Create a new XUri from serialized form.
            </summary>
            <param name="info">Serialization information.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="M:MindTouch.Dream.XUri.#ctor(System.String)">
            <summary>
            Create a new XUri from a valid uri string.
            </summary>
            <param name="uri">Uri string.</param>
            <exception cref="T:System.UriFormatException">Thrown if string cannot be parsed into an XUri.</exception>
        </member>
        <member name="M:MindTouch.Dream.XUri.#ctor(System.String,System.String,System.String,System.String,System.Int32,System.String[],System.Boolean,System.Collections.Generic.KeyValuePair{System.String,System.String}[],System.String)">
            <summary>
            Build a new XUri from its components.
            </summary>
            <param name="scheme">Uri scheme.</param>
            <param name="user">User.</param>
            <param name="password">Password.</param>
            <param name="host">Uri host.</param>
            <param name="port">Uri port.</param>
            <param name="segments">Path segments.</param>
            <param name="trailingSlash"><see langword="True"/> if the uri should have a trailing slash.</param>
            <param name="params">Query paramenters.</param>
            <param name="fragment">Uri fragment.</param>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetSegments(MindTouch.Dream.UriPathFormat)">
            <summary>
            Get all segments.
            </summary>
            <param name="format">Encoding format for segments.</param>
            <returns>Array of segments.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetSegment(System.Int32,MindTouch.Dream.UriPathFormat)">
            <summary>
            Get one segment.
            </summary>
            <param name="index">Index of segment.</param>
            <param name="format">Encoding format for segments.</param>
            <returns>Segment string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.At(System.String[])">
            <summary>
            Create a new XUri at a appended path.
            </summary>
            <param name="segments">Path segments.</param>
            <returns>New uri instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.AtPath(System.String)">
            <summary>
            Create a new XUri with appended path/query/fragment.
            </summary>
            <param name="pathQueryFragment">Path/query/fragment string.</param>
            <returns>New Uri instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.AtAbsolutePath(System.String)">
            <summary>
            Create a new Uri at a different absolute path.
            </summary>
            <param name="path">Path string.</param>
            <returns>New uri instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetRelativePathTo(MindTouch.Dream.XUri)">
            <summary>
            Get the relative portion of the current uri in relation to another uri.
            </summary>
            <remarks>Uri's must have same scheme, host and port.</remarks>
            <param name="uri">Comparison uri.</param>
            <returns>Relative path string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetRelativePathTo(MindTouch.Dream.XUri,System.Boolean)">
            <summary>
            Get the relative portion of the current uri in relation to another uri.
            </summary>
            <remarks>Uri's must have same scheme, host and port.</remarks>
            <param name="uri">Comparison uri.</param>
            <param name="strict"><cref langword="True"/> to force a strict comparison.</param>
            <returns>Relative path string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.HasPrefix(MindTouch.Dream.XUri)">
            <summary>
            Checks whether a given uri is a prefix to the current instance.
            </summary>
            <param name="prefix">Prefix uri.</param>
            <returns><see langword="True"/> if the given uri is a prefix for the current instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.HasPrefix(MindTouch.Dream.XUri,System.Boolean)">
            <summary>
            Checks whether a given uri is a prefix to the current instance.
            </summary>
            <param name="prefix">Prefix uri.</param>
            <param name="strict"><cref langword="True"/> to force a strict comparison.</param>
            <returns><see langword="True"/> if the given uri is a prefix for the current instance.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.ChangePrefix(MindTouch.Dream.XUri,MindTouch.Dream.XUri)">
            <summary>
            Create a new uri with a changed prefix.
            </summary>
            <param name="from">Current prefix uri.</param>
            <param name="to">New prefix uri.</param>
            <returns>New uri with different prefix.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.ChangePrefix(MindTouch.Dream.XUri,MindTouch.Dream.XUri,System.Boolean)">
            <summary>
            Create a new uri with a changed prefix.
            </summary>
            <param name="from">Current prefix uri.</param>
            <param name="to">New prefix uri.</param>
            <param name="strict"><cref langword="True"/> to force a strict comparison.</param>
            <returns>New uri with different prefix.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetParams(System.String)">
            <summary>
            Get parameters values for a query key.
            </summary>
            <param name="key">Query key.</param>
            <returns>Array of parameter values, or <see cref="F:MindTouch.Dream.XUri.EMPTY_ARRAY"/> if key doesn't exist.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetParam(System.String)">
            <summary>
            Get single parameter value.
            </summary>
            <param name="key">Parameter key.</param>
            <returns>Parameter value, or null if key doesn't exist.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetParam(System.String,System.String)">
            <summary>
            Get single parameter value.
            </summary>
            <param name="key">Parameter key.</param>
            <param name="def">Default to return if key doesn't exist.</param>
            <returns>Parameter or default value.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetParam(System.String,System.Int32,System.String)">
            <summary>
            Get single parameter value.
            </summary>
            <param name="key">Parameter key.</param>
            <param name="index">Index into list of parameter values.</param>
            <param name="def">Default to return if key doesn't exist.</param>
            <returns>Parameter or default value.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.With(System.String,System.String)">
            <summary>
            Create a new Uri based on the current instance with an additional query parameter.
            </summary>
            <param name="key">Query key.</param>
            <param name="value">Query value.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithParams(System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>
            Create a new Uri based on the current instance with additional query parameters.
            </summary>
            <param name="args">Array of query key/value pairs.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithParams(System.Collections.Specialized.NameValueCollection)">
            <summary>
            This method is obsolete. Please use <see cref="M:MindTouch.Dream.XUri.WithParams(System.Collections.Generic.KeyValuePair{System.String,System.String}[])"/> instead
            </summary>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithParamsFrom(MindTouch.Dream.XUri)">
            <summary>
            Create new XUri based on the current instance with parameters from another uri added.
            </summary>
            <param name="uri">Other uri.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithQuery(System.String)">
            <summary>
            Create a new XUri based on the current instance with the provided querystring added.
            </summary>
            <param name="query">Query string.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutQuery">
            <summary>
            Create a copy of the current XUri with the Query removed.
            </summary>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutParams">
            <summary>
            Create a copy of the current XUri with the Query parameters removed.
            </summary>
            <remarks>Same as <see cref="M:MindTouch.Dream.XUri.WithoutQuery"/>.</remarks>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithCredentials(System.String,System.String)">
            <summary>
            Create a new XUri based on the current instance with the given credentials.
            </summary>
            <param name="user">User.</param>
            <param name="password">Password.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithCredentialsFrom(MindTouch.Dream.XUri)">
            <summary>
            Create a new XUri based on the current instance with the credentials of another uri.
            </summary>
            <param name="uri">Input uri.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutCredentials">
            <summary>
            Create a copy of the current XUri with credentials removed.
            </summary>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithFragment(System.String)">
            <summary>
            Create a new XUri based on the current instance with the given fragment.
            </summary>
            <param name="fragment">Fragment.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutFragment">
            <summary>
            Create a copy of the current XUri with the fragment removed.
            </summary>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithFirstSegments(System.Int32)">
            <summary>
            Create a new XUri based on the current instance with only a subset of the original path.
            </summary>
            <param name="count">Number of segments to keep.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutFirstSegments(System.Int32)">
            <summary>
            Create a new XUri based on the current instance with only a subset of the original path.
            </summary>
            <param name="count">Number of segments to drop.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutLastSegment">
            <summary>
            Create a copy of the current XUri with the last segment removed.
            </summary>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutLastSegments(System.Int32)">
            <summary>
            Create a new XUri based on the current instance with only a subset of the original path.
            </summary>
            <param name="count">Number of segments to remove from end of path.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutPathQueryFragment">
            <summary>
            Create a copy of the current XUri with the <see cref="P:MindTouch.Dream.XUri.Path"/>, <see cref="P:MindTouch.Dream.XUri.Query"/> and <see cref="F:MindTouch.Dream.XUri.Fragment"/> removed.
            </summary>
            <returns>New Uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutCredentialsPathQueryFragment">
            <summary>
            Create a copy of the current XUri with the <see cref="P:MindTouch.Dream.XUri.UserInfo"/>, <see cref="P:MindTouch.Dream.XUri.Path"/>, <see cref="P:MindTouch.Dream.XUri.Query"/> and <see cref="F:MindTouch.Dream.XUri.Fragment"/> removed.
            </summary>
            <returns>New Uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutParams(System.String)">
            <summary>
            Create a copy of the current XUri with a specific query parameter removed.
            </summary>
            <param name="key">Query parameter key.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithTrailingSlash">
            <summary>
            Create a new XUri based on the current instance with a trailing slash.
            </summary>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutTrailingSlash">
            <summary>
            Create a copy of the current XUri with the trailing slash removed.
            </summary>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithScheme(System.String)">
            <summary>
            Create a new XUri based on the current instance with a different scheme.
            </summary>
            <param name="scheme">New scheme.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithHost(System.String)">
            <summary>
            Create a new XUri based on the current instance with a different host.
            </summary>
            <param name="host">New host.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithPort(System.Int32)">
            <summary>
            Create a new XUri based on the current instance with a different port.
            </summary>
            <param name="port">New port.</param>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithSegmentDoubleEncoding">
            <summary>
            Turn on double-encoding of segments in <see cref="M:MindTouch.Dream.XUri.ToUri"/> conversion.
            </summary>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.WithoutSegmentDoubleEncoding">
            <summary>
            Turn off double-encoding of segments in <see cref="M:MindTouch.Dream.XUri.ToUri"/> conversion.
            </summary>
            <returns>New uri.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.ToUri">
            <summary>
            Convert the instance to a <see cref="T:System.Uri"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.Equals(System.Object)">
            <summary>
            Override of <see cref="M:System.Object.Equals(System.Object)"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.XUri.GetHashCode">
            <summary>
            Override of <see cref="M:System.Object.GetHashCode"/>
            </summary>
            <returns>Uri hashcode.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.ToString">
            <summary>
            Renders uri as a string with user info password replaced with 'xxx'.
            </summary>
            <returns>Uri string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.ToString(System.Boolean)">
            <summary>
            Renders uri as a string 
            </summary>
            <param name="includePassword">If <see langword="True"/> the user info password is replaced with 'xxx'.</param>
            <returns>Uri string.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.Similarity(MindTouch.Dream.XUri)">
            <summary>
            Compare instance to another uri for similarity.
            </summary>
            <param name="other">Other uri.</param>
            <returns>Total number of uri token matching in sequence.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.Similarity(MindTouch.Dream.XUri,System.Boolean)">
            <summary>
            Compare instance to another uri for similarity.
            </summary>
            <param name="other">Other uri.</param>
            <param name="strict"><cref langword="True"/> to force a strict comparison.</param>
            <returns>Total number of uri token matching in sequence.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUri.PathStartsWith(System.String[])">
            <summary>
            Check whether the uri starts with a certain path.
            </summary>
            <param name="segments">Array of segments to match.</param>
            <returns><see langword="True"/> if the uri starts with the given segments.</returns>
        </member>
        <member name="P:MindTouch.Dream.XUri.Params">
            <summary>
            Query Paramenters.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.Segments">
            <summary>
            Path segments.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.HasQuery">
            <summary>
            Uri has a query parameters.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.HasFragment">
            <summary>
            Uri has a trailing fragment.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.UsesSegmentDoubleEncoding">
            <summary>
            True if the instance is set to double-encode path segments.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.Authority">
            <summary>
            Uri authority, e.g. userinfo and host/port.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.UserInfo">
            <summary>
            Uri user info.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.Path">
            <summary>
            Path.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.Query">
            <summary>
            Query string.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.HostPort">
            <summary>
            <see cref="F:MindTouch.Dream.XUri.Host"/> + ":" + <see cref="F:MindTouch.Dream.XUri.Port"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.SchemeHostPort">
            <summary>
            <see cref="F:MindTouch.Dream.XUri.Scheme"/> + "://" + <see cref="F:MindTouch.Dream.XUri.Host"/> + ":" + <see cref="F:MindTouch.Dream.XUri.Port"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.SchemeHostPortPath">
            <summary>
            <see cref="F:MindTouch.Dream.XUri.Scheme"/> + "://" + <see cref="F:MindTouch.Dream.XUri.Host"/> + ":" + <see cref="F:MindTouch.Dream.XUri.Port"/> + <see cref="P:MindTouch.Dream.XUri.Path"/>.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.PathQueryFragment">
            <summary>
            <see cref="P:MindTouch.Dream.XUri.Path"/> [ + "?" + <see cref="P:MindTouch.Dream.XUri.Query"/> ] [ + "#" + <see cref="F:MindTouch.Dream.XUri.Fragment"/> ].
            </summary>
            
        </member>
        <member name="P:MindTouch.Dream.XUri.QueryFragment">
            <summary>
            [ + "?" + <see cref="P:MindTouch.Dream.XUri.Query"/> ] [ + "#" + <see cref="F:MindTouch.Dream.XUri.Fragment"/> ].
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.MaxSimilarity">
            <summary>
            Maximum number of similar tokens for partial comparison.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.LastSegment">
            <summary>
            Last segment in uri.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.HostIsIp">
            <summary>
            <see langword="True"/> if <see cref="F:MindTouch.Dream.XUri.Host"/> is an IP address.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUri.IsHttpOrHttps">
            <summary>
            <see langword="True"/> if  <see cref="P:MindTouch.Dream.XUri.Path"/> is either "http" or "https".
            </summary>
        </member>
        <member name="T:MindTouch.Dream.XUriMap`1">
            <summary>
            Provides an <see cref="T:MindTouch.Dream.XUri"/> map to match the best parent uri.
            </summary>
            <remarks>
            This map is a counterpart to <see cref="T:MindTouch.Dream.XUriChildMap`1"/>, which matches all child uris, instead of the best parent.
            Parent/Child relationships are determined by scheme/hostpot/path similarity.
            </remarks>
            <typeparam name="T">Type of object that is associated with each <see cref="T:MindTouch.Dream.XUri"/> entry</typeparam>
        </member>
        <member name="M:MindTouch.Dream.XUriMap`1.Clear">
            <summary>
            Clear map of all entries.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.XUriMap`1.TryGetValue(MindTouch.Dream.XUri,`0@)">
            <summary>
            Try to get the best matching parent uri.
            </summary>
            <param name="key">Uri to match.</param>
            <param name="value">When the method returns <see langword="True"/>, this variable contains the reference object for matched parent Uri.</param>
            <returns><see langword="True"/> if a match was found.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriMap`1.TryGetValue(MindTouch.Dream.XUri,`0@,System.Int32@)">
            <summary>
            Try to get the best matching parent uri.
            </summary>
            <param name="key">Uri to match.</param>
            <param name="value">When the method returns <see langword="True"/>, this variable contains the reference object for matched parent Uri.</param>
            <param name="similarity">When the method returns <see langword="True"/>, this variable contains of similarity match between the input and matched Uri.</param>
            <returns><see langword="True"/> if a match was found.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriMap`1.Add(MindTouch.Dream.XUri,`0)">
            <summary>
            Add a new entry to the map.
            </summary>
            <param name="key">Key Uri.</param>
            <param name="value">Reference object.</param>
        </member>
        <member name="M:MindTouch.Dream.XUriMap`1.Remove(MindTouch.Dream.XUri)">
            <summary>
            Remove an entry from the map by its key Uri.
            </summary>
            <param name="key">Key uri.</param>
            <returns><see langword="True"/> if the call found and removed an entry for the key.</returns>
        </member>
        <member name="M:MindTouch.Dream.XUriMap`1.GetValues(MindTouch.Dream.XUri)">
            <summary>
            Get all parent matches for a key.
            </summary>
            <param name="uri">Uri to match.</param>
            <returns>Enumerable of reference objects whose key Uri is a parent of the input uri.</returns>
        </member>
        <member name="P:MindTouch.Dream.XUriMap`1.Count">
            <summary>
            Total number of Uri's in map.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUriMap`1.Keys">
            <summary>
            Enumerable of all Uri's in map.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.XUriMap`1.Item(MindTouch.Dream.XUri)">
            <summary>
            Retrieve a reference object by it's Uri.
            </summary>
            <param name="key">Key uri.</param>
            <returns>Mapped reference object.</returns>
        </member>
        <member name="T:MindTouch.LogUtils">
            <summary>
            Provides extension and static helper methods for working with a log4Net <see cref="T:log4net.ILog"/> instance.
            </summary>
        </member>
        <member name="M:MindTouch.LogUtils.IsTraceEnabled(log4net.ILog)">
            <summary>
            Short-cut for <see cref="M:log4net.Core.ILogger.IsEnabledFor(log4net.Core.Level)"/> with <see cref="F:log4net.Core.Level.Trace"/>.
            </summary>
            <param name="log">Logger instance.</param>
            <returns><see langword="True"/> if the the logger is running trace loggging.</returns>
        </member>
        <member name="M:MindTouch.LogUtils.TraceMethodCall(log4net.ILog,System.String,System.Object[])">
            <summary>
            Log a method call at <see cref="F:log4net.Core.Level.Trace"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="method">Method name.</param>
            <param name="args">Method arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.TraceExceptionMethodCall(log4net.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Log an exception in a specific method at <see cref="F:log4net.Core.Level.Trace"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="exception">Exception that triggered this log call.</param>
            <param name="method">Method name.</param>
            <param name="args">Method arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.TraceFormat(log4net.ILog,System.String,System.Object[])">
            <summary>
            Log a formatted string at <see cref="F:log4net.Core.Level.Trace"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="format">A format string.</param>
            <param name="args">Format string parameters.</param>
        </member>
        <member name="M:MindTouch.LogUtils.DebugMethodCall(log4net.ILog,System.String,System.Object[])">
            <summary>
            Log a method call at <see cref="F:log4net.Core.Level.Debug"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="method">Method name.</param>
            <param name="args">Method arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.DebugExceptionMethodCall(log4net.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Log an exception in a specific method at <see cref="F:log4net.Core.Level.Debug"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="exception">Exception that triggered this log call.</param>
            <param name="method">Method name.</param>
            <param name="args">Method arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.DebugFormat(log4net.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Log an exception with a formatted text message.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="exception">Exception that triggered this log call.</param>
            <param name="message">Message format string.</param>
            <param name="args">Format arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.InfoMethodCall(log4net.ILog,System.String,System.Object[])">
            <summary>
            Log a method call at <see cref="F:log4net.Core.Level.Info"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="method">Method name.</param>
            <param name="args">Method arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.WarnMethodCall(log4net.ILog,System.String,System.Object[])">
            <summary>
            Log a method call at <see cref="F:log4net.Core.Level.Warn"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="method">Method name.</param>
            <param name="args">Method arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.WarnExceptionMethodCall(log4net.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Log an exception in a specific method at <see cref="F:log4net.Core.Level.Warn"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="exception">Exception that triggered this log call.</param>
            <param name="method">Method name.</param>
            <param name="args">Method arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.WarnExceptionFormat(log4net.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Log a formatted string message about an exception at <see cref="F:log4net.Core.Level.Warn"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="exception">Exception that triggered this log call.</param>
            <param name="format">A format string.</param>
            <param name="args">Format string parameters.</param>
        </member>
        <member name="M:MindTouch.LogUtils.ErrorExceptionMethodCall(log4net.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Log an exception in a specific method at <see cref="F:log4net.Core.Level.Error"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="exception">Exception that triggered this log call.</param>
            <param name="method">Method name.</param>
            <param name="args">Method arguments.</param>
        </member>
        <member name="M:MindTouch.LogUtils.ErrorExceptionFormat(log4net.ILog,System.Exception,System.String,System.Object[])">
            <summary>
            Log a formatted string message about an exception at <see cref="F:log4net.Core.Level.Error"/> level.
            </summary>
            <param name="log">Logger instance.</param>
            <param name="exception">Exception that triggered this log call.</param>
            <param name="format">A format string.</param>
            <param name="args">Format string parameters.</param>
        </member>
        <member name="M:MindTouch.LogUtils.CreateLog">
            <summary>
            Create an <see cref="T:log4net.ILog"/> instance for the enclosing type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.LogUtils.CreateLog``1">
            <summary>
            This methods is deprecated please use <see cref="M:MindTouch.LogUtils.CreateLog"/>instead.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:MindTouch.LogUtils.CreateLog(System.Type)">
            <summary>
            Create an <see cref="T:log4net.ILog"/> instance for a given type.
            </summary>
            <param name="classType">Type of class to create the logger for</param>
            <returns></returns>
        </member>
        <member name="T:MindTouch.Dream.PhpUtil">
            <summary>
            Provides static helper methods for Php Http interop.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.PhpUtil.UnixTimeZero">
            <summary>
            Unix "Epoch" time, i.e. seconds since January 1st, 1970, UTC.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.PhpUtil.ConvertToFormatString(System.String)">
            <summary>
            Convert a php $n placeholder convention format string to a .NET format string. 
            </summary>
            <param name="paramsString"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.PhpUtil.WritePhp(MindTouch.Xml.XDoc,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Convert an xml document into Php object notation.
            </summary>
            <param name="doc">Document to convert.</param>
            <param name="stream">Stream to write converted document to.</param>
            <param name="encoding">Encoding to use for output.</param>
        </member>
        <member name="T:System.ArrayDiffKind">
            <summary>
            Type of difference result comparing arrays
            </summary>
        </member>
        <member name="F:System.ArrayDiffKind.Same">
            <summary>
            Items in arrays that are the same.
            </summary>
        </member>
        <member name="F:System.ArrayDiffKind.Removed">
            <summary>
            Items removed from the first array.
            </summary>
        </member>
        <member name="F:System.ArrayDiffKind.Added">
            <summary>
            Items added to the first array.
            </summary>
        </member>
        <member name="F:System.ArrayDiffKind.RemovedLeft">
            <summary>
            Left Item was removed.
            </summary>
            <remarks>
            This is an ambigious result that can be avoided by usint <see cref="T:System.ArrayMergeDiffPriority"/>
            </remarks>
        </member>
        <member name="F:System.ArrayDiffKind.RemovedRight">
            <summary>
            Right Item was removed.
            </summary>
            <remarks>
            This is an ambigious result that can be avoided by usint <see cref="T:System.ArrayMergeDiffPriority"/>
            </remarks>
        </member>
        <member name="F:System.ArrayDiffKind.AddedLeft">
            <summary>
            Left Item was added.
            </summary>
            <remarks>
            This is an ambigious result that can be avoided by usint <see cref="T:System.ArrayMergeDiffPriority"/>
            </remarks>
        </member>
        <member name="F:System.ArrayDiffKind.AddedRight">
            <summary>
            Right Item was added.
            </summary>
            <remarks>
            This is an ambigious result that can be avoided by usint <see cref="T:System.ArrayMergeDiffPriority"/>
            </remarks>
        </member>
        <member name="T:System.ArrayMergeDiffPriority">
            <summary>
            Merge priority for diff operations.
            </summary>
            <remarks>
            This removes ambigious results
            </remarks>
        </member>
        <member name="F:System.ArrayMergeDiffPriority.None">
            <summary>
            No merge priority.
            </summary>
        </member>
        <member name="F:System.ArrayMergeDiffPriority.Left">
            <summary>
            Prefer left most items in diff result merge.
            </summary>
        </member>
        <member name="F:System.ArrayMergeDiffPriority.Right">
            <summary>
            Prefer right most items in diff result merge.
            </summary>
        </member>
        <member name="T:System.ArrayUtil">
            <summary>
            A static utility class containing helper and extension methods for working with <see cref="T:System.Array"/> instances.
            </summary>
        </member>
        <member name="M:System.ArrayUtil.ToDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0},System.Boolean)">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key selector function.
            </summary>
            <typeparam name="TKey">The type of the elements of source.</typeparam>
            <typeparam name="TValue">The type of the key returned by keySelector.</typeparam>
            <param name="collection">An <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a <see cref="T:System.Collections.Generic.Dictionary`2"/> from.</param>
            <param name="keySelector">A function to extract a key from each element.</param>
            <param name="overwriteDuplicates">
            If <see langword="True"/>, duplicate key values are overwritten as encountered, otherwise this method will throw 
            <see cref="T:System.ArgumentException"/> on key collision.
            </param>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2"/> that contains keys and values.</returns>
        </member>
        <member name="M:System.ArrayUtil.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Get a value from a dictionary or a default value if not found
            </summary>
            <typeparam name="TKey">Dictionary key type</typeparam>
            <typeparam name="TValue">Dictionary value type</typeparam>
            <param name="dictionary">The dictionary to operate on</param>
            <param name="key">Key to try to retrieve a value for</param>
            <param name="default">Default value to return should the key not exist</param>
            <returns>Either the value for the given key, or the default</returns>
        </member>
        <member name="M:System.ArrayUtil.SubArray``1(``0[],System.Int32)">
            <summary>
            Get a sub array.
            </summary>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items.</typeparam>
            <param name="array">The source array.</param>
            <param name="begin">The index at which to start the subarray at.</param>
            <returns>A new array containing a subset of the original array.</returns>
        </member>
        <member name="M:System.ArrayUtil.SubArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Get a sub array.
            </summary>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items.</typeparam>
            <param name="array">The source array.</param>
            <param name="begin">The index at which to start the subarray at.</param>
            <param name="end">The index of the last item to include in the subarray.</param>
            <returns>A new array containing a subset of the original array.</returns>
        </member>
        <member name="M:System.ArrayUtil.At``1(``0[],System.Int32)">
            <summary>
            Retrieve an element from an array using safe index value lookup.
            </summary>
            <remarks>
            The index is normalized to allow negative and out of range values.
            Negative values count from the end. Index values that are too large return the last value in the array.
            </remarks>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items.</typeparam>
            <param name="array">Source array.</param>
            <param name="index">Index value.</param>
            <returns>Value at array index.</returns>
        </member>
        <member name="M:System.ArrayUtil.AtAssign``1(``0[],System.Int32,``0)">
            <summary>
            Set the value of an element using safe index value lookup.
            </summary>
            <remarks>
            The index is normalized to allow negative and out of range values.
            Negative values count from the end. Index values that are too large return the last value in the array.
            </remarks>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items.</typeparam>
            <param name="array">Source array.</param>
            <param name="index">Index value.</param>
            <param name="value">Value to set.</param>
        </member>
        <member name="M:System.ArrayUtil.AsNameValueCollection(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Convert an enumerable of key/value pairs into a <see cref="T:System.Collections.Specialized.NameValueCollection"/>.
            </summary>
            <param name="enumerable">Enumerable of key/value pairs.</param>
            <returns>Collection of name/value pairs.</returns>
        </member>
        <member name="M:System.ArrayUtil.AddToNameValueCollection(System.Collections.Specialized.NameValueCollection,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Add an enumerable of key value pairs to a NameValueCollection.
            </summary>
            <param name="collection">NameValue collection to add pairs to.</param>
            <param name="enumerable">An enumerable of key/value pairs</param>
            <returns>The same collection provided as input to allow call chaining.</returns>
        </member>
        <member name="M:System.ArrayUtil.Get(System.Collections.Specialized.NameValueCollection,System.String)">
            <summary>
            Get the first value or null for a certain key from a <see cref="T:System.Collections.Specialized.NameValueCollection"/>. 
            </summary>
            <param name="collection">Collection to retrieve value from.</param>
            <param name="key">Key to retrieve value for.</param>
            <returns>First value for given key or null, if no values are defined for the key.</returns>
        </member>
        <member name="M:System.ArrayUtil.AddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Append an enumerable of values to an existing list.
            </summary>
            <typeparam name="TInput">Type of values in list and enumerable.</typeparam>
            <param name="list">List to add values to.</param>
            <param name="itemsToAdd">Enumerable of values to add.</param>
        </member>
        <member name="M:System.ArrayUtil.Concat``1(``0[][])">
            <summary>
            Concatenate all items in one or more multi-dimensional array into a single array.
            </summary>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items.</typeparam>
            <param name="arrays">One or more multi-dimensional arrays to concatenate.</param>
            <returns>New array containing all items from provided arrays.</returns>
        </member>
        <member name="M:System.ArrayUtil.Compare``1(``0[],``0[])">
            <summary>
            Compare two Arrays.
            </summary>
            <remarks>
            Compare first checks array lengths and then each item, returning either the size difference of the arrays or the 
            <see cref="M:System.IComparable`1.CompareTo(`0)"/> value of the first non-matching item.
            </remarks>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items. Must be <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="left">Array to compare.</param>
            <param name="right">Array to compare.</param>
            <returns>Either the size difference between the two arrays or the <see cref="M:System.IComparable`1.CompareTo(`0)"/> value of the first non-matching item.</returns>
        </member>
        <member name="M:System.ArrayUtil.Intersect``1(``0[],``0[])">
            <summary>
            Compute the intersection two arrays.
            </summary>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items. Must be <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="left">Left Hand Array to intersect.</param>
            <param name="right">Right Hand Array to intersect.</param>
            <returns>Array containing only the items that occur in both source arrays.</returns>
        </member>
        <member name="M:System.ArrayUtil.Intersect``1(``0[],``0[],System.Comparison{``0})">
            <summary>
            Compute the intersection two arrays.
            </summary>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items. Must be <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="left">Left Hand Array to intersect.</param>
            <param name="right">Right Hand Array to intersect.</param>
            <param name="comparison">Comparison delegate.</param>
            <returns>Array containing only the items that occur in both source arrays.</returns>
        </member>
        <member name="M:System.ArrayUtil.Union``1(``0[],``0[])">
            <summary>
            Compute the union of two arrays.
            </summary>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items. Must be <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="left">Source Array.</param>
            <param name="right">Source Array.</param>
            <returns>Array containing all unique items from the source arrays.</returns>
        </member>
        <member name="M:System.ArrayUtil.Union``1(``0[],``0[],System.Comparison{``0})">
            <summary>
            Compute the union of two arrays.
            </summary>
            <typeparam name="T">Type of <see cref="T:System.Array"/> items. Must be <see cref="T:System.IComparable`1"/>.</typeparam>
            <param name="left">Source Array.</param>
            <param name="right">Source Array.</param>
            <param name="comparison">Comparison delegate.</param>
            <returns>Array containing all unique items from the source arrays.</returns>
        </member>
        <member name="M:System.ArrayUtil.IsNullOrEmpty``1(System.Collections.Generic.IList{``0})">
            <summary>
            Indicates whether the specified list is null or empty.
            </summary>
            <typeparam name="T">Type of <see cref="T:System.Collections.Generic.IList`1"/> items.</typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:System.ArrayUtil.AreNullOrEqualLength(System.Array,System.Array)">
            <summary>
            Indicates whether the specified arrays are either both null or of the same length.
            </summary>
            <param name="left">Array to examine.</param>
            <param name="right">Array to examine.</param>
            <returns><see langword="true"/> if both arrays are either null or have the same length.</returns>
        </member>
        <member name="M:System.ArrayUtil.AllKeyValues(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Retrieve all key/value pairs from the collection as an enumerable collection.
            </summary>
            <param name="collection">NameValueCollection instance.</param>
            <returns>Enumerable collection of key/value pairs.</returns>
        </member>
        <member name="M:System.ArrayUtil.AllKeyValuePairs(System.Collections.Specialized.NameValueCollection)">
            <summary>
            Retrieve all key/value pairs from the collection as an array.
            </summary>
            <param name="collection">NameValueCollection instance.</param>
            <returns>Array of key/value pairs.</returns>
        </member>
        <member name="M:System.ArrayUtil.Diff``1(``0[],``0[],System.Int32,System.Equality{``0})">
            <summary>
            Compute an array of differences between two arrays.
            </summary>
            <typeparam name="T">Type of input array items.</typeparam>
            <param name="before">Array of original values.</param>
            <param name="after">Array of values after modification.</param>
            <param name="maxDelta">Maximum size for a diff.  If this exceeded, the method will return null.</param>
            <param name="equal">Delegate for value comparison.</param>
            <returns>Array of difference kind and value tuples.</returns>
        </member>
        <member name="M:System.ArrayUtil.MergeDiff``1(MindTouch.Tuplet{System.ArrayDiffKind,``0}[],MindTouch.Tuplet{System.ArrayDiffKind,``0}[],System.ArrayMergeDiffPriority,System.Equality{``0},System.Func{``0,System.Object},System.Boolean@)">
            <summary>
            Merge two diffs.
            </summary>
            <typeparam name="T">Type of value items in the provided diffs.</typeparam>
            <param name="left">Left hand diff.</param>
            <param name="right">Right hand diff.</param>
            <param name="priority">Priority of resolving ambigious <see cref="T:System.ArrayDiffKind"/> values.</param>
            <param name="equal">Equality delegate for value comparison.</param>
            <param name="track">Tracking function for correlating related diff items, in case on of the related items is ambigious.</param>
            <param name="hasConflicts">Indicator whether any conflicts were found.</param>
            <returns>Diff result of merge.</returns>
        </member>
        <member name="M:System.ArrayUtil.RemoveLast``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Removes the last occurrence of an item in a list.
            </summary>
            <typeparam name="T">Generic type of list.</typeparam>
            <param name="list">List from which to remove the item from.</param>
            <param name="item">Item to remove.</param>
        </member>
        <member name="M:System.ArrayUtil.Resize``1(``0[],System.Int32)">
            <summary>
            Resize(T[], int) is obsolete. Use SubArray(T[], int) instead.
            </summary>
        </member>
        <member name="M:System.ArrayUtil.AsHash``2(System.Collections.Generic.IEnumerable{``1},System.Converter{``1,``0})">
            <summary>
            AsHash&lt;K, V&gt;() is obsolete. Use IEnumerable&lt;T&gt;.ToDictionary&lt;T, K&gt;() extension method instead (requires System.Linq)
            </summary>
        </member>
        <member name="M:System.ArrayUtil.Select``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Select(IEnumerable&lt;T&gt;, Predicate&lt;T&gt;) is obsolete. Use IEnumerable&lt;T&gt;.Where(Func&lt;T, bool&gt;) instead (requires System.Linq).
            </summary>
        </member>
        <member name="M:System.ArrayUtil.Convert``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
            <summary>
            Convert(IEnumerable&lt;TInput&gt;, Converter&lt;TInput, TOutput&gt;) is obsolete. Use IEnumerable&lt;TInput&gt;.Select(Func&lt;TInput, TOutput&gt;) instead (requires System.Linq).
            </summary>
        </member>
        <member name="T:System.AssemblyUtil">
            <summary>
            Utility class containing Extension methods for inspecting Assemblies.
            </summary>
        </member>
        <member name="M:System.AssemblyUtil.GetBuildDate(System.Reflection.Assembly)">
            <summary>
            Get the build date of an assembly by inspecting the assembly file header.
            </summary>
            <param name="assembly">Assembly to inspect</param>
            <returns><see cref="T:System.DateTime"/> when then assembly was built.</returns>
        </member>
        <member name="M:System.AssemblyUtil.GetAttribute``1(System.Reflection.Assembly)">
            <summary>
            Get an assembly attribute by type.
            </summary>
            <typeparam name="T">Type of the assembly attribute to retrieve.</typeparam>
            <param name="assembly">Assembly to inspect.</param>
            <returns>Instance of the specified assembly attribute, or null if the attribute is not found.</returns>
        </member>
        <member name="T:System.CultureUtil">
            <summary>
            Static Utility class containing extension and helper methods for working with <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
        </member>
        <member name="M:System.CultureUtil.GetNonNeutralCulture(System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
            <summary>
            Get a non-neutral culture for a given culture
            </summary>
            <param name="culture">Source culture</param>
            <param name="default">Default culture to return should there no non-neutral culture exist for the input culture.</param>
            <returns>A non-neutral <see cref="T:System.Globalization.CultureInfo"/> instance.</returns>
        </member>
        <member name="M:System.CultureUtil.GetNonNeutralCulture(System.String)">
            <summary>
            Returns a non-neutral culture for a given language. Will return the specified culture, if it is already non-neutral
            or look up a matching non-neutral culture. Will only return null if no match can be found.
            </summary>
            <param name="language"></param>
            <returns>Non-neutral culture or null if no culture exists for specified language</returns>
        </member>
        <member name="T:System.DateTimeUtil">
            <summary>
            Static utility class containing extension and helper methods for working with <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="F:System.DateTimeUtil.Epoch">
            <summary>
            The Unix Epoch time, i.e. seconds since January 1, 1970 (UTC).
            </summary>
        </member>
        <member name="M:System.DateTimeUtil.ToSafeUniversalTime(System.DateTime)">
            <summary>
            Safely get the UTC <see cref="T:System.DateTime"/> for a given input.
            </summary>
            <remarks>
            Unlike <see cref="M:System.DateTime.ToUniversalTime"/>, this method will consider <see cref="F:System.DateTimeKind.Unspecified"/> source dates to 
            originate in the universal time zone.
            </remarks>
            <param name="date">Source date</param>
            <returns>Date in the UTC timezone.</returns>
        </member>
        <member name="M:System.DateTimeUtil.WithoutMilliseconds(System.DateTime)">
            <summary>
            Remove the millisecond component from a date.
            </summary>
            <param name="date">Source date.</param>
            <returns>DateTime with milliseconds truncated.</returns>
        </member>
        <member name="M:System.DateTimeUtil.WithoutMilliseconds(System.TimeSpan)">
            <summary>
            Remove the millisecond component from a timespan.
            </summary>
            <param name="timeSpan">Source timeSpan.</param>
            <returns>TimeSpan with milliseconds truncated.</returns>
        </member>
        <member name="M:System.DateTimeUtil.ToEpoch(System.DateTime)">
            <summary>
            Get the utc-based unix epoch time.
            </summary>
            <param name="date">Source date.</param>
            <returns>Seconds since January 1, 1970 (UTC).</returns>
        </member>
        <member name="M:System.DateTimeUtil.FromEpoch(System.UInt32)">
            <summary>
            Get a DateTime instance from utc-based unix epoch time.
            </summary>
            <param name="secondsSinceEpoch">Seconds since January 1, 1970 (UTC).</param>
            <returns>DateTime instance.</returns>
        </member>
        <member name="M:System.DateTimeUtil.ParseInvariant(System.String)">
            <summary>
            Parse a date using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">Source datetime string.</param>
            <returns>DateTime</returns>
        </member>
        <member name="M:System.DateTimeUtil.ParseExactInvariant(System.String,System.String)">
            <summary>
            Parse a date using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> and an exact date format.
            </summary>
            <param name="value">Source datetime string.</param>
            <param name="format">DateTime format string.</param>
            <returns>DateTime</returns>
        </member>
        <member name="M:System.DateTimeUtil.TryParseInvariant(System.String,System.DateTime@)">
            <summary>
            Try to parse a date using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">Source datetime string.</param>
            <param name="date">Output location</param>
            <returns><see langword="True"/> if a date was successfully parsed.</returns>
        </member>
        <member name="M:System.DateTimeUtil.TryParseExactInvariant(System.String,System.String,System.DateTime@)">
            <summary>
            Try to parse a date using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
            </summary>
            <param name="value">Source datetime string.</param>
            <param name="format">DateTime format string.</param>
            <param name="date">Output location</param>
            <returns><see langword="True"/> if a date was successfully parsed.</returns>
        </member>
        <member name="P:System.DateTimeUtil.UtcToday">
            <summary>
            Get today's date in UTC timezone.
            </summary>
        </member>
        <member name="T:System.CultureComparer">
            <summary>
            Implementation of <see cref="T:System.Collections.IComparer"/> based on <see cref="P:System.Globalization.CultureInfo.CompareInfo"/>.
            </summary>
        </member>
        <member name="M:System.CultureComparer.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Create comparer based on culture.
            </summary>
            <param name="culture">Culture to get <see cref="T:System.Globalization.CompareInfo"/> from.</param>
        </member>
        <member name="M:System.CultureComparer.Compare(System.Object,System.Object)">
            <summary>
            See <see cref="M:System.Collections.IComparer.Compare(System.Object,System.Object)"/>.
            </summary>
            <param name="x">The first object to compare.</param>
            <param name="y">The seccond object to compare. </param>
            <returns>Value Condition Less than zero x is less than y. Zero x equals y. Greater than zero x is greater than y.</returns>
        </member>
        <member name="T:System.StringUtil">
            <summary>
            Static utility class containing extension and helper methods for working with strings.
            </summary>
        </member>
        <member name="F:System.StringUtil.EmptyArray">
            <summary>
            An empty string array. Array counterpart to <see cref="F:System.String.Empty"/>.
            </summary>
        </member>
        <member name="M:System.StringUtil.ReplaceAll(System.String,System.String[])">
            <summary>
            Replace all occurences of a number of strings.
            </summary>
            <param name="source">Source string.</param>
            <param name="replacements">Array of strings to match and their replacements. Each string to be replaced at odd index i must have a replacement value at index i+1.</param>
            <returns>String with replacements performed on it.</returns>
        </member>
        <member name="M:System.StringUtil.ReplaceAll(System.String,System.StringComparison,System.String[])">
            <summary>
            Replace all occurences of a number of strings.
            </summary>
            <param name="source">Source string.</param>
            <param name="comparison">Type of string comparison to use.</param>
            <param name="replacements">Array of strings to match and their replacements. Each string to be replaced at odd index i must have a replacement value at index i+1.</param>
            <returns>String with replacements performed on it.</returns>
        </member>
        <member name="M:System.StringUtil.EncodeHtmlEntities(System.String)">
            <summary>
            Encode any html entities in a string.
            </summary>
            <param name="text">String to encode.</param>
            <returns>Encoded string.</returns>
        </member>
        <member name="M:System.StringUtil.EncodeHtmlEntities(System.String,System.Text.Encoding)">
            <summary>
            Encode any html entities in a string.
            </summary>
            <param name="text">String to encode.</param>
            <param name="encoding">Text encoding to use.</param>
            <returns>Encoded string.</returns>
        </member>
        <member name="M:System.StringUtil.EncodeHtmlEntities(System.String,System.Text.Encoding,System.Boolean)">
            <summary>
            Encode any html entities in a string.
            </summary>
            <param name="text">String to encode.</param>
            <param name="encoding">Text encoding to use.</param>
            <param name="useEntityNames">If <see langword="True"/>, encodes html entity using entity name rather than numeric entity code.</param>
            <returns>Encoded string.</returns>
        </member>
        <member name="M:System.StringUtil.DecodeHtmlEntities(System.String)">
            <summary>
            Decode Html entities.
            </summary>
            <param name="text">Html encoded string.</param>
            <returns>Decoded string.</returns>
        </member>
        <member name="M:System.StringUtil.EscapeString(System.String)">
            <summary>
            Escape string.
            </summary>
            <param name="text">Sources string.</param>
            <returns>Escaped string.</returns>
        </member>
        <member name="M:System.StringUtil.UnescapeString(System.String)">
            <summary>
            Unescape string.
            </summary>
            <param name="text">Escaped string.</param>
            <returns>Unescaped string.</returns>
        </member>
        <member name="M:System.StringUtil.QuoteString(System.String)">
            <summary>
            Escape string and quote the results.
            </summary>
            <param name="text">Source string.</param>
            <returns>Quoted string.</returns>
        </member>
        <member name="M:System.StringUtil.ReplaceWithinDelimiters(System.String,System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Replace the contents between delimiters
            </summary>
            <param name="text">Source text.</param>
            <param name="startDelimiter">Delimiter demarking the beginning of the string to be replaced.</param>
            <param name="endDelimiter">Delimiter demarking the end of the string to replaced.</param>
            <param name="replace">The value to replace the value between the delimters with.</param>
            <param name="comparison">The type of string comparison to use to match delimiters.</param>
            <returns>String with delimited text replaced.</returns>
        </member>
        <member name="M:System.StringUtil.ReplaceWithinDelimiters(System.String,System.String,System.String,System.Converter{System.String,System.String},System.StringComparison)">
            <summary>
            Replace the contents between delimiters
            </summary>
            <param name="text">Source text.</param>
            <param name="startDelimiter">Delimiter demarking the beginning of the string to be replaced.</param>
            <param name="endDelimiter">Delimiter demarking the end of the string to replaced.</param>
            <param name="callback">Callback for converting the text between delimiters into its replacement text.</param>
            <param name="comparison">The type of string comparison to use to match delimiters.</param>
            <returns>String with delimited text replaced.</returns>
        </member>
        <member name="M:System.StringUtil.RepeatPattern(System.String,System.Int32)">
            <summary>
            Create a string by repeating a pattern.
            </summary>
            <param name="pattern">Pattern to repeat.</param>
            <param name="count">Repetitions of pattern.</param>
            <returns>Pattern string.</returns>
        </member>
        <member name="M:System.StringUtil.GetAlternativeHashCode(System.String)">
            <summary>
            Alternative implementation of <see cref="M:System.Object.GetHashCode"/>.
            </summary>
            <param name="token">Token to hash.</param>
            <returns>Numeric hashcode.</returns>
        </member>
        <member name="M:System.StringUtil.GetAlternativeHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Alternative implementation of <see cref="M:System.Object.GetHashCode"/>.
            </summary>
            <param name="chars">Characters sequence to hash.</param>
            <param name="offset">Offset into sequence to start hash consideration.</param>
            <param name="length">Number of characters to consider for hash.</param>
            <returns>Numeric hashcode.</returns>
        </member>
        <member name="M:System.StringUtil.EqualsInvariant(System.String,System.String,System.Boolean)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.Equals(System.String)"/>
            </summary>
            <param name="left">Left-hand string to compare.</param>
            <param name="right">Right-hand string to compare.</param>
            <param name="ignoreCase"><see langword="True"/> if case should not be considered in comparison.</param>
            <returns><see langword="True"/> if left- and right-hand sides are equal.</returns>
        </member>
        <member name="M:System.StringUtil.EqualsInvariant(System.String,System.String)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.Equals(System.String)"/>
            </summary>
            <param name="left">Left-hand string to compare.</param>
            <param name="right">Right-hand string to compare.</param>
            <returns><see langword="True"/> if left- and right-hand sides are equal.</returns>
        </member>
        <member name="M:System.StringUtil.EqualsInvariantIgnoreCase(System.String,System.String)">
            <summary>
            Shortcut for case-insensitive, invariant <see cref="M:System.String.Equals(System.String)"/>
            </summary>
            <param name="left">Left-hand string to compare.</param>
            <param name="right">Right-hand string to compare.</param>
            <returns><see langword="True"/> if left- and right-hand sides are equal.</returns>
        </member>
        <member name="M:System.StringUtil.CompareInvariant(System.String,System.String,System.Boolean)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.Compare(System.String,System.String)"/>
            </summary>
            <param name="left">Left-hand string to compare.</param>
            <param name="right">Right-hand string to compare.</param>
            <param name="ignoreCase"><see langword="True"/> if case should not be considered in comparison.</param>
            <returns>
            A 32-bit signed integer indicating the lexical relationship between the two comparands.  Value Condition Less than zero 
            left is less than right. Zero left equals right. Greater than zero left is greater than right.
            </returns>
        </member>
        <member name="M:System.StringUtil.CompareInvariant(System.String,System.String)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.Compare(System.String,System.String)"/>
            </summary>
            <param name="left">Left-hand string to compare.</param>
            <param name="right">Right-hand string to compare.</param>
            <returns>
            A 32-bit signed integer indicating the lexical relationship between the two comparands.  Value Condition Less than zero 
            left is less than right. Zero left equals right. Greater than zero left is greater than right.
            </returns>
        </member>
        <member name="M:System.StringUtil.CompareInvariantIgnoreCase(System.String,System.String)">
            <summary>
            Shortcut for case-insensitive, invariant <see cref="M:System.String.Compare(System.String,System.String)"/>
            </summary>
            <param name="left">Left-hand string to compare.</param>
            <param name="right">Right-hand string to compare.</param>
            <returns>
            A 32-bit signed integer indicating the lexical relationship between the two comparands.  Value Condition Less than zero 
            left is less than right. Zero left equals right. Greater than zero left is greater than right.
            </returns>
        </member>
        <member name="M:System.StringUtil.StartsWithInvariant(System.String,System.String,System.Boolean)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.StartsWith(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to compare.</param>
            <param name="ignoreCase"><see langword="True"/> if case should not be considered in comparison.</param>
            <returns><see langword="True"/> if value matches the beginning of the input string; otherwise, <see langword="False"/>.</returns>
        </member>
        <member name="M:System.StringUtil.StartsWithInvariant(System.String,System.String)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.StartsWith(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to compare.</param>
            <returns><see langword="True"/> if value matches the beginning of the input string; otherwise, <see langword="False"/>.</returns>
        </member>
        <member name="M:System.StringUtil.StartsWithInvariantIgnoreCase(System.String,System.String)">
            <summary>
            Shortcut for case-insensitive, invariant <see cref="M:System.String.StartsWith(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to compare.</param>
            <returns><see langword="True"/> if value matches the beginning of the input string; otherwise, <see langword="False"/>.</returns>
        </member>
        <member name="M:System.StringUtil.EndsWithInvariant(System.String,System.String,System.Boolean)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.EndsWith(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to compare.</param>
            <param name="ignoreCase"><see langword="True"/> if case should not be considered in comparison.</param>
            <returns><see langword="True"/> if value matches the end of the input string; otherwise, <see langword="False"/>.</returns>
        </member>
        <member name="M:System.StringUtil.EndsWithInvariant(System.String,System.String)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.EndsWith(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to compare.</param>
            <returns><see langword="True"/> if value matches the end of the input string; otherwise, <see langword="False"/>.</returns>
        </member>
        <member name="M:System.StringUtil.EndsWithInvariantIgnoreCase(System.String,System.String)">
            <summary>
            Shortcut for case-insensitive, invariant <see cref="M:System.String.EndsWith(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to compare.</param>
            <returns><see langword="True"/> if value matches the end of the input string; otherwise, <see langword="False"/>.</returns>
        </member>
        <member name="M:System.StringUtil.IndexOfInvariant(System.String,System.String,System.Boolean)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.IndexOf(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to find.</param>
            <param name="ignoreCase"><see langword="True"/> if case should not be considered in comparison.</param>
            <returns>
            The zero-based index position of value if that string is found, or -1 if it is not. If value is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
        </member>
        <member name="M:System.StringUtil.IndexOfInvariant(System.String,System.String)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.IndexOf(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to find.</param>
            <returns>
            The zero-based index position of value if that string is found, or -1 if it is not. If value is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
        </member>
        <member name="M:System.StringUtil.IndexOfInvariantIgnoreCase(System.String,System.String)">
            <summary>
            Shortcut for case-insensitive, invariant <see cref="M:System.String.IndexOf(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to find.</param>
            <returns>
            The zero-based index position of value if that string is found, or -1 if it is not. If value is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
        </member>
        <member name="M:System.StringUtil.LastIndexOfInvariant(System.String,System.String,System.Boolean)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.LastIndexOf(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to find.</param>
            <param name="ignoreCase"><see langword="True"/> if case should not be considered in comparison.</param>
            <returns>
            The index position of the value parameter if that string is found, or -1 if it is not. If value is <see cref="F:System.String.Empty"/>, the return value is the last index position in this instance.
            </returns>
        </member>
        <member name="M:System.StringUtil.LastIndexOfInvariant(System.String,System.String)">
            <summary>
            Shortcut for invariant <see cref="M:System.String.LastIndexOf(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to find.</param>
            <returns>
            The index position of the value parameter if that string is found, or -1 if it is not. If value is <see cref="F:System.String.Empty"/>, the return value is the last index position in this instance.
            </returns>
        </member>
        <member name="M:System.StringUtil.LastIndexOfInvariantIgnoreCase(System.String,System.String)">
            <summary>
            Shortcut for case-insensitive, invariant <see cref="M:System.String.LastIndexOf(System.String)"/>
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to find.</param>
            <returns>
            The index position of the value parameter if that string is found, or -1 if it is not. If value is <see cref="F:System.String.Empty"/>, the return value is the last index position in this instance.
            </returns>
        </member>
        <member name="M:System.StringUtil.ContainsInvariant(System.String,System.String)">
            <summary>
            Determine whether a string is contained in another string using invariant comparison.
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to find.</param>
            <returns><see langword="True"/> if value is found in the input string; otherwise, <see langword="False"/>.</returns>
        </member>
        <member name="M:System.StringUtil.ContainsInvariantIgnoreCase(System.String,System.String)">
            <summary>
            Determine whether a string is contained in another string using case-insensitive, invariant comparison.
            </summary>
            <param name="text">Text to examine</param>
            <param name="value">The System.String to find.</param>
            <returns><see langword="True"/> if value is found in the input string; otherwise, <see langword="False"/>.</returns>
        </member>
        <member name="M:System.StringUtil.GetHashCodeInvariant(System.String,System.Boolean)">
            <summary>
            Get Hashcode for a string using the invariant comparer.
            </summary>
            <param name="text">Text to examine.</param>
            <param name="ignoreCase"><see langword="True"/> if case should not be considered in comparison.</param>
            <returns>Hashcode for the input string.</returns>
        </member>
        <member name="M:System.StringUtil.GetHashCodeInvariant(System.String)">
            <summary>
            Get Hashcode for a string using the invariant comparer.
            </summary>
            <param name="text">Text to examine.</param>
            <returns>Hashcode for the input string.</returns>
        </member>
        <member name="M:System.StringUtil.GetHashCodeInvariantIgnoreCase(System.String)">
            <summary>
            Get Hashcode for a string using the case-insensitive, invariant comparer.
            </summary>
            <param name="text">Text to examine.</param>
            <returns>Hashcode for the input string.</returns>
        </member>
        <member name="M:System.StringUtil.CreateAlphaNumericKey(System.Int32)">
            <summary>
            Compute a random alphanumeric value.
            </summary>
            <param name="length">Length of value to compute.</param>
            <returns>A random alphanumeric key value.</returns>
        </member>
        <member name="M:System.StringUtil.ComputeHash(System.String)">
            <summary>
            Compute the MD5 hash.
            </summary>
            <param name="text">Text to compute hash for.</param>
            <returns>MD5 hash.</returns>
        </member>
        <member name="M:System.StringUtil.ComputeHash(System.String,System.Text.Encoding)">
            <summary>
            Compute the MD5 hash.
            </summary>
            <param name="text">Text to compute hash for.</param>
            <param name="encoding">Encoding to use to get input string bytes.</param>
            <returns>MD5 hash.</returns>
        </member>
        <member name="M:System.StringUtil.ComputeHashString(System.String)">
            <summary>
            Compute the MD5 hash.
            </summary>
            <param name="text">Text to compute hash for.</param>
            <returns>MD5 hash string.</returns>
        </member>
        <member name="M:System.StringUtil.ComputeHashString(System.String,System.Text.Encoding)">
            <summary>
            Compute the MD5 hash.
            </summary>
            <param name="text">Text to compute hash for.</param>
            <param name="encoding">Encoding to use to get input string bytes.</param>
            <returns>MD5 hash string.</returns>
        </member>
        <member name="M:System.StringUtil.HexStringFromBytes(System.Byte[])">
            <summary>
            Convert bytes into a hex string.
            </summary>
            <param name="bytes">Input bytes.</param>
            <returns>Sequence of hexadecimal values for input byte array.</returns>
        </member>
        <member name="M:System.StringUtil.BytesFromHexString(System.String)">
            <summary>
            Convert a hex string to a bytes.
            </summary>
            <param name="text">A string containing a sequence of hexadecimal values.</param>
            <returns>Byte array.</returns>
        </member>
        <member name="M:System.StringUtil.IntToHexChar(System.Int32)">
            <summary>
            Convert an integer value to a hexadecimal value.
            </summary>
            <param name="n">Integer to convert.</param>
            <returns>Hexadecimal character.</returns>
        </member>
        <member name="M:System.StringUtil.IfNullOrEmpty(System.String,System.String)">
            <summary>
            Check if string is null or empty.  If so, return the alternative value.
            </summary>
            <param name="value">String to check.</param>
            <param name="alternative">String to return if first string is null or empty.</param>
            <returns></returns>
        </member>
        <member name="T:System.SvnRevisionAttribute">
            <summary>
            Assembly attribute used by MindTouch build system to track subversion revision number with the Assembly.
            </summary>
        </member>
        <member name="M:System.SvnRevisionAttribute.#ctor(System.Int32)">
            <summary>
            Default constructor used by Attribute syntax.
            </summary>
            <param name="revision">Subversion revision number for the Assembly.</param>
        </member>
        <member name="P:System.SvnRevisionAttribute.Revision">
            <summary>
            Accessor for revsion number attached via attribute.
            </summary>
        </member>
        <member name="T:System.SvnBranchAttribute">
            <summary>
            Assembly attribute used by MindTouch build system to track subversion branch name with the Assembly.
            </summary>
        </member>
        <member name="M:System.SvnBranchAttribute.#ctor(System.String)">
            <summary>
            Default constructor used by Attribute syntax.
            </summary>
            <param name="branch">Subversion branch name for Assembly.</param>
        </member>
        <member name="P:System.SvnBranchAttribute.Branch">
            <summary>
            Accessor for branch name attached via attribute.
            </summary>
        </member>
        <member name="T:System.Equality`1">
            <summary>
            Equality computation delegate.
            </summary>
            <typeparam name="T">Type of the values to be compared</typeparam>
            <param name="left">Left-hand value</param>
            <param name="right">Right-hand value</param>
            <returns><see langword="True"/> if left and right are the same value as determined by the delegate implementation.</returns>
        </member>
        <member name="T:System.Func`6">
            <summary>
            Encapsulates a method that has no parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <remarks>This definition extends the regular .NET Func definitions, which only cover 4 parameters.</remarks>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="item1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="item2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="item3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="item4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="item5">The fifth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:System.Func`7">
            <summary>
            Encapsulates a method that has no parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <remarks>This definition extends the regular .NET Func definitions, which only cover 4 parameters.</remarks>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="item1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="item2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="item3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="item4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="item5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="item6">The sixth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:System.Func`8">
            <summary>
            Encapsulates a method that has no parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <remarks>This definition extends the regular .NET Func definitions, which only cover 4 parameters.</remarks>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="item1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="item2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="item3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="item4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="item5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="item6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="item7">The seventh parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:System.Func`9">
            <summary>
            Encapsulates a method that has no parameters and returns a value of the type specified by the TResult parameter.
            </summary>
            <remarks>This definition extends the regular .NET Func definitions, which only cover 4 parameters.</remarks>
            <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
            <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
            <param name="item1">The first parameter of the method that this delegate encapsulates.</param>
            <param name="item2">The second parameter of the method that this delegate encapsulates.</param>
            <param name="item3">The third parameter of the method that this delegate encapsulates.</param>
            <param name="item4">The fourth parameter of the method that this delegate encapsulates.</param>
            <param name="item5">The fifth parameter of the method that this delegate encapsulates.</param>
            <param name="item6">The sixth parameter of the method that this delegate encapsulates.</param>
            <param name="item7">The seventh parameter of the method that this delegate encapsulates.</param>
            <param name="item8">The eighth parameter of the method that this delegate encapsulates.</param>
            <returns>The return value of the method that this delegate encapsulates.</returns>
        </member>
        <member name="T:MindTouch.ITuplet">
            <summary>
            Interface for a generic ordered list of items.
            </summary>
        </member>
        <member name="M:MindTouch.ITuplet.ToArray">
            <summary>
            Convert tuple into an array of elements.
            </summary>
            <returns>Array of objects.</returns>
        </member>
        <member name="P:MindTouch.ITuplet.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.ITuplet.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.ATuplet">
            <summary>
            Abstract base class for creating concretely sized Tuple classes.
            </summary>
        </member>
        <member name="M:MindTouch.ATuplet.#ctor">
            <summary>
            Create a new instance without initial values.
            </summary>
        </member>
        <member name="M:MindTouch.ATuplet.#ctor(System.Object[])">
            <summary>
            Create a new instances with initial values.
            </summary>
            <param name="items">Array of initial values.</param>
        </member>
        <member name="M:MindTouch.ATuplet.ToArray">
            <summary>
            Convert tuple into an array of elements.
            </summary>
            <returns>Array of objects.</returns>
        </member>
        <member name="M:MindTouch.ATuplet.ToString">
            <summary>
            Create a string representation of the Tuple
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="P:MindTouch.ATuplet.Count">
            <summary>
            Number of elements in the tuple
            </summary>
            <remarks>This Property is abstract and must be implemented by the implementing class</remarks>
        </member>
        <member name="P:MindTouch.ATuplet.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
            <remarks>This Property is abstract and must be implemented by the implementing class</remarks>
        </member>
        <member name="T:MindTouch.Tuplet">
            <summary>
            Empty Tuple
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="P:MindTouch.Tuplet.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`1">
            <summary>
            A Tuple of 1 item.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`1.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`1.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`1.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`1.#ctor(`0)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`1.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`1.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`2">
            <summary>
            A Tuple of 2 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
        </member>
        <member name="M:MindTouch.Tuplet`2.op_Implicit(MindTouch.Tuplet{`0,`1})~System.Collections.Generic.KeyValuePair{`0,`1}">
            <summary>
            Implict cast operator to convert this Tuple into a <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.
            </summary>
            <param name="tuplet">The Tuple to convert.</param>
            <returns>A new instance of <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</returns>
        </member>
        <member name="F:MindTouch.Tuplet`2.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`2.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`2.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`2.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`2.#ctor(`0,`1)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
        </member>
        <member name="M:MindTouch.Tuplet`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Create a new instance from a key/value pair.
            </summary>
            <param name="pair">Key/Value pair.</param>
        </member>
        <member name="P:MindTouch.Tuplet`2.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`2.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`3">
            <summary>
            A Tuple of 3 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`3.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`3.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`3.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`3.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`3.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`3.#ctor(`0,`1,`2)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`3.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`3.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`4">
            <summary>
            A Tuple of 4 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`4.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`4.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`4.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`4.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`4.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`4.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`4.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`4.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`5">
            <summary>
            A Tuple of 5 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`5.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`5.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`5.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`5.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`5.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`5.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`5.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`5.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`5.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`6">
            <summary>
            A Tuple of 6 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`6.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`6.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`6.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`6.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`6.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`6.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`6.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`6.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`6.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`6.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`7">
            <summary>
            A Tuple of 7 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`7.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`7.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`7.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`7.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`7.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`7.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`7.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`7.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`7.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`7.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`7.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`8">
            <summary>
            A Tuple of 8 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`8.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`8.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`8.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`8.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`8.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`8.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`8.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`8.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`8.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`8.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`8.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`8.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`9">
            <summary>
            A Tuple of 9 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
            <typeparam name="T9">The type of the nineth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`9.Item9">
            <summary>
            The nineth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`9.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`9.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`9.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
            <param name="t9">The nineth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`9.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`9.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`10">
            <summary>
            A Tuple of 10 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
            <typeparam name="T9">The type of the nineth item.</typeparam>
            <typeparam name="T10">The type of the tenth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item9">
            <summary>
            The nineth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`10.Item10">
            <summary>
            The tenth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`10.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`10.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`10.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
            <param name="t9">The nineth item.</param>
            <param name="t10">The tenth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`10.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`10.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`11">
            <summary>
            A Tuple of 11 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
            <typeparam name="T9">The type of the nineth item.</typeparam>
            <typeparam name="T10">The type of the tenth item.</typeparam>
            <typeparam name="T11">The type of the eleventh item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item9">
            <summary>
            The nineth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item10">
            <summary>
            The tenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`11.Item11">
            <summary>
            The eleventh item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`11.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`11.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`11.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
            <param name="t9">The nineth item.</param>
            <param name="t10">The tenth item.</param>
            <param name="t11">The eleventh item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`11.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`11.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`12">
            <summary>
            A Tuple of 12 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
            <typeparam name="T9">The type of the nineth item.</typeparam>
            <typeparam name="T10">The type of the tenth item.</typeparam>
            <typeparam name="T11">The type of the eleventh item.</typeparam>
            <typeparam name="T12">The type of the twelveth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item9">
            <summary>
            The nineth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item10">
            <summary>
            The tenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item11">
            <summary>
            The eleventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`12.Item12">
            <summary>
            The twelveth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`12.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`12.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`12.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
            <param name="t9">The nineth item.</param>
            <param name="t10">The tenth item.</param>
            <param name="t11">The eleventh item.</param>
            <param name="t12">The twelveth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`12.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`12.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`13">
            <summary>
            A Tuple of 14 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
            <typeparam name="T9">The type of the nineth item.</typeparam>
            <typeparam name="T10">The type of the tenth item.</typeparam>
            <typeparam name="T11">The type of the eleventh item.</typeparam>
            <typeparam name="T12">The type of the twelveth item.</typeparam>
            <typeparam name="T13">The type of the thirteenth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item9">
            <summary>
            The nineth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item10">
            <summary>
            The tenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item11">
            <summary>
            The eleventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item12">
            <summary>
            The twelveth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`13.Item13">
            <summary>
            The thirteenth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`13.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`13.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`13.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
            <param name="t9">The nineth item.</param>
            <param name="t10">The tenth item.</param>
            <param name="t11">The eleventh item.</param>
            <param name="t12">The twelveth item.</param>
            <param name="t13">The thirteenth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`13.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`13.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`14">
            <summary>
            A Tuple of 14 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
            <typeparam name="T9">The type of the nineth item.</typeparam>
            <typeparam name="T10">The type of the tenth item.</typeparam>
            <typeparam name="T11">The type of the eleventh item.</typeparam>
            <typeparam name="T12">The type of the twelveth item.</typeparam>
            <typeparam name="T13">The type of the thirteenth item.</typeparam>
            <typeparam name="T14">The type of the fourteenth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item9">
            <summary>
            The nineth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item10">
            <summary>
            The tenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item11">
            <summary>
            The eleventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item12">
            <summary>
            The twelveth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item13">
            <summary>
            The thirteenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`14.Item14">
            <summary>
            The fourteenth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`14.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`14.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`14.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
            <param name="t9">The nineth item.</param>
            <param name="t10">The tenth item.</param>
            <param name="t11">The eleventh item.</param>
            <param name="t12">The twelveth item.</param>
            <param name="t13">The thirteenth item.</param>
            <param name="t14">The fourteenth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`14.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`14.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`15">
            <summary>
            A Tuple of 15 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
            <typeparam name="T9">The type of the nineth item.</typeparam>
            <typeparam name="T10">The type of the tenth item.</typeparam>
            <typeparam name="T11">The type of the eleventh item.</typeparam>
            <typeparam name="T12">The type of the twelveth item.</typeparam>
            <typeparam name="T13">The type of the thirteenth item.</typeparam>
            <typeparam name="T14">The type of the fourteenth item.</typeparam>
            <typeparam name="T15">The type of the fifteenth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item9">
            <summary>
            The nineth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item10">
            <summary>
            The tenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item11">
            <summary>
            The eleventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item12">
            <summary>
            The twelveth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item13">
            <summary>
            The thirteenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item14">
            <summary>
            The fourteenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`15.Item15">
            <summary>
            The fifteenth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`15.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`15.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`15.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
            <param name="t9">The nineth item.</param>
            <param name="t10">The tenth item.</param>
            <param name="t11">The eleventh item.</param>
            <param name="t12">The twelveth item.</param>
            <param name="t13">The thirteenth item.</param>
            <param name="t14">The fourteenth item.</param>
            <param name="t15">The fifteenth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`15.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`15.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tuplet`16">
            <summary>
            A Tuple of 16 items.
            </summary>
            <typeparam name="T1">The type of the first item.</typeparam>
            <typeparam name="T2">The type of the second item.</typeparam>
            <typeparam name="T3">The type of the third item.</typeparam>
            <typeparam name="T4">The type of the fourth item.</typeparam>
            <typeparam name="T5">The type of the fifth item.</typeparam>
            <typeparam name="T6">The type of the sixth item.</typeparam>
            <typeparam name="T7">The type of the seventh item.</typeparam>
            <typeparam name="T8">The type of the eighth item.</typeparam>
            <typeparam name="T9">The type of the nineth item.</typeparam>
            <typeparam name="T10">The type of the tenth item.</typeparam>
            <typeparam name="T11">The type of the eleventh item.</typeparam>
            <typeparam name="T12">The type of the twelveth item.</typeparam>
            <typeparam name="T13">The type of the thirteenth item.</typeparam>
            <typeparam name="T14">The type of the fourteenth item.</typeparam>
            <typeparam name="T15">The type of the fifteenth item.</typeparam>
            <typeparam name="T16">The type of the sixteenth item.</typeparam>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item1">
            <summary>
            The first item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item2">
            <summary>
            The second item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item3">
            <summary>
            The third item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item4">
            <summary>
            The fourth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item5">
            <summary>
            The fifth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item6">
            <summary>
            The sixth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item7">
            <summary>
            The seventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item8">
            <summary>
            The eighth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item9">
            <summary>
            The nineth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item10">
            <summary>
            The tenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item11">
            <summary>
            The eleventh item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item12">
            <summary>
            The twelveth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item13">
            <summary>
            The thirteenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item14">
            <summary>
            The fourteenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item15">
            <summary>
            The fifteenth item.
            </summary>
        </member>
        <member name="F:MindTouch.Tuplet`16.Item16">
            <summary>
            The sixteenth item.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`16.#ctor">
            <summary>
            Create a new instance.
            </summary>
        </member>
        <member name="M:MindTouch.Tuplet`16.#ctor(System.Object[])">
            <summary>
            Create a new instance from a list of items.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MindTouch.Tuplet`16.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9,`10,`11,`12,`13,`14,`15)">
            <summary>
            Create a new instance with initial values for all items.
            </summary>
            <param name="t1">The first item.</param>
            <param name="t2">The second item.</param>
            <param name="t3">The third item.</param>
            <param name="t4">The fourth item.</param>
            <param name="t5">The fifth item.</param>
            <param name="t6">The sixth item.</param>
            <param name="t7">The seventh item.</param>
            <param name="t8">The eighth item.</param>
            <param name="t9">The nineth item.</param>
            <param name="t10">The tenth item.</param>
            <param name="t11">The eleventh item.</param>
            <param name="t12">The twelveth item.</param>
            <param name="t13">The thirteenth item.</param>
            <param name="t14">The fourteenth item.</param>
            <param name="t15">The fifteenth item.</param>
            <param name="t16">The sixteenth item.</param>
        </member>
        <member name="P:MindTouch.Tuplet`16.Count">
            <summary>
            Number of elements in the tuple
            </summary>
        </member>
        <member name="P:MindTouch.Tuplet`16.Item(System.Int32)">
            <summary>
            Accessor to tuple elements by position.
            </summary>
            <param name="index">Index of item.</param>
            <returns>Value of item.</returns>
        </member>
        <member name="T:MindTouch.Tasking.AsyncAllAlternatesFailed">
            <summary>
            Thrown when completion of all of a list of alternate synchronization handles fails.
            </summary>
            <remarks>Used by <see cref="M:MindTouch.Tasking.AResultEx.Alt(MindTouch.Tasking.Result[],MindTouch.Tasking.Result)"/> and <see cref="M:MindTouch.Tasking.AResultEx.Alt``1(MindTouch.Tasking.Result{``0}[],MindTouch.Tasking.Result{``0},System.Action{``0})"/>.</remarks>
            <seealso cref="M:MindTouch.Tasking.AResultEx.Alt(MindTouch.Tasking.Result[],MindTouch.Tasking.Result)"/>
            <seealso cref="M:MindTouch.Tasking.AResultEx.Alt``1(MindTouch.Tasking.Result{``0}[],MindTouch.Tasking.Result{``0},System.Action{``0})"/>
        </member>
        <member name="T:MindTouch.Tasking.Async">
            <summary>
            Static utility class containing extension and helper methods for handling asynchronous execution.
            </summary>
        </member>
        <member name="F:MindTouch.Tasking.Async.GlobalDispatchQueue">
            <summary>
            The globally accessible <see cref="T:MindTouch.Threading.IDispatchQueue"/> for dispatching work without queue affinity.
            </summary>
        </member>
        <member name="M:MindTouch.Tasking.Async.GetMaxThreads(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Get the maximum number of resources allowed for this process' execution environment.
            </summary>
            <param name="threads">Number of threads allowed.</param>
            <param name="ports">Number of completion ports allowed.</param>
            <param name="dispatchers">Number of dispatchers allowed.</param>
        </member>
        <member name="M:MindTouch.Tasking.Async.GetAvailableThreads(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Get the minimum number of resources allocated forthis process' execution environment.
            </summary>
            <param name="threads">Minimum number of threads allocated.</param>
            <param name="ports">Minimum number of completion ports allocated.</param>
            <param name="dispatchers">Minimum number of dispatchers allocated.</param>
        </member>
        <member name="M:MindTouch.Tasking.Async.Fork(System.Action)">
            <summary>
            Dispatch an action to be executed via the <see cref="F:MindTouch.Tasking.Async.GlobalDispatchQueue"/>.
            </summary>
            <param name="handler">Action to enqueue for execution.</param>
        </member>
        <member name="M:MindTouch.Tasking.Async.Fork(System.Action,MindTouch.Tasking.Result)">
            <summary>
            Dispatch an action to be executed via the <see cref="F:MindTouch.Tasking.Async.GlobalDispatchQueue"/>.
            </summary>
            <param name="handler">Action to enqueue for execution.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.Fork(System.Action,MindTouch.Tasking.TaskEnv,MindTouch.Tasking.Result)">
            <summary>
            Dispatch an action to be executed via the <see cref="F:MindTouch.Tasking.Async.GlobalDispatchQueue"/>.
            </summary>
            <param name="handler">Action to enqueue for execution.</param>
            <param name="env">Environment in which to execute the action.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.Fork``1(System.Func{``0},MindTouch.Tasking.Result{``0})">
            <summary>
            Dispatch an action to be executed via the <see cref="F:MindTouch.Tasking.Async.GlobalDispatchQueue"/>.
            </summary>
            <typeparam name="T">Type of result value produced by action.</typeparam>
            <param name="handler">Action to enqueue for execution.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.ForkThread(System.Action,MindTouch.Tasking.Result)">
            <summary>
            Dispatch an action to be executed with a new, dedicated backgrouns thread.
            </summary>
            <param name="handler">Action to enqueue for execution.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.ForkThread``1(System.Func{``0},MindTouch.Tasking.Result{``0})">
            <summary>
            Dispatch an action to be executed with a new, dedicated backgrouns thread.
            </summary>
            <typeparam name="T">Type of result value produced by action.</typeparam>
            <param name="handler">Action to enqueue for execution.</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.ForkThread(System.Action)">
            <summary>
            Dispatch an action to be executed with a new, dedicated backgrouns thread.
            </summary>
            <param name="handler">Action to enqueue for execution.</param>
        </member>
        <member name="M:MindTouch.Tasking.Async.Sleep(System.TimeSpan)">
            <summary>
            De-schedule the current execution environment to sleep for some period.
            </summary>
            <param name="duration">Time to sleep.</param>
            <returns>Synchronization handle to continue execution after the sleep period.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.WaitHandle(System.Threading.WaitHandle,MindTouch.Tasking.Result{System.Threading.WaitHandle})">
            <summary>
            Wrap a <see cref="M:MindTouch.Tasking.Async.WaitHandle(System.Threading.WaitHandle,MindTouch.Tasking.Result{System.Threading.WaitHandle})"/> with <see cref="T:MindTouch.Tasking.Result`1"/> to allow Result style synchronization with the handle.
            </summary>
            <param name="handle">The handle to wrap</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the action's execution.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.ExecuteProcess(System.String,System.String,System.IO.Stream,MindTouch.Tasking.Result{MindTouch.Tuplet{System.Int32,System.IO.Stream,System.IO.Stream}})">
            <summary>
            Execute a system process.
            </summary>
            <param name="application">Application to execute.</param>
            <param name="cmdline">Command line parameters for he application.</param>
            <param name="input">Input stream to pipe into the application.</param>
            <param name="result">The Result instance to be returned by this method.</param>
            <returns>Synchronization handle for the process execution, providing the application's exit code, output Stream and error Stream</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.ExecuteProcess(System.String,System.String,System.IO.Stream,System.IO.Stream,System.IO.Stream,MindTouch.Tasking.Result{System.Int32})">
            <summary>
            Execute a system process.
            </summary>
            <param name="application">Application to execute.</param>
            <param name="cmdline">Command line parameters for he application.</param>
            <param name="input">Input stream to pipe into the application.</param>
            <param name="output"></param>
            <param name="error"></param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for the process execution, providing the application's exit code</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,MindTouch.Tasking.Result)">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <param name="begin">Lambda wrapping a no-arg async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,MindTouch.Tasking.Result)">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T1">Type of asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a single argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">Asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,MindTouch.Tasking.Result)">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 2 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,MindTouch.Tasking.Result)">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <typeparam name="T3">Type of third asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 3 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="item3">Third asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``4(System.Func{``0,``1,``2,``3,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,``3,System.Object,MindTouch.Tasking.Result)">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <typeparam name="T3">Type of third asynchronous method argument.</typeparam>
            <typeparam name="T4">Type of fourth asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 4 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="item3">Third asynchronous method argument.</param>
            <param name="item4">Fourth asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``5(System.Func{``0,``1,``2,``3,``4,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,``3,``4,System.Object,MindTouch.Tasking.Result)">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <typeparam name="T3">Type of third asynchronous method argument.</typeparam>
            <typeparam name="T4">Type of fourth asynchronous method argument.</typeparam>
            <typeparam name="T5">Type of fifth asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 5 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="item3">Third asynchronous method argument.</param>
            <param name="item4">Fourth asynchronous method argument.</param>
            <param name="item5">Fifth asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``6(System.Func{``0,``1,``2,``3,``4,``5,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,``3,``4,``5,System.Object,MindTouch.Tasking.Result)">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <typeparam name="T3">Type of third asynchronous method argument.</typeparam>
            <typeparam name="T4">Type of fourth asynchronous method argument.</typeparam>
            <typeparam name="T5">Type of fifth asynchronous method argument.</typeparam>
            <typeparam name="T6">Type of sixth asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 6 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="item3">Third asynchronous method argument.</param>
            <param name="item4">Fourth asynchronous method argument.</param>
            <param name="item5">Fifth asynchronous method argument.</param>
            <param name="item6">Sixth asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,MindTouch.Tasking.Result{``0})">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T">Type of the asynchronous method return value.</typeparam>
            <param name="begin">Lambda wrapping a no argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle providing result value T.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``2(System.Func{``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},``1,System.Object,MindTouch.Tasking.Result{``0})">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T">Type of the asynchronous method return value.</typeparam>
            <typeparam name="T1">Type of asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a single argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">Asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle providing result value T.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``3(System.Func{``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},``1,``2,System.Object,MindTouch.Tasking.Result{``0})">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T">Type of the asynchronous method return value.</typeparam>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 2 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle providing result value T.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``4(System.Func{``1,``2,``3,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},``1,``2,``3,System.Object,MindTouch.Tasking.Result{``0})">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T">Type of the asynchronous method return value.</typeparam>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <typeparam name="T3">Type of third asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 3 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="item3">Third asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle providing result value T.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``5(System.Func{``1,``2,``3,``4,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},``1,``2,``3,``4,System.Object,MindTouch.Tasking.Result{``0})">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T">Type of the asynchronous method return value.</typeparam>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <typeparam name="T3">Type of third asynchronous method argument.</typeparam>
            <typeparam name="T4">Type of fourth asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 4 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="item3">Third asynchronous method argument.</param>
            <param name="item4">Fourth asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle providing result value T.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``6(System.Func{``1,``2,``3,``4,``5,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},``1,``2,``3,``4,``5,System.Object,MindTouch.Tasking.Result{``0})">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T">Type of the asynchronous method return value.</typeparam>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <typeparam name="T3">Type of third asynchronous method argument.</typeparam>
            <typeparam name="T4">Type of fourth asynchronous method argument.</typeparam>
            <typeparam name="T5">Type of fifth asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 5 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="item3">Third asynchronous method argument.</param>
            <param name="item4">Fourth asynchronous method argument.</param>
            <param name="item5">Fifth asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle providing result value T.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.From``7(System.Func{``1,``2,``3,``4,``5,``6,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},``1,``2,``3,``4,``5,``6,System.Object,MindTouch.Tasking.Result{``0})">
            <summary>
            Convert an asynchronous call using the <see cref="T:System.AsyncCallback"/> pattern into one using a <see cref="T:MindTouch.Tasking.Result"/> synchronization handle.
            </summary>
            <typeparam name="T">Type of the asynchronous method return value.</typeparam>
            <typeparam name="T1">Type of first asynchronous method argument.</typeparam>
            <typeparam name="T2">Type of second asynchronous method argument.</typeparam>
            <typeparam name="T3">Type of third asynchronous method argument.</typeparam>
            <typeparam name="T4">Type of fourth asynchronous method argument.</typeparam>
            <typeparam name="T5">Type of fifth asynchronous method argument.</typeparam>
            <typeparam name="T6">Type of sixth asynchronous method argument.</typeparam>
            <param name="begin">Lambda wrapping a 6 argument async call.</param>
            <param name="end">Action to execute on async completion.</param>
            <param name="item1">First asynchronous method argument.</param>
            <param name="item2">Second asynchronous method argument.</param>
            <param name="item3">Third asynchronous method argument.</param>
            <param name="item4">Fourth asynchronous method argument.</param>
            <param name="item5">Fifth asynchronous method argument.</param>
            <param name="item6">Sixth asynchronous method argument.</param>
            <param name="state">State object</param>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result`1"/>instance to be returned by this method.</param>
            <returns>Synchronization handle providing result value T.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.WaitFor(System.Threading.WaitHandle,System.TimeSpan)">
            <summary>
            Waits for handle to be set.
            </summary>
            <param name="handle">Handle to wait on.</param>
            <param name="timeout">Timeout period. Use <cref see="TimeSpan"/>.MaxValue for no timeout.</param>
            <returns>Returns true if the handle was set before the timeout, false otherwise.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Async.WaitFor(MindTouch.Threading.MonitorSemaphore,System.TimeSpan)">
            <summary>
            Waits for event to be signaled.
            </summary>
            <param name="monitor">Event to wait on.</param>
            <param name="timeout">Timeout period. Use <cref see="TimeSpan"/>.MaxValue for no timeout.</param>
            <returns>Returns true if the event was signaled before the timeout, false otherwise.</returns>
        </member>
        <member name="P:MindTouch.Tasking.Async.CurrentDispatchQueue">
            <summary>
            The <see cref="T:MindTouch.Threading.IDispatchQueue"/> used by the current execution environment.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Async.MaxStackSize">
            <summary>
            The maximum stack size that Threads created by Dream (<see cref="T:MindTouch.Threading.ElasticThreadPool"/>, <see cref="M:MindTouch.Tasking.Async.Fork(System.Action)"/>, <see cref="M:MindTouch.Tasking.Async.ForkThread(System.Action)"/>, etc.)
            should use. If null, uses process default stack size.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineHandler`1">
            <summary>
            Signature for a no argument Coroutine.
            </summary>
            <typeparam name="TResult">Type of synchronization handle. Expected to be subclass of <see cref="T:MindTouch.Tasking.AResult"/>.</typeparam>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineHandler`2">
            <summary>
            Signature for a one argument Coroutine.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="TResult">Type of synchronization handle. Expected to be subclass of <see cref="T:MindTouch.Tasking.AResult"/>.</typeparam>
            <param name="arg1">First coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineHandler`3">
            <summary>
            Signature for a two argument Coroutine.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="TResult">Type of synchronization handle. Expected to be subclass of <see cref="T:MindTouch.Tasking.AResult"/>.</typeparam>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineHandler`4">
            <summary>
            Signature for a three argument Coroutine.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="TResult">Type of synchronization handle. Expected to be subclass of <see cref="T:MindTouch.Tasking.AResult"/>.</typeparam>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineHandler`5">
            <summary>
            Signature for a four argument Coroutine.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="T4">Type of the fourth argument.</typeparam>
            <typeparam name="TResult">Type of synchronization handle. Expected to be subclass of <see cref="T:MindTouch.Tasking.AResult"/>.</typeparam>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="arg4">Fourth coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineHandler`6">
            <summary>
            Signature for a five argument Coroutine.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="T4">Type of the fourth argument.</typeparam>
            <typeparam name="T5">Type of the fifth argument.</typeparam>
            <typeparam name="TResult">Type of synchronization handle. Expected to be subclass of <see cref="T:MindTouch.Tasking.AResult"/>.</typeparam>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="arg4">Fourth coroutine argument.</param>
            <param name="arg5">Fifth coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineHandler`7">
            <summary>
            Signature for a six argument Coroutine.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="T4">Type of the fourth argument.</typeparam>
            <typeparam name="T5">Type of the fifth argument.</typeparam>
            <typeparam name="T6">Type of the sixth argument.</typeparam>
            <typeparam name="TResult">Type of synchronization handle. Expected to be subclass of <see cref="T:MindTouch.Tasking.AResult"/>.</typeparam>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="arg4">Fourth coroutine argument.</param>
            <param name="arg5">Fifth coroutine argument.</param>
            <param name="arg6">Sixth coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Tasking.CoroutineHandler`8">
            <summary>
            Signature for a seven argument Coroutine.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="T4">Type of the fourth argument.</typeparam>
            <typeparam name="T5">Type of the fifth argument.</typeparam>
            <typeparam name="T6">Type of the sixth argument.</typeparam>
            <typeparam name="T7">Type of the seventh argument.</typeparam>
            <typeparam name="TResult">Type of synchronization handle. Expected to be subclass of <see cref="T:MindTouch.Tasking.AResult"/>.</typeparam>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="arg4">Fourth coroutine argument.</param>
            <param name="arg5">Fifth coroutine argument.</param>
            <param name="arg6">Sixth coroutine argument.</param>
            <param name="arg7">Seventh coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="T:MindTouch.Tasking.Coroutine">
            <summary>
            Provides an execution framework for a special type of methods, called Coroutines.
            </summary>
            <remarks>
            Coroutines are methods that can yield their execution by using the <see langword="yield"/> keyword. To be a coroutine,
            a method's signature must match one of the <see cref="T:MindTouch.Tasking.CoroutineHandler`1"/> delegates, i.e. it will always have a
            return type of <see cref="T:System.Collections.Generic.IEnumerator`1"/> and the last argument is always a subclass of <see cref="T:MindTouch.Tasking.AResult"/>.
            </remarks>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke``1(MindTouch.Tasking.CoroutineHandler{``0},``0)">
            <summary>
            Invoke a no argument Coroutine. Static shortcut for <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> member.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="callee">Method to invoke as coroutine.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke``2(MindTouch.Tasking.CoroutineHandler{``0,``1},``0,``1)">
            <summary>
            Invoke a one argument Coroutine. Static shortcut for <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> member.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="callee">Method to invoke as coroutine.</param>
            <param name="arg1">First coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke``3(MindTouch.Tasking.CoroutineHandler{``0,``1,``2},``0,``1,``2)">
            <summary>
            Invoke a two argument Coroutine. Static shortcut for <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> member.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="callee">Method to invoke as coroutine.</param>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke``4(MindTouch.Tasking.CoroutineHandler{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>
            Invoke a three argument Coroutine. Static shortcut for <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> member.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="callee">Method to invoke as coroutine.</param>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke``5(MindTouch.Tasking.CoroutineHandler{``0,``1,``2,``3,``4},``0,``1,``2,``3,``4)">
            <summary>
            Invoke a four argument Coroutine. Static shortcut for <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> member.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="T4">Type of the fourth argument.</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="callee">Method to invoke as coroutine.</param>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="arg4">Fourth coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke``6(MindTouch.Tasking.CoroutineHandler{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4,``5)">
            <summary>
            Invoke a five argument Coroutine. Static shortcut for <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> member.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="T4">Type of the fourth argument.</typeparam>
            <typeparam name="T5">Type of the fifth argument.</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="callee">Method to invoke as coroutine.</param>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="arg4">Fourth coroutine argument.</param>
            <param name="arg5">Fifth coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke``7(MindTouch.Tasking.CoroutineHandler{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            Invoke a six argument Coroutine. Static shortcut for <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> member.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="T4">Type of the fourth argument.</typeparam>
            <typeparam name="T5">Type of the fifth argument.</typeparam>
            <typeparam name="T6">Type of the sixth argument.</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="callee">Method to invoke as coroutine.</param>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="arg4">Fourth coroutine argument.</param>
            <param name="arg5">Fifth coroutine argument.</param>
            <param name="arg6">Sixth coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke``8(MindTouch.Tasking.CoroutineHandler{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            Invoke a  seven argument Coroutine. Static shortcut for <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> member.
            </summary>
            <typeparam name="T1">Type of the first argument.</typeparam>
            <typeparam name="T2">Type of the second argument.</typeparam>
            <typeparam name="T3">Type of the third argument.</typeparam>
            <typeparam name="T4">Type of the fourth argument.</typeparam>
            <typeparam name="T5">Type of the fifth argument.</typeparam>
            <typeparam name="T6">Type of the sixth argument.</typeparam>
            <typeparam name="T7">Type of the seventh argument.</typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="callee">Method to invoke as coroutine.</param>
            <param name="arg1">First coroutine argument.</param>
            <param name="arg2">Second coroutine argument.</param>
            <param name="arg3">Third coroutine argument.</param>
            <param name="arg4">Fourth coroutine argument.</param>
            <param name="arg5">Fifth coroutine argument.</param>
            <param name="arg6">Sixth coroutine argument.</param>
            <param name="arg7">Seventh coroutine argument.</param>
            <param name="result">
            The result instance to be returned by the call to <see cref="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})"/> that executes this coroutine.
            </param>
            <returns>Iterator used by <see cref="T:MindTouch.Tasking.Coroutine"/>.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.#ctor(System.Delegate,MindTouch.Tasking.AResult)">
            <summary>
            Create a new Coroutine instance from a delegate.
            </summary>
            <remarks>
            Consider using one of the static Invoke methods instead.
            </remarks>
            <param name="callee">Delegate to method to be invoked as a coroutine.</param>
            <param name="result">Synchronization handle.</param>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.#ctor(System.Reflection.MethodInfo,MindTouch.Tasking.AResult)">
            <summary>
            Create a new Coroutine instance from a method
            </summary>
            <param name="method">Info for method to be invoked as a coroutine.</param>
            <param name="result">Synchronization handle.</param>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.GetStackTrace">
            <summary>
            Get a coroutine specific stacktrace, i.e. following the coroutine invocation stack rather than the thread call stack.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Invoke(System.Func{System.Collections.Generic.IEnumerator{MindTouch.Tasking.IYield}})">
            <summary>
            Invoke the coroutine.
            </summary>
            <param name="invocation"></param>
        </member>
        <member name="M:MindTouch.Tasking.Coroutine.Continue">
            <summary>
            Continue execution of a suspended coroutine.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Coroutine.Current">
            <summary>
            The current <see cref="T:MindTouch.Tasking.Coroutine"/> instance, if executing in a coroutine contex.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Coroutine.Method">
            <summary>
            Method that this Coroutine is executing. 
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Coroutine.FullName">
            <summary>
            Full name of the method being called as a coroutine.
            </summary>
        </member>
        <member name="T:MindTouch.Tasking.Lock`1">
            <summary>
            Provides a generic mechanism for synchronizing access to a value.
            </summary>
            <typeparam name="T">Type of value the lock can synchronize access for.</typeparam>
        </member>
        <member name="M:MindTouch.Tasking.Lock`1.#ctor(`0)">
            <summary>
            Create a new lock for a value.
            </summary>
            <param name="value">Value to lock.</param>
        </member>
        <member name="M:MindTouch.Tasking.Lock`1.Capture(MindTouch.Tasking.Result)">
            <summary>
            Capture the lock.
            </summary>
            <param name="result">The <see cref="T:MindTouch.Tasking.Result"/>instance to be returned by this method.</param>
            <returns>Synchronization handle for capturing the lock.</returns>
        </member>
        <member name="M:MindTouch.Tasking.Lock`1.Release">
            <summary>
            Release the captured lock.
            </summary>
        </member>
        <member name="P:MindTouch.Tasking.Lock`1.Value">
            <summary>
            Retrieve the value if the lock has been captured. Throws <see cref="T:System.InvalidOperationException"/> if the lock has not yet been captured.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.TaskTimerStatus">
            <summary>
            Possible <see cref="T:MindTouch.Dream.TaskTimer"/> states
            </summary>
        </member>
        <member name="F:MindTouch.Dream.TaskTimerStatus.Done">
            <summary>
            The timer has completed.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.TaskTimerStatus.Pending">
            <summary>
            The timer is pending execution.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.TaskTimerStatus.Queued">
            <summary>
            The timer is queued for later execution.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.TaskTimerStatus.Locked">
            <summary>
            The timer is locked.
            </summary>
        </member>
        <member name="T:MindTouch.Dream.TaskTimer">
            <summary>
            Provides a mechanism for invoking an action at future time. 
            </summary>
        </member>
        <member name="M:MindTouch.Dream.TaskTimer.New(System.DateTime,System.Action{MindTouch.Dream.TaskTimer},System.Object,MindTouch.Tasking.TaskEnv)">
            <summary>
            This method is obsolete. Use <see cref="M:MindTouch.Tasking.TaskTimerFactory.New(System.DateTime,System.Action{MindTouch.Dream.TaskTimer},System.Object,MindTouch.Tasking.TaskEnv)"/> instead.
            </summary>
            <param name="when"></param>
            <param name="handler"></param>
            <param name="state"></param>
            <param name="env"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.TaskTimer.New(System.TimeSpan,System.Action{MindTouch.Dream.TaskTimer},System.Object,MindTouch.Tasking.TaskEnv)">
            <summary>
            This methods is obsolete. Use <see cref="M:MindTouch.Tasking.TaskTimerFactory.New(System.TimeSpan,System.Action{MindTouch.Dream.TaskTimer},System.Object,MindTouch.Tasking.TaskEnv)"/> instead.
            </summary>
            <param name="when"></param>
            <param name="handler"></param>
            <param name="state"></param>
            <param name="env"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Dream.TaskTimer.Shutdown">
            <summary>
            This method is obsolete. Use <see cref="M:MindTouch.Tasking.TaskTimerFactory.Shutdown"/>  instead.
            </summary>
        </member>
        <member name="F:MindTouch.Dream.TaskTimer.State">
            <summary>
            State object.
            </summary>
        </member>
        <member name="M:MindTouch.Dream.TaskTimer.#ctor(System.Action{MindTouch.Dream.TaskTimer},System.Object)">
            <summary>
            This constructor is obsolete. Use <see cref="M:MindTouch.Tasking.TaskTimerFactory.New(System.Action{MindTouch.Dream.TaskTimer},System.Object)"/> instead.
            </summary>
            <param name="handler"></param>
            <param name="state"></param>
        </member>
        <member name="M:MindTouch.Dream.TaskTimer.Change(System.TimeSpan,MindTouch.Tasking.TaskEnv)">
            <summary>
            Change when the timer will execute.
            </summary>
            <param name="timespan">The relative time.</param>
            <param name="env">The environment to use for invocation.</param>
        </member>
        <member name="M:MindTouch.Dream.TaskTimer.Change(System.DateTime,MindTouch.Tasking.TaskEnv)">
            <summary>
            Change when the timer will execute.
            </summary>
            <param name="when">The absolute time.</param>
            <param name="env">The environment to use for invocation.</param>
        </member>
        <member name="M:MindTouch.Dream.TaskTimer.Cancel">
            <summary>
            Cancel the scheduled invocation.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.TaskTimer.Retries">
            <summary>
            Number of times the timer has retried a state change.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.TaskTimer.When">
            <summary>
            The time when the timer is scheduled to fire.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.TaskTimer.Status">
            <summary>
            Timer status.
            </summary>
        </member>
        <member name="P:MindTouch.Dream.TaskTimer.Handler">
            <summary>
            The action that will be invoked at fire time.
            </summary>
        </member>
        <member name="T:MindTouch.Threading.ElasticThreadPool">
            <summary>
            ElasticThreadPool provides a thread pool that can have a variable number of threads going from a minimum number of reserved threads
            to a maximum number of parallel threads.
            </summary>
            <remarks>
            The threads are obtained from the DispatchThreadScheduler and shared across all other clients of the DispatchThreadScheduler.
            Obtained threads are released automatically if the thread pool is idle for long enough.  Reserved threads are never released.
            </remarks>
        </member>
        <member name="F:MindTouch.Threading.ElasticThreadPool.MAX_RESERVED_THREADS">
            <summary>
            Maximum number of threads that can be reserved by a single instance.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.ElasticThreadPool.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new ElasticThreadPool instance.
            </summary>
            <param name="minReservedThreads">Minium number of threads to reserve for the thread pool.</param>
            <param name="maxParallelThreads">Maximum number of parallel threads used by the thread pool.</param>
            <exception cref="T:MindTouch.InsufficientResourcesException">The ElasticThreadPool instance was unable to obtain the minimum reserved threads.</exception>
        </member>
        <member name="M:MindTouch.Threading.ElasticThreadPool.QueueWorkItem(System.Action)">
            <summary>
            Adds an item to the thread pool.
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
        </member>
        <member name="M:MindTouch.Threading.ElasticThreadPool.TryQueueWorkItem(System.Action)">
            <summary>
            Adds an item to the thread pool.
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
            <returns>Always returns true.</returns>
        </member>
        <member name="M:MindTouch.Threading.ElasticThreadPool.Dispose">
            <summary>
            Shutdown the ElasticThreadPool instance.  This method blocks until all pending items have finished processing.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.ElasticThreadPool.ToString">
            <summary>
            Convert the dispatch queue into a string.
            </summary>
            <returns>String.</returns>
        </member>
        <member name="P:MindTouch.Threading.ElasticThreadPool.MinReservedThreads">
            <summary>
            Number of minimum reserved threads.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.ElasticThreadPool.MaxParallelThreads">
            <summary>
            Number of maxium parallel threads.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.ElasticThreadPool.ThreadCount">
            <summary>
            Number of threads currently used.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.ElasticThreadPool.WorkItemCount">
            <summary>
            Number of items pending for execution.
            </summary>
        </member>
        <member name="T:MindTouch.Threading.ImmediateDispatchQueue">
            <summary>
            Provides an implementation of <see cref="T:MindTouch.Threading.IDispatchQueue"/> that immediately invokes the work item
            rather than queueing t for execution.
            </summary>
        </member>
        <member name="F:MindTouch.Threading.ImmediateDispatchQueue.Instance">
            <summary>
            Singleton instnace of the <see cref="T:MindTouch.Threading.ImmediateDispatchQueue"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.ImmediateDispatchQueue.QueueWorkItem(System.Action)">
            <summary>
            Adds a work-item to the thread pool.  Depending on the implementation, this method may block the invoker
            or throw an exception if the thread pool cannot accept more items.
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
        </member>
        <member name="M:MindTouch.Threading.ImmediateDispatchQueue.TryQueueWorkItem(System.Action)">
            <summary>
            In the context of this implementation, <see cref="M:MindTouch.Threading.ImmediateDispatchQueue.TryQueueWorkItem(System.Action)"/> behaves identically to <see cref="M:MindTouch.Threading.ImmediateDispatchQueue.QueueWorkItem(System.Action)"/>
            and will always return <see langword="True"/>.
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
            <returns>Always returns <see langword="True"/>.</returns>
        </member>
        <member name="M:MindTouch.Threading.ImmediateDispatchQueue.ToString">
            <summary>
            Convert the dispatch queue into a string.
            </summary>
            <returns>String.</returns>
        </member>
        <member name="T:MindTouch.Threading.LegacyThreadPool">
            <summary>
            LegacyThreadPool is a singleton class that provides an IDispatchQueue interface to the System.Threading.ThreadPool class.
            </summary>
        </member>
        <member name="F:MindTouch.Threading.LegacyThreadPool.Instance">
            <summary>
            Unique instance for interacting with System.Threading.ThreadPool class using the IDispatchQueue interface.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown when System.Threading.ThreadPool cannot accept the work-item.</exception>
        </member>
        <member name="M:MindTouch.Threading.LegacyThreadPool.QueueWorkItem(System.Action)">
            <summary>
            Adds an item to the thread pool.  This method is implemented using System.Threading.ThreadPool::UnsafeQueueUserWorkItem().
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
        </member>
        <member name="M:MindTouch.Threading.LegacyThreadPool.TryQueueWorkItem(System.Action)">
            <summary>
            Adds an item to the thread pool.  This method is implemented using System.Threading.ThreadPool::UnsafeQueueUserWorkItem().
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
            <returns>True if the work-item was enqueud, false otherwise.</returns>
        </member>
        <member name="M:MindTouch.Threading.LegacyThreadPool.ToString">
            <summary>
            Convert the dispatch queue into a string.
            </summary>
            <returns>String.</returns>
        </member>
        <member name="T:MindTouch.Threading.LockFreeCounter">
            <summary>
            Provides a thread-safe counter with out lock overhead.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.LockFreeCounter.#ctor(System.Int32)">
            <summary>
            Create a new counter with an initial value.
            </summary>
            <param name="value">Initial value.</param>
        </member>
        <member name="M:MindTouch.Threading.LockFreeCounter.Increment">
            <summary>
            Increment the counter by one.
            </summary>
            <returns>The counter value after increment.</returns>
        </member>
        <member name="M:MindTouch.Threading.LockFreeCounter.Decrement">
            <summary>
            Decrement the counter by one.
            </summary>
            <returns>The counter value after decrement.</returns>
        </member>
        <member name="M:MindTouch.Threading.LockFreeCounter.Add(System.Int32)">
            <summary>
            Add a value to the counter.
            </summary>
            <param name="value">Value to add.</param>
            <returns>The counter value after the add.</returns>
        </member>
        <member name="M:MindTouch.Threading.LockFreeCounter.Exchange(System.Int32)">
            <summary>
            Set the counter to a new value.
            </summary>
            <param name="value">The value to set the counter to.</param>
            <returns>The value of the counter before the new value was set.</returns>
        </member>
        <member name="M:MindTouch.Threading.LockFreeCounter.CompareAndSwap(System.Int32,System.Int32)">
            <summary>
            Compares the current value and a comparand for equality and, if they are equal, sets the counter to the new value.
            </summary>
            <param name="value">The value to try and set the counter to.</param>
            <param name="comparand">The expected current value of the counter.</param>
            <returns>The original value of the counter. If this value is different from the comparand, the set failed.</returns>
        </member>
        <member name="P:MindTouch.Threading.LockFreeCounter.Value">
            <summary>
            Current counter value.
            </summary>
        </member>
        <member name="T:MindTouch.Threading.RendezVousEvent">
            <summary>
            RendezVousEvent is a lightweight synchronization primitive.  It used to align exactly one signal source to a signal receiver (i.e. a rendez-vous).
            The order in which the signal is set and waited on are not important.  The RendezVousEvent will remember that it was signaled and immediately
            trigger the receiver. <br/>
            The receiver must be a continuation.  The RendezVousEvent does not allow for blocking wait.
            </summary>
        </member>
        <member name="F:MindTouch.Threading.RendezVousEvent.CaptureTaskState">
            <summary>
            Capture the state of the task (set to <see langword="False"/> by default.)
            </summary>
        </member>
        <member name="F:MindTouch.Threading.RendezVousEvent.Pending">
            <summary>
            Dictionary of pending events.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.RendezVousEvent.PinToThread">
            <summary>
            Ensure the receiver continuation is executed on the current thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">The RendezVousEvent is already pinned to an IDispatchQueue.</exception>
        </member>
        <member name="M:MindTouch.Threading.RendezVousEvent.PinTo(System.Threading.SynchronizationContext)">
            <summary>
            Ensure the receiver continuation is executed on the given synchronization context.
            </summary>
            <param name="context">Synchronization context for the receiver continuation.</param>
            <exception cref="T:System.InvalidOperationException">The RendezVousEvent is already pinned to an IDispatchQueue.</exception>
        </member>
        <member name="M:MindTouch.Threading.RendezVousEvent.PinTo(MindTouch.Threading.IDispatchQueue)">
            <summary>
            Ensure the receiver continuation is executed on the given IDispatchQueue.
            </summary>
            <param name="dispatchQueue">IDispatchQueue for the receiver continuation.</param>
            <exception cref="T:System.InvalidOperationException">The RendezVousEvent is already pinned to an IDispatchQueue.</exception>
        </member>
        <member name="M:MindTouch.Threading.RendezVousEvent.Signal">
            <summary>
            Signal the RendezVousEvent.  If a receiver continuation is present, trigger it.  
            Otherwise, store the signal until a continuation is registered.
            </summary>
            <exception cref="T:System.InvalidOperationException">The RendezVousEvent instance has already been signaled.</exception>
        </member>
        <member name="M:MindTouch.Threading.RendezVousEvent.Wait(System.Action)">
            <summary>
            Register the receiver continuation to activate when the RendezVousEvent instance is signaled.
            </summary>
            <param name="handler">Receiver continuation to invoke when RendezVousEvent instance is signaled.</param>
            <exception cref="T:System.InvalidOperationException">The RendezVousEvent instance has already a continuation.</exception>
        </member>
        <member name="M:MindTouch.Threading.RendezVousEvent.Abandon">
            <summary>
            Reset RendezVousEvent instance to its initial state without a signal and a continuation.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.RendezVousEvent.IsReadyOrWait(System.Action)">
            <summary>
            Atomically check if RendezVousEvent is already signaled.  If so, return true and mark the RendezVousEvent instance as having 
            completed its synchronization operation.  Otherwise, register the receiver continuation to activate when the RendezVousEvent 
            instance is signaled.
            </summary>
            <param name="handler">Receiver continuation to invoke when RendezVousEvent instance is signaled.</param>
            <returns>Returns true if RendezVousEvent instance is already signaled.</returns>
        </member>
        <member name="P:MindTouch.Threading.RendezVousEvent.PendingCounter">
            <summary>
            Returns the number of pending RendezVousEvent instances.  A pending RendezVousEvent instance has a continuation, but has not been signaled yet.
            </summary>
        </member>
        <member name="P:MindTouch.Threading.RendezVousEvent.HasCompleted">
            <summary>
            Returns true if the RendezVousEvent instance has been signaled and the receiver continuation has been triggered.
            </summary>
        </member>
        <member name="T:MindTouch.Threading.SynchronizationDispatchQueue">
            <summary>
            Provides an implementation of <see cref="T:MindTouch.Threading.IDispatchQueue"/> that immediately dispatches against a <see cref="T:System.Threading.SynchronizationContext"/>.
            </summary>
        </member>
        <member name="F:MindTouch.Threading.SynchronizationDispatchQueue.Context">
            <summary>
            The synchronization context of this dispatch queue.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.SynchronizationDispatchQueue.#ctor(System.Threading.SynchronizationContext)">
            <summary>
            Create a new dispatch queue for a given synchronization context.
            </summary>
            <param name="context">Context to post work items against.</param>
        </member>
        <member name="M:MindTouch.Threading.SynchronizationDispatchQueue.QueueWorkItem(System.Action)">
            <summary>
            Adds a work-item to the thread pool.  Depending on the implementation, this method may block the invoker
            or throw an exception if the thread pool cannot accept more items.
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
        </member>
        <member name="M:MindTouch.Threading.SynchronizationDispatchQueue.TryQueueWorkItem(System.Action)">
            <summary>
            In the context of this implementation, <see cref="M:MindTouch.Threading.SynchronizationDispatchQueue.TryQueueWorkItem(System.Action)"/> behaves identically to <see cref="M:MindTouch.Threading.SynchronizationDispatchQueue.QueueWorkItem(System.Action)"/>
            and will always return <see langword="True"/>.
            </summary>
            <param name="callback">Item to add to the thread pool.</param>
            <returns>Always returns <see langword="True"/>.</returns>
        </member>
        <member name="M:MindTouch.Threading.SynchronizationDispatchQueue.ToString">
            <summary>
            Convert the dispatch queue into a string.
            </summary>
            <returns>String.</returns>
        </member>
        <member name="T:MindTouch.Threading.Timer.GlobalClock">
            <summary>
            Provides a global timing mechanism that accepts registration of callback to be invoked by the clock. In most cases, a
            <see cref="T:MindTouch.Dream.TaskTimer"/> should be used rather than registering a callback directly with the global clock.
            </summary>
        </member>
        <member name="M:MindTouch.Threading.Timer.GlobalClock.AddCallback(System.String,System.Action{System.DateTime,System.TimeSpan})">
            <summary>
            Add a named callback to the clock.
            </summary>
            <param name="name">Unique key for the callback.</param>
            <param name="callback">Callback action.</param>
        </member>
        <member name="M:MindTouch.Threading.Timer.GlobalClock.RemoveCallback(System.Action{System.DateTime,System.TimeSpan})">
            <summary>
            Remove a callback by reference.
            </summary>
            <param name="callback">Callback to remove.</param>
        </member>
        <member name="T:MindTouch.Web.HttpUtil">
            <summary>
            Static utility class containing extension and helper methods for Web and Http related tasks.
            </summary>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.AddHeader(System.Net.HttpWebRequest,System.String,System.String)">
            <summary>
            Add a header to a web request.
            </summary>
            <param name="request">Target web request.</param>
            <param name="key">Header Key.</param>
            <param name="value">Header Value.</param>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.AddHeader(System.Net.HttpListenerResponse,System.String,System.String)">
            <summary>
            Add a header to a http response.
            </summary>
            <param name="response">Target http response</param>
            <param name="key">Header Key.</param>
            <param name="value">Header Value.</param>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.GetAuthentication(System.Uri,MindTouch.Dream.DreamHeaders,System.String@,System.String@)">
            <summary>
            Retrieve user credentials from a request uri and/or headers.
            </summary>
            <param name="uri">Request uri.</param>
            <param name="headers">Request headers.</param>
            <param name="username">Parsed user name.</param>
            <param name="password">Parsed password.</param>
            <returns><see langword="True"/> if the credentials were succesfully parsed from request information.</returns>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.RenderBasicAuthentication(System.String,System.String)">
            <summary>
            Render Basic Authentication value.
            </summary>
            <param name="username">User name.</param>
            <param name="password">Password.</param>
            <returns>Basic Authentication string.</returns>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.GetCultureInfoFromHeader(System.String,System.Globalization.CultureInfo)">
            <summary>
            Extract <see cref="T:System.Globalization.CultureInfo"/> from a header value.
            </summary>
            <param name="header">Header value to be parsed.</param>
            <param name="def">Default <see cref="T:System.Globalization.CultureInfo"/> to return in case no culture can be parsed from the header.</param>
            <returns>Parsed or default culture.</returns>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.ParseNameValuePairs(System.String)">
            <summary>
            Parse all name value pairs from a header string.
            </summary>
            <param name="header">Header to be parsed.</param>
            <returns>Dictionary of header name value pairs.</returns>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.FromHttpContext(System.Net.HttpListenerContext)">
            <summary>
            Derive request uri from the HttpContext.
            </summary>
            <param name="context">Source context.</param>
            <returns>Request uri.</returns>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.FromHttpContext(System.Web.HttpContext)">
            <summary>
            Derive request uri from the HttpContext.
            </summary>
            <param name="context">Source context.</param>
            <returns>Request uri.</returns>
        </member>
        <member name="M:MindTouch.Web.HttpUtil.FromHttpContextComponents(System.Uri,System.String)">
            <summary>
            Build request uri from decoded uri and raw path.
            </summary>
            <param name="uri">Already decoded uri.</param>
            <param name="rawpath">Raw path string.</param>
            <returns>Properly encoded request uri.</returns>
        </member>
        <member name="T:MindTouch.Xml.XAtomBase">
            <summary>
            Provides an a base Xml document abstraction based on <see cref="T:MindTouch.Xml.XDoc"/> with additional methods to ease creating Atom documents.
            </summary>
        </member>
        <member name="T:MindTouch.Xml.XDoc">
            <summary>
            A fluent interface-style Document Object Model for building, manipulating and ingesting Xml.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDoc.RFC_DATETIME_FORMAT">
            <summary>
            RFC DateTime format used by <see cref="T:MindTouch.Xml.XDoc"/>
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDoc.NS_DSIG">
            <summary>
            Namespace for XDoc digital signatures generated by <see cref="M:MindTouch.Xml.XDoc.Sign(System.Security.Cryptography.RSACryptoServiceProvider)"/>.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDoc.NS_XMLNS">
            <summary>
            XmlNs namespace Uri.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDoc.NS_XML">
            <summary>
            Xml namespace Uri.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDoc.Empty">
            <summary>
            An Empty XDoc instance.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDoc.XmlNameTable">
            <summary>
            Xml Name Table shared by <see cref="T:MindTouch.Xml.XDoc"/> instances
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDoc.op_Equality(MindTouch.Xml.XDoc,MindTouch.Xml.XDoc)">
            <summary>
            Equality operator to compare content equality of two XDoc instances.
            </summary>
            <param name="left">XDoc instance.</param>
            <param name="right">XDoc instance.</param>
            <returns><see langword="true"/></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.op_Inequality(MindTouch.Xml.XDoc,MindTouch.Xml.XDoc)">
            <summary>
            Inequality operator to compare content equality of two XDoc instances.
            </summary>
            <param name="left">XDoc instance.</param>
            <param name="right">XDoc instance.</param>
            <returns><see langword="true"/></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.RemoveAll(System.Collections.Generic.ICollection{MindTouch.Xml.XDoc})">
            <summary>
            Removes a collection of XDoc instances from their respective containers.
            </summary>
            <param name="items">Collection of XDoc instances to remove or Null.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.NewListXmlNode(System.Xml.XmlNodeList)">
            <summary>
            Converts an XmlNodeList instace into an XmlNode array.
            </summary>
            <param name="list">XmlNodeList to convert to an array. Cannot be null.</param>
            <returns>Array of XmlNode instances.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.CreateSelection(MindTouch.Xml.XDoc[])">
            <summary>
            Creates a new XDoc instance is a selection of documents.
            </summary>
            <param name="documents">Array of XDoc instances to convert into a selection.</param>
            <returns>Returns an XDoc instance that is a selection of XDoc instances.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.CreateNodesSelection(System.Xml.XmlNode[])">
            <summary>
            Creates a new XDoc instance is a selection of XmlNodes.
            </summary>
            <param name="nodes">Array of XmlNodes to convert into a selection.</param>
            <returns>Returns an XDoc instance that is a selection of the XmlNodes.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.CompareNode(System.Xml.XmlNode,System.Xml.XmlNode)">
            <summary>
            Recursively compares two XmlNode instances. Immediately returns false upon finding the first differnece between the two nodes.
            </summary>
            <param name="left">The left node. Cannot be null.</param>
            <param name="right">The right node. Cannot be null.</param>
            <returns>Returns true if the two nodes match, false otherwise.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.#ctor(System.String)">
            <summary>
            Creates a new XDoc instance with the given root tag.
            </summary>
            <param name="tag">Root tag of the new XML document. Cannot be null.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.#ctor(System.String,System.String)">
            <summary>
            Creates a new XDoc instance with the given root tag and the given implicit namespace.
            </summary>
            <param name="tag">Root tag of the new XML document. Cannot be null.</param>
            <param name="ns">Tag xml namespace.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new XDoc instance with the given root tag and the given implicit namespace.
            </summary>
            <param name="prefix">Prefix for the root tag of the new XML document.</param>
            <param name="tag">Root tag of the new XML document. Cannot be null.</param>
            <param name="ns">Tag xml namespace.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.#ctor(System.Xml.XmlDocument)">
            <summary>
            Creates a new XDoc instance from an existing XmlDocument instance.
            </summary>
            <param name="doc">XmlDocument instance with a root element. Cannot be null.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.#ctor(MindTouch.Xml.XDoc)">
            <summary>
            Creates a new XDoc instance from an existing, non-empty XDoc instance.
            </summary>
            <param name="doc">Non-empty XDoc instance. Cannot be null.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.#ctor(System.Xml.XmlNode[],System.Int32,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Protected constructor for XDoc inheritors for creating a new instance with the state of the old instance.
            </summary>
            <param name="list">List of nodes for the current cursor into the <see cref="T:System.Xml.XmlDocument"/>.</param>
            <param name="index">Index into the list of nodes providing the cursor pointer.</param>
            <param name="root">Root of the XDoc instance.</param>
            <param name="nsManager">Namespace manager to use with the instance.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AtPath(System.String,System.Xml.XmlNamespaceManager)">
            <summary>
            Returns a new rooted XDoc instance based on the supplied XPath. The selection starts at the given index position.
            </summary>
            <param name="path">XPath 1.0 expression to select XDoc instances in the current XDoc instance.</param>
            <param name="namespaces">Namespaces to use for xpath expression</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.As``1">
            <summary>
            Returns XDoc contents converted into given type.
            </summary>
            <typeparam name="T">Type to convet into (must be struct type)</typeparam>
            <returns>Converted value or null if no value is present</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.HasName(System.String)">
            <summary>
            Check the element/attribute name of the current XDoc.
            </summary>
            <param name="name">Name to compare with</param>
            <returns>True if the name matches</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.HasName(System.String,System.String)">
            <summary>
            Check the element/attribute name of the current XDoc.
            </summary>
            <param name="name">Name to compare with</param>
            <param name="namespaceUri">XML namespace to compar with</param>
            <returns>True if the name and namespace match</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.HasAttr(System.String)">
            <summary>
            Check if current XDoc contains named attribute.
            </summary>
            <param name="name">Name to compare with</param>
            <returns>True if the name matches an attribute</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.HasAttr(System.String,System.String)">
            <summary>
            Check if current XDoc contains named attribute.
            </summary>
            <param name="name">Name to compare with</param>
            <param name="namespaceUri">XML namespace to compar with</param>
            <returns>True if the name matches an attribute</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Clone">
            <summary>
            Returns a deep clone of the XDoc instance starting at the root XDoc instance.
            </summary>
            <returns>Deep clone of the root XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.MarkExclusive">
            <summary>
            Mark the current XDoc instance as exclusive.  This will skip the next Clone() operation when it occurs.
            </summary>
            <returns>XDoc instance marked as exclusive</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Copy">
            <summary>
            Returns a shallow copy of current XDoc instance.
            </summary>
            <returns>Shallow copy of the XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AtPosition(System.Int32)">
            <summary>
            Returns the XDoc instance at the index position in the XDoc selection.
            </summary>
            <param name="index">index position</param>
            <returns>selected XDoc node or Empty if index is out of bounds</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.String)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.String,System.String)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="namespaceUri">Attribute XML namespace</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,MindTouch.Dream.XUri)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.Int32)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.UInt32)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.Int64)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.UInt64)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.Single)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.Double)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.DateTime)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Attr(System.String,System.Boolean)">
            <summary>
            Add an attribute to the XDoc instance.
            </summary>
            <param name="tag">Attribute name</param>
            <param name="value">Value of the attribute</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Start(System.String)">
            <summary>
            Starts a new child element. (e.g. &lt;foo&gt;)
            </summary>
            <param name="tag">Element name</param>
            <returns>Created XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Start(System.String,System.String)">
            <summary>
            Starts a new child element. (e.g. &lt;foo&gt;)
            </summary>
            <param name="tag">Element name</param>
            <param name="namespaceUri">Element XML namespace</param>
            <returns>Created XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Elem(System.String)">
            <summary>
            Adds a complete child element.
            </summary>
            <param name="tag">Element name</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Elem(System.String,System.String)">
            <summary>
            Adds a complete child element.
            </summary>
            <param name="tag">Element name</param>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Elem(System.String,System.DateTime)">
            <summary>
            Adds a complete child element.
            </summary>
            <param name="tag">Element name</param>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Elem(System.String,System.Byte[])">
            <summary>
            Adds a complete child element.
            </summary>
            <param name="tag">Element name</param>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Elem(System.String,MindTouch.Dream.XUri)">
            <summary>
            Adds a complete child element.
            </summary>
            <param name="tag">Element name</param>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Elem(System.String,System.Object)">
            <summary>
            Adds a complete child.
            </summary>
            <param name="tag">Element name</param>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Value(System.String)">
            <summary>
            Adds a text node.
            </summary>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Value(System.DateTime)">
            <summary>
            Adds a text node.
            </summary>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Value(System.Boolean)">
            <summary>
            Adds a text node.
            </summary>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Value(System.Byte[])">
            <summary>
            Adds a text node.
            </summary>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Value(MindTouch.Dream.XUri)">
            <summary>
            Adds a text node.
            </summary>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Value(System.Object)">
            <summary>
            Adds a text node.
            </summary>
            <param name="value">Value to add</param>
            <returns>Current XDoc instance</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ReplaceValue(System.Boolean)">
            <summary>
            Replaces the text node with a new text node.
            </summary>
            <param name="value">Replacement value</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ReplaceValue(System.Byte[])">
            <summary>
            Replaces the text node with a new text node.
            </summary>
            <param name="value">Replacement value</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ReplaceValue(System.DateTime)">
            <summary>
            Replaces the text node with a new text node.
            </summary>
            <param name="value">Replacement value</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ReplaceValue(System.Object)">
            <summary>
            Replaces the text node with a new text node.
            </summary>
            <param name="value">Replacement value</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ReplaceValue(MindTouch.Dream.XUri)">
            <summary>
            Replaces the text node with a new text node.
            </summary>
            <param name="value">Replacement value</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ReplaceValue(System.String)">
            <summary>
            Replaces the text node with a new text node.
            </summary>
            <param name="value">Replacement value</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.InsertValueAt(System.String,System.String)">
            <summary>
            Inserts a text or attribute node at the given XPath expression, creating elements as needed.
            </summary>
            <param name="xpath">XPath expression</param>
            <param name="value">Value to insert</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.CDataSection(System.String)">
            <summary>
            Adds a CDATA section.
            </summary>
            <param name="value">Contents of the CDATA section.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Comment(System.String)">
            <summary>
            Adds an XML comment node.
            </summary>
            <param name="value">Comment text.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ConditionalComment(System.String,MindTouch.Xml.XDoc)">
            <summary>
            Adds a conditional XML comment node.
            </summary>
            <param name="condition">Condition expression.</param>
            <param name="contents">Comment text.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.End">
            <summary>
            Ends a child element. (e.g. &lt;/foo&gt;)
            </summary>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the markerNode is not found before reaching the root node or the document is empty</exception>
        </member>
        <member name="M:MindTouch.Xml.XDoc.End(System.Xml.XmlNode)">
            <summary>
            Ends child elements until the current node is the same as the marker node. Will throw an <see cref="T:System.InvalidOperationException"/> if
            the marker isn't encountered before the root. It is however fine to use the root as the marker node.
            </summary>
            <param name="markerNode">Xml node to use a marker of where the document was before the target <see cref="M:MindTouch.Xml.XDoc.Start(System.String)"/> was called.</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Thrown if the markerNode is not found before reaching the root node or the document is empty</exception>
        </member>
        <member name="M:MindTouch.Xml.XDoc.EndAll">
            <summary>
            Ends all child elements until the root XDoc instance is reached.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Remove">
            <summary>
            Removes this XDoc instance from the containing document.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.RemoveAttr(System.String)">
            <summary>
            Removes an attriute.
            </summary>
            <param name="name">Name of attribute to remove.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.RemoveAll">
            <summary>
            Removes all XDoc instances in current selection.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDoc.RemoveNodes">
            <summary>
            Removes all child nodes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Replace(MindTouch.Xml.XDoc)">
            <summary>
            Replaces this XDoc instance with another one.
            </summary>
            <param name="doc">Replacement XDoc instance.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ReplaceWithNodes(MindTouch.Xml.XDoc)">
            <summary>
            Replaces this XDoc instance with the child nodes of another one.
            </summary>
            <param name="doc">Container of replacement nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Replace(System.String)">
            <summary>
            Replaces this XDoc instance with a text node.
            </summary>
            <param name="value">Text value.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Replace(System.DateTime)">
            <summary>
            Replaces this XDoc instance with a text node.
            </summary>
            <param name="value">Text value.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Replace(System.Byte[])">
            <summary>
            Replaces this XDoc instance with a text node.
            </summary>
            <param name="value">Text value.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Replace(System.Object)">
            <summary>
            Replaces this XDoc instance with a text node.
            </summary>
            <param name="value">Text value.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Rename(System.String)">
            <summary>
            Change the name of the current element node. 
            </summary>
            <param name="name">New element name.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddNodesInFront(MindTouch.Xml.XDoc)">
            <summary>
            Prepend child nodes from another XDoc instance. 
            </summary>
            <param name="doc">Container of prepended nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddNodesBefore(MindTouch.Xml.XDoc)">
            <summary>
            Add child nodes from another XDoc instance before this one. 
            </summary>
            <param name="doc">Container of prepended nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddNodesAfter(MindTouch.Xml.XDoc)">
            <summary>
            Add child nodes from another XDoc instance after this one. 
            </summary>
            <param name="doc">Container of prepended nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddNodes(MindTouch.Xml.XDoc)">
            <summary>
            Adds child nodes from another XDoc instance. 
            </summary>
            <param name="doc">Container of added nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Add(MindTouch.Xml.XDoc)">
            <summary>
            Adds an XDoc instance.
            </summary>
            <param name="doc">XDoc instance to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAfter(System.String)">
            <summary>
            Adds a value after this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAfter(System.DateTime)">
            <summary>
            Adds a value after this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAfter(System.Boolean)">
            <summary>
            Adds a value after this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAfter(System.Byte[])">
            <summary>
            Adds a value after this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAfter(MindTouch.Dream.XUri)">
            <summary>
            Adds a value after this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAfter(System.Object)">
            <summary>
            Adds a value after this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAfter(MindTouch.Xml.XDoc)">
            <summary>
            Adds an XDoc instance after this one.
            </summary>
            <param name="doc">XDoc instance to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddBefore(System.String)">
            <summary>
            Adds a value before this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddBefore(System.DateTime)">
            <summary>
            Adds a value before this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddBefore(System.Boolean)">
            <summary>
            Adds a value before this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddBefore(System.Byte[])">
            <summary>
            Adds a value before this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddBefore(MindTouch.Dream.XUri)">
            <summary>
            Adds a value before this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddBefore(System.Object)">
            <summary>
            Adds a value before this XDoc instance.
            </summary>
            <param name="value">Value to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddBefore(MindTouch.Xml.XDoc)">
            <summary>
            Adds an XDoc instance before this one.
            </summary>
            <param name="doc">XDoc instance to add.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAll(MindTouch.Xml.XDoc)">
            <summary>
            Adds all XDoc instances in selection to this one.
            </summary>
            <param name="doc">XDoc selection.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAllBefore(MindTouch.Xml.XDoc)">
            <summary>
            Adds all XDoc instances in selection before this one.
            </summary>
            <param name="doc">XDoc selection.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAllAfter(MindTouch.Xml.XDoc)">
            <summary>
            Adds all XDoc instances in selection after this one.
            </summary>
            <param name="doc">XDoc selection.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.AddAll(System.Collections.Generic.IEnumerable{MindTouch.Xml.XDoc})">
            <summary>
            Adds all XDoc instances in collection to this one.
            </summary>
            <param name="collection">XDoc instance collection.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.GetContentsAsStrings">
            <summary>
            Returns the contents text for each XDoc instance in the selection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ForEach(System.Action{MindTouch.Xml.XDoc})">
            <summary>
            Invokes the given method for each XDoc instance in the selection.
            </summary>
            <param name="call">Action delegate.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Sort(System.Comparison{MindTouch.Xml.XDoc})">
            <summary>
            Sorts the child elements using the given comparer.
            </summary>
            <param name="comparer">Comparison delegate.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Filter(System.Predicate{MindTouch.Xml.XDoc})">
            <summary>
            Filters the child nodes using the given filter.
            </summary>
            <param name="filter">Predicate delegate.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.UsePrefix(System.String,System.String)">
            <summary>
            Adds prefix-namespace combination to the XML namespace manager.
            </summary>
            <param name="prefix">Prefix name.</param>
            <param name="namespace">Namespace URI.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.WithXslTransform(System.String)">
            <summary>
            Adds an XML stylesheet processing node.
            </summary>
            <param name="href">XSL tranform URI.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.TransformAsText(System.Xml.Xsl.XslCompiledTransform)">
            <summary>
            Converts this XDoc instance into a string using the given XSLT.
            </summary>
            <param name="xslt">XSLT instance.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.TransformAsXml(System.Xml.Xsl.XslCompiledTransform)">
            <summary>
            Converts this XDoc instance into a new XDoc instances using the givne XSLT.
            </summary>
            <param name="xslt">XSLT instance.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Save(System.String,System.Boolean)">
            <summary>
            Stores this XDoc instance into a file.
            </summary>
            <param name="filename">File path.</param>
            <param name="pretty">Use pretty formatting when saving.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Save(System.String)">
            <summary>
            Stores this XDoc instance into a file.
            </summary>
            <param name="filename">File path.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToXml">
            <summary>
            Creates a copy as an XmlDocument instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToXHtml">
            <summary>
            Renders the XDoc instance using XHTML compatible format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToXHtml(System.Boolean)">
            <summary>
            Renders the XDoc instance using XHTML compatible format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToInnerXHtml">
            <summary>
            Renders the XDoc instance using XHTML entities, but omitting the outermost element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToObject(System.Xml.Serialization.XmlSerializer)">
            <summary>
            Converts the XDoc instance into an object instance using the given XmlSerializer instance.
            </summary>
            <param name="serializer">XmlSerialize instance.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToString">
            <summary>
            Renders the XDoc instance as an XML document using UTF-8 encoding.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToString(System.Text.Encoding)">
            <summary>
            Renders the XDoc instance as an XML document using the given encoding.
            </summary>
            <param name="encoding">Text encoding.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToString(System.Text.Encoding,System.Boolean)">
            <summary>
            Renders the XDoc instance as an XML document using the given encoding.
            </summary>
            <param name="encoding">Text encoding.</param>
            <param name="declaration">Include XML declaration.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.WriteTo(System.IO.Stream)">
            <summary>
            Renders the XDoc instance as an XML document using UTF-8 encoding.
            </summary>
            <param name="stream">Stream to render the instance on.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.WriteTo(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Renders the XDoc instance as an XML document using the given encoding.
            </summary>
            <param name="stream">Stream to render the instance on.</param>
            <param name="encoding">Text encoding.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.WriteTo(System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>
            Renders the XDoc instance as an XML document using the given encoding.
            </summary>
            <param name="stream">Stream to render the instance on.</param>
            <param name="encoding">Text encoding.</param>
            <param name="declaration">Include XML declaration.</param>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToPrettyString">
            <summary>
            Renders the XDoc instance as an indented XML document using UTF-8 encoding.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToCompactString">
            <summary>
            Renders the XDoc instance omitting whitespace where possible using UTF-8 encoding.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToList">
            <summary>
            Converts the XDoc selection into a list of XDoc instances.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToBytes">
            <summary>
            Converts the XDoc instance into a byte array using UTF-8 encoding.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToBytes(System.Text.Encoding)">
            <summary>
            Converts the XDoc instance into a byte array using the given encoding.
            </summary>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ToKeyValuePairs">
            <summary>
            Converts the XDoc instance into an array of XPath expressions and text values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Equals(System.Object)">
            <summary>
            Compares this XDoc instance to another one.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.GetHashCode">
            <summary>
            Computes the hashcode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Sign(System.Security.Cryptography.RSACryptoServiceProvider)">
            <summary>
            Append XML digital signature to XDoc instance.
            </summary>
            <param name="rsa">RSA key to use for digital signature.</param>
            <returns>XDoc instance with appended XML digital signature.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.HasValidSignature(System.Security.Cryptography.RSACryptoServiceProvider)">
            <summary>
            Check if XDoc instance has an XML digital signature.
            </summary>
            <param name="rsa">RSA key to use for digital signature.</param>
            <returns>True if digital signature is present and valid.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Unsign">
            <summary>
            Remove XML digital signature from XDoc instance.
            </summary>
            <returns>XDoc instance without a digital signature.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.ReverseList">
            <summary>
            Return a new selection in reverse order.
            </summary>
            <returns>XDoc instance with elements listed in reverse order.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.VisitAll">
            <summary>
            Return an enumerable that visits all nodes recursively.
            </summary>
            <returns>A recursive enumerable for the XDoc instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.VisitAll(System.Action{MindTouch.Xml.XDoc})">
            <summary>
            Return an enumerable that visits all nodes recursively.
            </summary>
            <param name="nodeExitCallback">Callback called with the visited XDoc after it and its children have been visited.</param>
            <returns>A recursive enumerable for the XDoc instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.VisitOnly(System.Predicate{MindTouch.Xml.XDoc})">
            <summary>
            Return an enumerable that visits nodes recursively under condition.
            </summary>
            <param name="enumerateChildren">Test function to determine if the children of the current XDoc instance should be enumerated.</param>
            <returns>A recursive enumerable for the XDoc instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.VisitOnly(System.Predicate{MindTouch.Xml.XDoc},System.Action{MindTouch.Xml.XDoc})">
            <summary>
            Return an enumerable that visits nodes recursively under condition.
            </summary>
            <param name="enumerateChildren">Test function to determine if the children of the current XDoc instance should be enumerated.</param>
            <param name="nodeExitCallback">Callback called with the visited XDoc after it and its children have been visited.</param>
            <returns>A recursive enumerable for the XDoc instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDoc.Initialize(System.Xml.XmlNode[],System.Int32,System.Xml.XmlNode,System.Xml.XmlNamespaceManager)">
            <summary>
            Protected initializer for XDoc inheritors for setting the state of an existing instance.
            </summary>
            <param name="list">List of nodes for the current cursor into the <see cref="T:System.Xml.XmlDocument"/>.</param>
            <param name="index">Index into the list of nodes providing the cursor pointer.</param>
            <param name="root">Root of the XDoc instance.</param>
            <param name="nsManager">Namespace manager to use with the instance.</param>
        </member>
        <member name="P:MindTouch.Xml.XDoc.XhtmlDocType">
            <summary>
            Returns the DOCTYPE string to mark an XML document as being XHTML 1.0 Strict compliant.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Item(System.Int32)">
            <summary>
            Returns the XDoc at the given index of the root XDoc or an empty instance if the index is out of bounds.
            </summary>
            <param name="index">Index of the child instance of the root XDoc instance.</param>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Item(System.String)">
            <summary>
            Returns a new rooted XDoc instance based on the supplied XPath. The selection starts at the first result.
            </summary>
            <param name="path">XPath 1.0 expression to select XDoc instances in the current XDoc instance.</param>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Item(System.Xml.XmlNode)">
            <summary>
            Returns a new rooted XDoc instance representing the given XmlNode instance. The XmlNode instance must belong to the same XmlDocument instance as the XDoc instance.
            </summary>
            <param name="node">XmlNode instance to wrapt. Cannot be null.</param>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Doc">
            <summary>
            Returns the XDoc instance representing the root element of XmlDocument instance.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Root">
            <summary>
            Returns the root XDoc instance, which is either the XmlDocument element or the original node returned by an XPath expression.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.ListLength">
            <summary>
            Returns the number of items in the XDoc selection.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Contents">
            <summary>
            Returns the textual contents of the XDoc instance, including text and inner XML nodes.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Elements">
            <summary>
            Returns an XDoc selection that includes all child elements.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.First">
            <summary>
            Returns the first XDoc instance of the selection.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Next">
            <summary>
            Returns the next XDoc instance in the selection.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.IsEmpty">
            <summary>
            Returns true if the XDoc instance is empty.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.IsText">
            <summary>
            Returns true if the XDoc instance is an XmlText node.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Name">
            <summary>
            Returns the element or attribute name of the current XDoc instance.
            </summary>
            <exception cref="T:System.InvalidOperationException">XDoc is empty</exception>
        </member>
        <member name="P:MindTouch.Xml.XDoc.NamespaceURI">
            <summary>
            Returns the element or attribute namespace URI of the current XDoc instance.
            </summary>
            <exception cref="T:System.InvalidOperationException">XDoc is empty</exception>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Prefix">
            <summary>
            Returns the element or attribute prefix of the current XDoc instance.
            </summary>
            <exception cref="T:System.InvalidOperationException">XDoc is empty</exception>
        </member>
        <member name="P:MindTouch.Xml.XDoc.QualifiedName">
            <summary>
            Returns the element or attribute qualified name containing the namespace URI, prefix, and name of the current XDoc instance.
            </summary>
            <exception cref="T:System.InvalidOperationException">XDoc is empty</exception>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsXmlNode">
            <summary>
            Return the XmlNode wrappter by the XDoc instance. Use with caution and only if absolutely nessecary.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsText">
            <summary>
            Returns the value of all contained text nodes that are immediate children.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsInnerText">
            <summary>
            Returns the value of all contained text nodes including nested ones.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsBool">
            <summary>
            Returns the contents as boolean or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsByte">
            <summary>
            Returns the contents as byte or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsSByte">
            <summary>
            Returns the contents as signed byte or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsShort">
            <summary>
            Returns the contents as short integer or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsUShort">
            <summary>
            Returns the contents as unsigned short integer or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsInt">
            <summary>
            Returns the contents as integer or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsUInt">
            <summary>
            Returns the contents as unsigned integer or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsLong">
            <summary>
            Returns the contents as long integer or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsULong">
            <summary>
            Returns the contents as unsigned long integer or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsFloat">
            <summary>
            Returns the contents as floating-point number or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsDouble">
            <summary>
            Returns the contents as double floating-point number or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsDecimal">
            <summary>
            Returns the contents as decimal number or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsDate">
            <summary>
            Returns the contents as date/time or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsUri">
            <summary>
            Returns the contents as uri or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.AsBytes">
            <summary>
            Returns the contents as byte array or null if contents could not be converted.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Parent">
            <summary>
            Returns the parent XDoc instance or Empty if none exists.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.Language">
            <summary>
            Gets/sets the value of the xml:lang attribute. Returns null if no such attribute exists. Set null to clear out the attribute.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDoc.EmptyNamespaceUri">
            <summary>
            Gets the namespace URI associated with the empty prefix
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.ATOM_NAMESPACE">
            <summary>
            Atom xml namespace
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.#ctor(MindTouch.Xml.XDoc)">
            <summary>
            Create a new Atom document from an existing document.
            </summary>
            <param name="doc">The source document.</param>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.#ctor(System.String,System.DateTime)">
            <summary>
            Creates an Atom document with a given root tag and updated date.
            </summary>
            <param name="tag">Root tag.</param>
            <param name="updated">Date the document was last updated.</param>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.AddAuthor(System.String,MindTouch.Dream.XUri,System.String)">
            <summary>
            Add an author to the document.
            </summary>
            <param name="name">Author name.</param>
            <param name="uri">Uri to Author resource.</param>
            <param name="email">Author email.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.AddContributor(System.String,MindTouch.Dream.XUri,System.String)">
            <summary>
            Add a contributor to the document.
            </summary>
            <param name="name">Contributor name.</param>
            <param name="uri">Uri to Contributor resource.</param>
            <param name="email">Contributor email.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.AddCategory(System.String,MindTouch.Dream.XUri,System.String)">
            <summary>
            Add a category to the document.
            </summary>
            <param name="term">Category term.</param>
            <param name="scheme">Category scheme.</param>
            <param name="label">Category label.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.AddLink(MindTouch.Dream.XUri,MindTouch.Xml.XAtomBase.LinkRelation,MindTouch.Dream.MimeType,System.Nullable{System.Int64},System.String)">
            <summary>
            Add a link to the document.
            </summary>
            <param name="href">Uri to the linked resource.</param>
            <param name="relation">Relationship of the linked resource to the current document.</param>
            <param name="type">Type of resource being linked.</param>
            <param name="length">Size in bytes.</param>
            <param name="title">Title of the linked resource.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.AddText(System.String,System.String,System.String)">
            <summary>
            Add text to the document.
            </summary>
            <param name="tag">Enclosing tag for the text.</param>
            <param name="type">Type attribute for the enclosed.</param>
            <param name="text">Text content to add.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.AddText(System.String,MindTouch.Dream.MimeType,System.Byte[])">
            <summary>
            Add text to the document.
            </summary>
            <param name="tag">Enclosing tag for the text.</param>
            <param name="mime">Mime type of the enclosed text.</param>
            <param name="data">The text body as a byte array.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.AddText(System.String,MindTouch.Dream.MimeType,MindTouch.Xml.XDoc)">
            <summary>
            Add text to the document.
            </summary>
            <param name="tag">Enclosing tag for the text.</param>
            <param name="mime">Mime type of the enclosed text.</param>
            <param name="xml">The body document to add.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomBase.AddPerson(System.String,System.String,MindTouch.Dream.XUri,System.String)">
            <summary>
            Add a person reference to the document.
            </summary>
            <param name="tag">Enclosing tag for the person entry.</param>
            <param name="name">Person name.</param>
            <param name="uri">Uri to Person resource.</param>
            <param name="email">Person email.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="P:MindTouch.Xml.XAtomBase.Id">
            <summary>
            Atom Id uri.
            </summary>
        </member>
        <member name="T:MindTouch.Xml.XAtomBase.LinkRelation">
            <summary>
            Atom link rel attribute enumeration.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Alternate">
            <summary>
            Signifies a link that points to an alternate version of the current resource.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Related">
            <summary>
            Signifies a link that points to a resource that is related to the current content.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Self">
            <summary>
            Signifies a link to a resource that is the equivalent of the current content.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Enclosure">
            <summary>
            Signifies a link to a related resource that may be large in size or requires special handling.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Via">
            <summary>
            Signifies a link to a resource that is the source of the materail of the current content.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Edit">
            <summary>
            Signifies a link to the resource that allows editing of the current content.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.First">
            <summary>
            Signifies a link to furthest preceeding resource in a series of resources.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Last">
            <summary>
            Signifies a link to furthest following resource in a series of resources.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Next">
            <summary>
            Signifies a link to immediately following resource in a series of resources.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XAtomBase.LinkRelation.Previous">
            <summary>
            Signifies a link to immediately preceeding resource in a series of resources.
            </summary>
        </member>
        <member name="T:MindTouch.Xml.XAtomFeed">
            <summary>
            Provides a Atom feed document abstraction based on <see cref="T:MindTouch.Xml.XDoc"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XAtomFeed.#ctor(MindTouch.Xml.XDoc)">
            <summary>
            Parse an existing Atom feed into the <see cref="T:MindTouch.Xml.XAtomFeed"/> representation.
            </summary>
            <param name="doc">The document to parse as an atom feed.</param>
        </member>
        <member name="M:MindTouch.Xml.XAtomFeed.#ctor(System.String,MindTouch.Dream.XUri,System.DateTime)">
            <summary>
            Create a new Atom feed.
            </summary>
            <param name="title">Title of the feed.</param>
            <param name="link">Canonical uri to the feed resource.</param>
            <param name="updated">Last time the feed was updated.</param>
        </member>
        <member name="M:MindTouch.Xml.XAtomFeed.StartEntry(System.String,System.DateTime,System.DateTime)">
            <summary>
            Start a new entry block.
            </summary>
            <remarks>Behaves like the normal <see cref="M:MindTouch.Xml.XDoc.Start(System.String)"/> and sets the cursor to the new entry until a matching
            <see cref="M:MindTouch.Xml.XDoc.End"/> is encountered.</remarks>
            <param name="title">Entry title.</param>
            <param name="published">Entry publication date.</param>
            <param name="updated">Last time the entry was updated.</param>
            <returns>A new <see cref="T:MindTouch.Xml.XAtomEntry"/> as a node in the current document.</returns>
        </member>
        <member name="P:MindTouch.Xml.XAtomFeed.Entries">
            <summary>
            Get an array of all entries in the feed.
            </summary>
        </member>
        <member name="T:MindTouch.Xml.XAtomEntry">
            <summary>
            Provides a Atom feed entry document abstraction based on <see cref="T:MindTouch.Xml.XDoc"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XAtomEntry.#ctor(MindTouch.Xml.XDoc)">
            <summary>
            Parse an existing Atom feed entry into the <see cref="T:MindTouch.Xml.XAtomEntry"/> representation.
            </summary>
            <param name="doc">Document in the Atom feed entry format.</param>
        </member>
        <member name="M:MindTouch.Xml.XAtomEntry.#ctor(System.String,System.DateTime,System.DateTime)">
            <summary>
            Create a new Atom feed entry document.
            </summary>
            <param name="title">Entry title.</param>
            <param name="published">Entry publication date.</param>
            <param name="updated">Last time the entry was updated.</param>
        </member>
        <member name="M:MindTouch.Xml.XAtomEntry.AddContent(System.String)">
            <summary>
            Add content to the entry.
            </summary>
            <param name="text">Text body to add.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomEntry.AddContent(MindTouch.Dream.MimeType,MindTouch.Xml.XDoc)">
            <summary>
            Add a subdocument as content to the entry.
            </summary>
            <param name="mime">Mime type of the document to be added.</param>
            <param name="xml">Document to add.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomEntry.AddContent(MindTouch.Dream.MimeType,System.Byte[])">
            <summary>
            Add content to the entry.
            </summary>
            <param name="mime">Mime type of the content to be added.</param>
            <param name="data">Content as byte array.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomEntry.AddSummary(System.String)">
            <summary>
            Add an entry summary.
            </summary>
            <param name="text">Summary text.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XAtomEntry.AddSummary(MindTouch.Dream.MimeType,MindTouch.Xml.XDoc)">
            <summary>
            Add an entry summary document.
            </summary>
            <param name="mime">Mime type of the summary document to be added.</param>
            <param name="xml">Summary document.</param>
            <returns>Returns the current document instance.</returns>
        </member>
        <member name="P:MindTouch.Xml.XAtomEntry.Where">
            <summary>
            Entry Geo Rss Tag.
            </summary>
        </member>
        <member name="T:MindTouch.Xml.XDocCop">
            <summary>
            Provides a mechanism to verify and enforce document structure and content rules on an <see cref="T:MindTouch.Xml.XDoc"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.#ctor">
            <summary>
            Create a new instance without any predefined rules.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.#ctor(System.String[])">
            <summary>
            Create a new instance with a set of initial rules.
            </summary>
            <param name="rules">Array of rules.</param>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.AddRules(System.String[])">
            <summary>
            Add rules to the instance.
            </summary>
            <param name="rules">Array of rules.</param>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.AddRule(System.String)">
            <summary>
            Add a single rule to the instance.
            </summary>
            <param name="rule">Rule to add.</param>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.Enforce(MindTouch.Xml.XDoc)">
            <summary>
            Enforce the specified rules on the document.
            </summary>
            <param name="doc">Document to process.</param>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.Enforce(MindTouch.Xml.XDoc,System.Boolean)">
            <summary>
            Enforce the specified rules on the document.
            </summary>
            <param name="doc">Document to process.</param>
            <param name="removeIllegalElements">If <see langword="True"/> strip illegal elements from the document.</param>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.Verify(MindTouch.Xml.XDoc)">
            <summary>
            Verify that the document conforms to the specified rules.
            </summary>
            <param name="doc">Document to process.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.IsLegalElement(System.String)">
            <summary>
            Checks if the tag name is legal for the specified rules.
            </summary>
            <param name="tag">XML tag name to check.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.IsLegalAttribute(System.String,System.String)">
            <summary>
            Checks if the attribute name is legal for the given tag name is legal using the specified rules.
            </summary>
            <param name="tag">XML tag name to check.</param>
            <param name="name">XML attribute name to check.</param>
            <returns></returns>
        </member>
        <member name="M:MindTouch.Xml.XDocCop.ToString">
            <summary>
            Create a string representation of the document analysis.
            </summary>
            <returns>A string instance.</returns>
        </member>
        <member name="T:MindTouch.Xml.XDocDiff">
            <summary>
            Provides a facility for comparing <see cref="T:MindTouch.Xml.XDoc"/> instances.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Diff(MindTouch.Xml.XDoc,MindTouch.Xml.XDoc,System.Int32)">
            <summary>
            Diff two documents.
            </summary>
            <param name="left">Left hand document.</param>
            <param name="right">Right hand document.</param>
            <param name="maxsize">Maximum size of the difference response.</param>
            <returns>Array of difference tuples.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Diff(MindTouch.Xml.XDocDiff.Token[],MindTouch.Xml.XDocDiff.Token[],System.Int32)">
            <summary>
            Diff two token sets.
            </summary>
            <param name="left">Left hand token set.</param>
            <param name="right">Right hand token set.</param>
            <param name="maxsize">Maximum size of the difference response.</param>
            <returns>Array of difference tuples.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Merge(MindTouch.Xml.XDoc,MindTouch.Xml.XDoc,MindTouch.Xml.XDoc,System.Int32,System.ArrayMergeDiffPriority,System.Boolean@)">
            <summary>
            Perform a three-way merge of documents.
            </summary>
            <param name="original">Original document.</param>
            <param name="left">Left hand modification of document.</param>
            <param name="right">Right hand modification of document.</param>
            <param name="maxsize">Maximum size of the difference response.</param>
            <param name="priority">Merge priority.</param>
            <param name="conflict">Output of conflict flag.</param>
            <returns>Merged document.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Merge(MindTouch.Xml.XDocDiff.Token[],MindTouch.Xml.XDocDiff.Token[],MindTouch.Xml.XDocDiff.Token[],System.Int32,System.ArrayMergeDiffPriority,System.Boolean@)">
            <summary>
            Perform a three-way merge between token sets resulting in a document.
            </summary>
            <param name="original">Original Token set.</param>
            <param name="left">Left hand token set.</param>
            <param name="right">Right hand token set.</param>
            <param name="maxsize">Maximum size of the difference response.</param>
            <param name="priority">Merge priority.</param>
            <param name="conflict">Output of conflict flag.</param>
            <returns>Merged document.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Highlight(MindTouch.Tuplet{System.ArrayDiffKind,MindTouch.Xml.XDocDiff.Token}[])">
            <summary>
            Create a highlight document from a set of differences.
            </summary>
            <param name="diff">Difference set.</param>
            <returns>Highlight document.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Highlight(MindTouch.Tuplet{System.ArrayDiffKind,MindTouch.Xml.XDocDiff.Token}[],MindTouch.Xml.XDoc@,System.Collections.Generic.List{MindTouch.Tuplet{System.String,System.String,System.String}}@,MindTouch.Xml.XDoc@,MindTouch.Xml.XDoc@)">
            <summary>
            Create before, after and combined highlight documents for a set of differences.
            </summary>
            <param name="diff">Difference set.</param>
            <param name="combined">Output of combined highlight document.</param>
            <param name="combinedInvisible">Output of the combined invisible differences.</param>
            <param name="before">Output of before difference highlight document.</param>
            <param name="after">Output of after difference highlight document.</param>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Detokenize(MindTouch.Tuplet{System.ArrayDiffKind,MindTouch.Xml.XDocDiff.Token}[])">
            <summary>
            Create a document from a difference set.
            </summary>
            <param name="tokens">Difference set.</param>
            <returns>Detokenized document.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Tokenize(MindTouch.Xml.XDoc)">
            <summary>
            Convert a document to a token set.
            </summary>
            <param name="doc"></param>
            <returns>Set of tokens.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Write(MindTouch.Tuplet{System.ArrayDiffKind,MindTouch.Xml.XDocDiff.Token}[],System.IO.TextWriter)">
            <summary>
            Write a difference set.
            </summary>
            <param name="diffset">Difference set.</param>
            <param name="writer">TextWriter to write the set to.</param>
        </member>
        <member name="T:MindTouch.Xml.XDocDiff.Token">
            <summary>
            Provides a xml node token.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Token.Equal(MindTouch.Xml.XDocDiff.Token,MindTouch.Xml.XDocDiff.Token)">
            <summary>
            Compare two Token to determine whether they represent the same value.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="F:MindTouch.Xml.XDocDiff.Token.Type">
            <summary>
            Type of node.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDocDiff.Token.Value">
            <summary>
            String value of Xml node.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDocDiff.Token.Key">
            <summary>
            Unique key to identify token by.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Token.#ctor(System.Xml.XmlNodeType,System.String,System.Object)">
            <summary>
            Create a new node token.
            </summary>
            <param name="type">Type of node.</param>
            <param name="value">String value of node.</param>
            <param name="key">Unique key to identify token by.</param>
        </member>
        <member name="M:MindTouch.Xml.XDocDiff.Token.ToString">
            <summary>
            Return a string representation of the the Token's value.
            </summary>
            <returns>A string instance.</returns>
        </member>
        <member name="T:MindTouch.Xml.XDocWord">
            <summary>
            Provides a utility for extracting and replacing words from an xml document.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocWord.ConvertToWordList(MindTouch.Xml.XDoc)">
            <summary>
            Create a word list from an <see cref="T:MindTouch.Xml.XDoc"/> instance.
            </summary>
            <param name="doc">Document to extract words from.</param>
            <returns>Array of word instances.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocWord.ReplaceText(MindTouch.Xml.XDocWord[],MindTouch.Xml.XDocWord.ReplacementHandler)">
            <summary>
            Replace words in a document.
            </summary>
            <param name="wordlist">List of words to run replacement function for.</param>
            <param name="handler">Word replacement delegate.</param>
        </member>
        <member name="F:MindTouch.Xml.XDocWord.Value">
            <summary>
            The word.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDocWord.Offset">
            <summary>
            Word count offset into document.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XDocWord.Node">
            <summary>
            The Xml node containing the word.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocWord.ToString">
            <summary>
            Create a string represenation of the instance.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MindTouch.Xml.XDocWord.IsText">
            <summary>
            <see langword="True"/> if the node is a text node.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDocWord.IsWord">
            <summary>
            <see langword="True"/> if the parsed contents are an alphanumeric sequence.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XDocWord.Path">
            <summary>
            XPath to the Node.
            </summary>
        </member>
        <member name="T:MindTouch.Xml.XDocWord.ReplacementHandler">
            <summary>
            Delegate for replacing and <see cref="T:MindTouch.Xml.XDocWord"/> instance in a document with a new XmlNode.
            </summary>
            <param name="doc">Parent document node of the word.</param>
            <param name="word">Word to replace.</param>
            <returns>Replacement Xml node.</returns>
        </member>
        <member name="T:MindTouch.Xml.XDocFactory">
            <summary>
            Provides a static factory methods for creating <see cref="T:MindTouch.Xml.XDoc"/> instances.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocFactory.LoadFrom(System.String,MindTouch.Dream.MimeType)">
            <summary>
            Load a document from a file.
            </summary>
            <param name="filename">Path to document.</param>
            <param name="mime">Document mime-type.</param>
            <returns>New document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocFactory.From(System.IO.Stream,MindTouch.Dream.MimeType)">
            <summary>
            Create a document from a stream.
            </summary>
            <param name="stream">Document stream.</param>
            <param name="mime">Document mime-type.</param>
            <returns>New document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocFactory.From(System.String,MindTouch.Dream.MimeType)">
            <summary>
            Create a document from an xml string.
            </summary>
            <param name="value">Document string.</param>
            <param name="mime">Document mime-type.</param>
            <returns>New document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocFactory.From(System.Object,System.Xml.Serialization.XmlSerializer)">
            <summary>
            Create a document by serializing an object to xml.
            </summary>
            <param name="obj">Object to serialize.</param>
            <param name="serializer">Xml serializer instance.</param>
            <returns>New document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocFactory.From(System.IO.TextReader,MindTouch.Dream.MimeType)">
            <summary>
            Create a document from a text reader.
            </summary>
            <param name="reader">Document text reader.</param>
            <param name="mime">Document mime-type.</param>
            <returns>New document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocFactory.From(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String)">
            <summary>
            Create a document from a collection of key/value pairs
            </summary>
            <param name="values">Enumeration of key/value pairs.</param>
            <param name="root">Name of the root element for document.</param>
            <returns></returns>
        </member>
        <member name="T:MindTouch.Xml.XDocUtil">
            <summary>
            Provides static helper methods for working with <see cref="T:MindTouch.Xml.XDoc"/>.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XDocUtil.TryParseXmlDateTime(System.String,System.DateTime@)">
            <summary>
            Try to parse an xml datetime string.
            </summary>
            <param name="value">String value.</param>
            <param name="date">Output of parsed Datetime.</param>
            <returns><see langword="True"/> if a <see cref="T:System.DateTime"/> instance was successfully parsed.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocUtil.EncodeXmlString(System.String)">
            <summary>
            Encode a string into xml-safe form.
            </summary>
            <param name="text">String to encode.</param>
            <returns>Encoded string.</returns>
        </member>
        <member name="M:MindTouch.Xml.XDocUtil.CollapseNodeList(System.Collections.IEnumerable)">
            <summary>
            Collapse a list of <see cref="T:System.Xml.XmlNode"/> instances into a dictionary of node name and matching nodes.
            </summary>
            <param name="nodes">Enumeration of <see cref="T:System.Xml.XmlNode"/>.</param>
            <returns>Dictionary indexed by XmlNode names containing all nodes for that name.</returns>
        </member>
        <member name="T:MindTouch.Xml.VersitUtil">
            <summary>
            Provides static helper functions for creating Xml documents from Versit documents (VCal, VCard).
            </summary>
        </member>
        <member name="F:MindTouch.Xml.VersitUtil.MAX_VERSIT_LINE_LENGTH">
            <summary>
            Max line length for Versit format, 76.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.VersitUtil.ToVersit(MindTouch.Xml.XDoc)">
            <summary>
            Convert a versit based xml document to the versit string serialization.
            </summary>
            <param name="doc">Source document.</param>
            <returns>Versit string serialization.</returns>
        </member>
        <member name="M:MindTouch.Xml.VersitUtil.FromVersit(System.String,System.String)">
            <summary>
            Parse a Versit string into an Xml document.
            </summary>
            <param name="versit">Versit string.</param>
            <param name="root">Name to use as thexml document root node.</param>
            <returns>Xml document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.VersitUtil.FromVersit(System.IO.TextReader,System.String)">
            <summary>
            Read a Versit string from a text reader and parse it into an Xml document.
            </summary>
            <param name="reader">Source reader.</param>
            <param name="root">Name to use as thexml document root node.</param>
            <returns>Xml document instance.</returns>
        </member>
        <member name="T:MindTouch.Xml.JsonUtil">
            <summary>
            Provides extension methods for converting Xml into Json.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.JsonUtil.ToJson(MindTouch.Xml.XDoc)">
            <summary>
            Convert an xml document into a Json string.
            </summary>
            <param name="doc">Document to convert.</param>
            <returns>Json string.</returns>
        </member>
        <member name="M:MindTouch.Xml.JsonUtil.ToJsonp(MindTouch.Xml.XDoc)">
            <summary>
            Convert an xml document into a Json-p string.
            </summary>
            <param name="doc">Document to convert.</param>
            <returns>Json string.</returns>
        </member>
        <member name="T:MindTouch.Xml.XSpanUtil">
            <summary>
            Provides static helpers for converting regular Xml documents to and from XSpan format.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XSpanUtil.FromXSpan(MindTouch.Xml.XDoc)">
            <summary>
            Convert an XSpan document to a regular Xml document.
            </summary>
            <param name="xspan">XSpan document.</param>
            <returns>New Xml document instance.</returns>
        </member>
        <member name="M:MindTouch.Xml.XSpanUtil.ToXSpan(MindTouch.Xml.XDoc)">
            <summary>
            Convert an Xml document to XSpan format.
            </summary>
            <param name="doc">Xml document to be converted.</param>
            <returns>XSpan xml document.</returns>
        </member>
        <member name="T:MindTouch.Xml.XPostUtil">
            <summary>
            Provides static helpers for converting between a key/value POST argument body and an Xml representation.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XPostUtil.FromXPathValuePairs(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.String)">
            <summary>
            Convert a key/value pair into an xml document.
            </summary>
            <param name="enumerator">Enumerable of key value pairs.</param>
            <param name="root">Name of the root node of the output document.</param>
            <returns>New Xml document.</returns>
        </member>
        <member name="M:MindTouch.Xml.XPostUtil.ToXPathValuePairs(MindTouch.Xml.XDoc)">
            <summary>
            Convert an xml document into a key/value pair list.
            </summary>
            <param name="doc">Document to convert.</param>
            <returns>Array of key/value pairs.</returns>
        </member>
        <member name="T:MindTouch.Xml.XSoap">
            <summary>
            Simple soap envelope extension on top of XDoc for building Soap messages.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XSoap.SOAP_NAMESPACE">
            <summary>
            Soap envelope namespace uri.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XSoap.SOAP_ENCODING_NAMESPACE">
            <summary>
            Soap encoding namespace uri.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XSoap.XSI_NAMESPACE">
            <summary>
            Xml Schema instance namespace uri.
            </summary>
        </member>
        <member name="F:MindTouch.Xml.XSoap.XSD_NAMESPACE">
            <summary>
            Xml Schema namespace uri.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XSoap.#ctor(MindTouch.Xml.XDoc)">
            <summary>
            Create a version of an Xml document with the soap namespaces and prefixes imported.
            </summary>
            <param name="doc">Existing document to wrap.</param>
        </member>
        <member name="M:MindTouch.Xml.XSoap.#ctor(System.String)">
            <summary>
            Create a new empty soap envelope.
            </summary>
            <param name="tag">Root node name.</param>
        </member>
        <member name="M:MindTouch.Xml.XSoap.#ctor">
            <summary>
            Create a new empty envelope.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XSoap.Header">
            <summary>
            Accesss the envelope header.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XSoap.Body">
            <summary>
            Access the envelope body.
            </summary>
        </member>
        <member name="P:MindTouch.Xml.XSoap.Fault">
            <summary>
            Access the body fault message (if one exists).
            </summary>
        </member>
        <member name="T:MindTouch.Xml.XException">
            <summary>
            Provides a way to create an Xml serialization of an exception.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XException.MakeException(MindTouch.Xml.XDoc)">
            <summary>
            Deserialize an exception from an Xml document represenation.
            </summary>
            <param name="exception">Exception Xml document.</param>
            <returns>Deserialized exception.</returns>
        </member>
        <member name="M:MindTouch.Xml.XException.AddStackTrace(MindTouch.Xml.XDoc,System.String)">
            <summary>
            Add a stack trace to an Xml serialized exception.
            </summary>
            <param name="exception">Xml serialized exception.</param>
            <param name="stacktrace">Stack trace.</param>
        </member>
        <member name="M:MindTouch.Xml.XException.#ctor(System.Exception)">
            <summary>
            Serialize an exception into xml.
            </summary>
            <param name="e">The exception to serialize.</param>
        </member>
        <member name="T:MindTouch.Xml.XMessage">
            <summary>
            Provides a mechanism for serializing a <see cref="T:MindTouch.Dream.DreamMessage"/> as an Xml document.
            </summary>
        </member>
        <member name="M:MindTouch.Xml.XMessage.#ctor(MindTouch.Dream.DreamMessage)">
            <summary>
            Serialize message into Xml.
            </summary>
            <param name="message">Message to serialize.</param>
        </member>
    </members>
</doc>
